<Type Name="RuntimeTypeBase" FullName="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase">
  <TypeSignature Language="C#" Value="public abstract class RuntimeTypeBase : Microsoft.EntityFrameworkCore.Infrastructure.RuntimeAnnotatableBase, Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase" FrameworkAlternate="efcore-10.0;efcore-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit RuntimeTypeBase extends Microsoft.EntityFrameworkCore.Infrastructure.RuntimeAnnotatableBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-10.0;efcore-9.0" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class RuntimeTypeBase&#xA;Inherits RuntimeAnnotatableBase&#xA;Implements IRuntimeTypeBase" FrameworkAlternate="efcore-10.0;efcore-9.0" />
  <TypeSignature Language="F#" Value="type RuntimeTypeBase = class&#xA;    inherit RuntimeAnnotatableBase&#xA;    interface IRuntimeTypeBase&#xA;    interface ITypeBase&#xA;    interface IReadOnlyTypeBase&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IAnnotatable" FrameworkAlternate="efcore-10.0;efcore-9.0" />
  <TypeSignature Language="C#" Value="public abstract class RuntimeTypeBase : Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBase, Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase" FrameworkAlternate="efcore-8.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit RuntimeTypeBase extends Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-8.0" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class RuntimeTypeBase&#xA;Inherits AnnotatableBase&#xA;Implements IRuntimeTypeBase" FrameworkAlternate="efcore-8.0" />
  <TypeSignature Language="F#" Value="type RuntimeTypeBase = class&#xA;    inherit AnnotatableBase&#xA;    interface IRuntimeTypeBase&#xA;    interface ITypeBase&#xA;    interface IReadOnlyTypeBase&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IAnnotatable" FrameworkAlternate="efcore-8.0" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Infrastructure.RuntimeAnnotatableBase</BaseTypeName>
    <BaseTypeName FrameworkAlternate="efcore-8.0">Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.ITypeBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
                Represents a structural type in a model.
            </summary>
    <remarks>
                See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see> for more information and examples.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected RuntimeTypeBase (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.RuntimeModel model, Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase? baseType, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, System.Reflection.PropertyInfo? indexerPropertyInfo, bool propertyBag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.RuntimeModel model, class Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase baseType, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, class System.Reflection.PropertyInfo indexerPropertyInfo, bool propertyBag) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.RuntimeModel,Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Reflection.PropertyInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, type As Type, model As RuntimeModel, baseType As RuntimeTypeBase, changeTrackingStrategy As ChangeTrackingStrategy, indexerPropertyInfo As PropertyInfo, propertyBag As Boolean)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase : string * Type * Microsoft.EntityFrameworkCore.Metadata.RuntimeModel * Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase" Usage="new Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase (name, type, model, baseType, changeTrackingStrategy, indexerPropertyInfo, propertyBag)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.RuntimeModel" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="baseType" Type="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase" Index="3" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="4" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="indexerPropertyInfo" Type="System.Reflection.PropertyInfo" Index="5" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyBag" Type="System.Boolean" Index="6" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="baseType">To be added.</param>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="indexerPropertyInfo">To be added.</param>
        <param name="propertyBag">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected RuntimeTypeBase (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.RuntimeModel model, Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase? baseType, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, System.Reflection.PropertyInfo? indexerPropertyInfo, bool propertyBag, int derivedTypesCount, int propertyCount, int complexPropertyCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.RuntimeModel model, class Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase baseType, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, class System.Reflection.PropertyInfo indexerPropertyInfo, bool propertyBag, int32 derivedTypesCount, int32 propertyCount, int32 complexPropertyCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.RuntimeModel,Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Reflection.PropertyInfo,System.Boolean,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, type As Type, model As RuntimeModel, baseType As RuntimeTypeBase, changeTrackingStrategy As ChangeTrackingStrategy, indexerPropertyInfo As PropertyInfo, propertyBag As Boolean, derivedTypesCount As Integer, propertyCount As Integer, complexPropertyCount As Integer)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase : string * Type * Microsoft.EntityFrameworkCore.Metadata.RuntimeModel * Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool * int * int * int -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase" Usage="new Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase (name, type, model, baseType, changeTrackingStrategy, indexerPropertyInfo, propertyBag, derivedTypesCount, propertyCount, complexPropertyCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-9.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="efcore-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.RuntimeModel" Index="2" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="baseType" Type="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase" Index="3" FrameworkAlternate="efcore-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="4" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="indexerPropertyInfo" Type="System.Reflection.PropertyInfo" Index="5" FrameworkAlternate="efcore-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyBag" Type="System.Boolean" Index="6" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="derivedTypesCount" Type="System.Int32" Index="7" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="propertyCount" Type="System.Int32" Index="8" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="complexPropertyCount" Type="System.Int32" Index="9" FrameworkAlternate="efcore-9.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="baseType">To be added.</param>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="indexerPropertyInfo">To be added.</param>
        <param name="propertyBag">To be added.</param>
        <param name="derivedTypesCount">To be added.</param>
        <param name="propertyCount">To be added.</param>
        <param name="complexPropertyCount">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected RuntimeTypeBase (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.RuntimeModel model, Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase? baseType, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, System.Reflection.PropertyInfo? indexerPropertyInfo, bool propertyBag, string? discriminatorProperty, object? discriminatorValue, int derivedTypesCount, int propertyCount, int complexPropertyCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.RuntimeModel model, class Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase baseType, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, class System.Reflection.PropertyInfo indexerPropertyInfo, bool propertyBag, string discriminatorProperty, object discriminatorValue, int32 derivedTypesCount, int32 propertyCount, int32 complexPropertyCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.RuntimeModel,Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Reflection.PropertyInfo,System.Boolean,System.String,System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, type As Type, model As RuntimeModel, baseType As RuntimeTypeBase, changeTrackingStrategy As ChangeTrackingStrategy, indexerPropertyInfo As PropertyInfo, propertyBag As Boolean, discriminatorProperty As String, discriminatorValue As Object, derivedTypesCount As Integer, propertyCount As Integer, complexPropertyCount As Integer)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase : string * Type * Microsoft.EntityFrameworkCore.Metadata.RuntimeModel * Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool * string * obj * int * int * int -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase" Usage="new Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase (name, type, model, baseType, changeTrackingStrategy, indexerPropertyInfo, propertyBag, discriminatorProperty, discriminatorValue, derivedTypesCount, propertyCount, complexPropertyCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.RuntimeModel" Index="2" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="baseType" Type="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase" Index="3" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="4" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="indexerPropertyInfo" Type="System.Reflection.PropertyInfo" Index="5" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="propertyBag" Type="System.Boolean" Index="6" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="discriminatorProperty" Type="System.String" Index="7" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="discriminatorValue" Type="System.Object" Index="8" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="derivedTypesCount" Type="System.Int32" Index="9" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="propertyCount" Type="System.Int32" Index="10" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="complexPropertyCount" Type="System.Int32" Index="11" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="baseType">To be added.</param>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="indexerPropertyInfo">To be added.</param>
        <param name="propertyBag">To be added.</param>
        <param name="discriminatorProperty">To be added.</param>
        <param name="discriminatorValue">To be added.</param>
        <param name="derivedTypesCount">To be added.</param>
        <param name="propertyCount">To be added.</param>
        <param name="complexPropertyCount">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty AddComplexProperty (string name, Type clrType, string targetTypeName, Type targetType, System.Reflection.PropertyInfo? propertyInfo = default, System.Reflection.FieldInfo? fieldInfo = default, Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode = Microsoft.EntityFrameworkCore.PropertyAccessMode.PreferField, bool nullable = false, bool collection = false, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy = Microsoft.EntityFrameworkCore.ChangeTrackingStrategy.Snapshot, System.Reflection.PropertyInfo? indexerPropertyInfo = default, bool propertyBag = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty AddComplexProperty(string name, class System.Type clrType, string targetTypeName, class System.Type targetType, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode, bool nullable, bool collection, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, class System.Reflection.PropertyInfo indexerPropertyInfo, bool propertyBag) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.AddComplexProperty(System.String,System.Type,System.String,System.Type,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.PropertyAccessMode,System.Boolean,System.Boolean,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Reflection.PropertyInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddComplexProperty (name As String, clrType As Type, targetTypeName As String, targetType As Type, Optional propertyInfo As PropertyInfo = Nothing, Optional fieldInfo As FieldInfo = Nothing, Optional propertyAccessMode As PropertyAccessMode = Microsoft.EntityFrameworkCore.PropertyAccessMode.PreferField, Optional nullable As Boolean = false, Optional collection As Boolean = false, Optional changeTrackingStrategy As ChangeTrackingStrategy = Microsoft.EntityFrameworkCore.ChangeTrackingStrategy.Snapshot, Optional indexerPropertyInfo As PropertyInfo = Nothing, Optional propertyBag As Boolean = false) As RuntimeComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member AddComplexProperty : string * Type * string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.PropertyAccessMode * bool * bool * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&#xA;override this.AddComplexProperty : string * Type * string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.PropertyAccessMode * bool * bool * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty" Usage="runtimeTypeBase.AddComplexProperty (name, clrType, targetTypeName, targetType, propertyInfo, fieldInfo, propertyAccessMode, nullable, collection, changeTrackingStrategy, indexerPropertyInfo, propertyBag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="clrType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetTypeName" Type="System.String" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetType" Type="System.Type" Index="3" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="4" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" Index="5" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyAccessMode" Type="Microsoft.EntityFrameworkCore.PropertyAccessMode" Index="6" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="nullable" Type="System.Boolean" Index="7" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="8" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="9" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="indexerPropertyInfo" Type="System.Reflection.PropertyInfo" Index="10" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyBag" Type="System.Boolean" Index="11" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property to add.</param>
        <param name="clrType">The type of value the property will hold.</param>
        <param name="targetTypeName">The name of the complex type to be added.</param>
        <param name="targetType">The CLR type that is used to represent instances of this complex type.</param>
        <param name="propertyInfo">The corresponding CLR property or <see langword="null" /> for a shadow property.</param>
        <param name="fieldInfo">The corresponding CLR field or <see langword="null" /> for a shadow property.</param>
        <param name="propertyAccessMode">The <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> used for this property.</param>
        <param name="nullable">A value indicating whether this property can contain <see langword="null" />.</param>
        <param name="collection">Indicates whether the property represents a collection.</param>
        <param name="changeTrackingStrategy">The change tracking strategy for this complex type.</param>
        <param name="indexerPropertyInfo">The <see cref="T:System.Reflection.PropertyInfo" /> for the indexer on the associated CLR type if one exists.</param>
        <param name="propertyBag">
                A value indicating whether this entity type has an indexer which is able to contain arbitrary properties
                and a method that can be used to determine whether a given indexer property contains a value.
            </param>
        <summary>
                Adds a complex property to this entity type.
            </summary>
        <returns>The newly created property.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty AddComplexProperty (string name, Type clrType, string targetTypeName, Type targetType, System.Reflection.PropertyInfo? propertyInfo = default, System.Reflection.FieldInfo? fieldInfo = default, Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode = Microsoft.EntityFrameworkCore.PropertyAccessMode.PreferField, bool nullable = false, bool collection = false, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy = Microsoft.EntityFrameworkCore.ChangeTrackingStrategy.Snapshot, System.Reflection.PropertyInfo? indexerPropertyInfo = default, bool propertyBag = false, int propertyCount = 0, int complexPropertyCount = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty AddComplexProperty(string name, class System.Type clrType, string targetTypeName, class System.Type targetType, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode, bool nullable, bool collection, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, class System.Reflection.PropertyInfo indexerPropertyInfo, bool propertyBag, int32 propertyCount, int32 complexPropertyCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.AddComplexProperty(System.String,System.Type,System.String,System.Type,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.PropertyAccessMode,System.Boolean,System.Boolean,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Reflection.PropertyInfo,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddComplexProperty (name As String, clrType As Type, targetTypeName As String, targetType As Type, Optional propertyInfo As PropertyInfo = Nothing, Optional fieldInfo As FieldInfo = Nothing, Optional propertyAccessMode As PropertyAccessMode = Microsoft.EntityFrameworkCore.PropertyAccessMode.PreferField, Optional nullable As Boolean = false, Optional collection As Boolean = false, Optional changeTrackingStrategy As ChangeTrackingStrategy = Microsoft.EntityFrameworkCore.ChangeTrackingStrategy.Snapshot, Optional indexerPropertyInfo As PropertyInfo = Nothing, Optional propertyBag As Boolean = false, Optional propertyCount As Integer = 0, Optional complexPropertyCount As Integer = 0) As RuntimeComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member AddComplexProperty : string * Type * string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.PropertyAccessMode * bool * bool * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool * int * int -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&#xA;override this.AddComplexProperty : string * Type * string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.PropertyAccessMode * bool * bool * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool * int * int -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty" Usage="runtimeTypeBase.AddComplexProperty (name, clrType, targetTypeName, targetType, propertyInfo, fieldInfo, propertyAccessMode, nullable, collection, changeTrackingStrategy, indexerPropertyInfo, propertyBag, propertyCount, complexPropertyCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="clrType" Type="System.Type" Index="1" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="targetTypeName" Type="System.String" Index="2" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="targetType" Type="System.Type" Index="3" FrameworkAlternate="efcore-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="4" FrameworkAlternate="efcore-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" Index="5" FrameworkAlternate="efcore-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyAccessMode" Type="Microsoft.EntityFrameworkCore.PropertyAccessMode" Index="6" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="nullable" Type="System.Boolean" Index="7" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="8" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="9" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="indexerPropertyInfo" Type="System.Reflection.PropertyInfo" Index="10" FrameworkAlternate="efcore-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyBag" Type="System.Boolean" Index="11" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="propertyCount" Type="System.Int32" Index="12" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="complexPropertyCount" Type="System.Int32" Index="13" FrameworkAlternate="efcore-9.0" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property to add.</param>
        <param name="clrType">The type of value the property will hold.</param>
        <param name="targetTypeName">The name of the complex type to be added.</param>
        <param name="targetType">The CLR type that is used to represent instances of this complex type.</param>
        <param name="propertyInfo">The corresponding CLR property or <see langword="null" /> for a shadow property.</param>
        <param name="fieldInfo">The corresponding CLR field or <see langword="null" /> for a shadow property.</param>
        <param name="propertyAccessMode">The <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> used for this property.</param>
        <param name="nullable">A value indicating whether this property can contain <see langword="null" />.</param>
        <param name="collection">Indicates whether the property represents a collection.</param>
        <param name="changeTrackingStrategy">The change tracking strategy for this complex type.</param>
        <param name="indexerPropertyInfo">The <see cref="T:System.Reflection.PropertyInfo" /> for the indexer on the associated CLR type if one exists.</param>
        <param name="propertyBag">
                A value indicating whether this entity type has an indexer which is able to contain arbitrary properties
                and a method that can be used to determine whether a given indexer property contains a value.
            </param>
        <param name="propertyCount">The expected number of declared properties for this complex type.</param>
        <param name="complexPropertyCount">The expected number of declared complex properties for this complex type.</param>
        <summary>
                Adds a complex property to this entity type.
            </summary>
        <returns>The newly created property.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty AddComplexProperty (string name, Type clrType, string targetTypeName, Type targetType, System.Reflection.PropertyInfo? propertyInfo = default, System.Reflection.FieldInfo? fieldInfo = default, Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode = Microsoft.EntityFrameworkCore.PropertyAccessMode.PreferField, bool nullable = false, bool collection = false, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy = Microsoft.EntityFrameworkCore.ChangeTrackingStrategy.Snapshot, System.Reflection.PropertyInfo? indexerPropertyInfo = default, bool propertyBag = false, string? discriminatorProperty = default, object? discriminatorValue = default, int propertyCount = 0, int complexPropertyCount = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty AddComplexProperty(string name, class System.Type clrType, string targetTypeName, class System.Type targetType, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode, bool nullable, bool collection, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, class System.Reflection.PropertyInfo indexerPropertyInfo, bool propertyBag, string discriminatorProperty, object discriminatorValue, int32 propertyCount, int32 complexPropertyCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.AddComplexProperty(System.String,System.Type,System.String,System.Type,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.PropertyAccessMode,System.Boolean,System.Boolean,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Reflection.PropertyInfo,System.Boolean,System.String,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddComplexProperty (name As String, clrType As Type, targetTypeName As String, targetType As Type, Optional propertyInfo As PropertyInfo = Nothing, Optional fieldInfo As FieldInfo = Nothing, Optional propertyAccessMode As PropertyAccessMode = Microsoft.EntityFrameworkCore.PropertyAccessMode.PreferField, Optional nullable As Boolean = false, Optional collection As Boolean = false, Optional changeTrackingStrategy As ChangeTrackingStrategy = Microsoft.EntityFrameworkCore.ChangeTrackingStrategy.Snapshot, Optional indexerPropertyInfo As PropertyInfo = Nothing, Optional propertyBag As Boolean = false, Optional discriminatorProperty As String = Nothing, Optional discriminatorValue As Object = Nothing, Optional propertyCount As Integer = 0, Optional complexPropertyCount As Integer = 0) As RuntimeComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member AddComplexProperty : string * Type * string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.PropertyAccessMode * bool * bool * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool * string * obj * int * int -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&#xA;override this.AddComplexProperty : string * Type * string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.PropertyAccessMode * bool * bool * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool * string * obj * int * int -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty" Usage="runtimeTypeBase.AddComplexProperty (name, clrType, targetTypeName, targetType, propertyInfo, fieldInfo, propertyAccessMode, nullable, collection, changeTrackingStrategy, indexerPropertyInfo, propertyBag, discriminatorProperty, discriminatorValue, propertyCount, complexPropertyCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="clrType" Type="System.Type" Index="1" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="targetTypeName" Type="System.String" Index="2" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="targetType" Type="System.Type" Index="3" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="4" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" Index="5" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyAccessMode" Type="Microsoft.EntityFrameworkCore.PropertyAccessMode" Index="6" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="nullable" Type="System.Boolean" Index="7" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="8" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="9" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="indexerPropertyInfo" Type="System.Reflection.PropertyInfo" Index="10" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyBag" Type="System.Boolean" Index="11" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="discriminatorProperty" Type="System.String" Index="12" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="discriminatorValue" Type="System.Object" Index="13" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyCount" Type="System.Int32" Index="14" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="complexPropertyCount" Type="System.Int32" Index="15" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property to add.</param>
        <param name="clrType">The type of value the property will hold.</param>
        <param name="targetTypeName">The name of the complex type to be added.</param>
        <param name="targetType">The CLR type that is used to represent instances of this complex type.</param>
        <param name="propertyInfo">The corresponding CLR property or <see langword="null" /> for a shadow property.</param>
        <param name="fieldInfo">The corresponding CLR field or <see langword="null" /> for a shadow property.</param>
        <param name="propertyAccessMode">The <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> used for this property.</param>
        <param name="nullable">A value indicating whether this property can contain <see langword="null" />.</param>
        <param name="collection">Indicates whether the property represents a collection.</param>
        <param name="changeTrackingStrategy">The change tracking strategy for this complex type.</param>
        <param name="indexerPropertyInfo">The <see cref="T:System.Reflection.PropertyInfo" /> for the indexer on the associated CLR type if one exists.</param>
        <param name="propertyBag">
                A value indicating whether this entity type has an indexer which is able to contain arbitrary properties
                and a method that can be used to determine whether a given indexer property contains a value.
            </param>
        <param name="discriminatorProperty">The name of the property that will be used for storing a discriminator value.</param>
        <param name="discriminatorValue">The discriminator value for this complex type.</param>
        <param name="propertyCount">The expected number of declared properties for this complex type.</param>
        <param name="complexPropertyCount">The expected number of declared complex properties for this complex type.</param>
        <summary>
                Adds a complex property to this entity type.
            </summary>
        <returns>The newly created property.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty AddProperty (string name, Type clrType, System.Reflection.PropertyInfo? propertyInfo = default, System.Reflection.FieldInfo? fieldInfo = default, Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode = Microsoft.EntityFrameworkCore.PropertyAccessMode.PreferField, bool nullable = false, bool concurrencyToken = false, Microsoft.EntityFrameworkCore.Metadata.ValueGenerated valueGenerated = Microsoft.EntityFrameworkCore.Metadata.ValueGenerated.Never, Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior beforeSaveBehavior = Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior.Save, Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior afterSaveBehavior = Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior.Save, int? maxLength = default, bool? unicode = default, int? precision = default, int? scale = default, Type? providerPropertyType = default, Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? valueGeneratorFactory = default, Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? valueConverter = default, Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? valueComparer = default, Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? keyValueComparer = default, Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? providerValueComparer = default, Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter? jsonValueReaderWriter = default, Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping = default, object? sentinel = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty AddProperty(string name, class System.Type clrType, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode, bool nullable, bool concurrencyToken, valuetype Microsoft.EntityFrameworkCore.Metadata.ValueGenerated valueGenerated, valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior beforeSaveBehavior, valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior afterSaveBehavior, valuetype System.Nullable`1&lt;int32&gt; maxLength, valuetype System.Nullable`1&lt;bool&gt; unicode, valuetype System.Nullable`1&lt;int32&gt; precision, valuetype System.Nullable`1&lt;int32&gt; scale, class System.Type providerPropertyType, class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; valueGeneratorFactory, class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter valueConverter, class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer valueComparer, class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer keyValueComparer, class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer providerValueComparer, class Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter jsonValueReaderWriter, class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, object sentinel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.AddProperty(System.String,System.Type,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.PropertyAccessMode,System.Boolean,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ValueGenerated,Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior,Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Type,System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator},Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter,Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, clrType As Type, Optional propertyInfo As PropertyInfo = Nothing, Optional fieldInfo As FieldInfo = Nothing, Optional propertyAccessMode As PropertyAccessMode = Microsoft.EntityFrameworkCore.PropertyAccessMode.PreferField, Optional nullable As Boolean = false, Optional concurrencyToken As Boolean = false, Optional valueGenerated As ValueGenerated = Microsoft.EntityFrameworkCore.Metadata.ValueGenerated.Never, Optional beforeSaveBehavior As PropertySaveBehavior = Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior.Save, Optional afterSaveBehavior As PropertySaveBehavior = Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior.Save, Optional maxLength As Nullable(Of Integer) = Nothing, Optional unicode As Nullable(Of Boolean) = Nothing, Optional precision As Nullable(Of Integer) = Nothing, Optional scale As Nullable(Of Integer) = Nothing, Optional providerPropertyType As Type = Nothing, Optional valueGeneratorFactory As Func(Of IProperty, ITypeBase, ValueGenerator) = Nothing, Optional valueConverter As ValueConverter = Nothing, Optional valueComparer As ValueComparer = Nothing, Optional keyValueComparer As ValueComparer = Nothing, Optional providerValueComparer As ValueComparer = Nothing, Optional jsonValueReaderWriter As JsonValueReaderWriter = Nothing, Optional typeMapping As CoreTypeMapping = Nothing, Optional sentinel As Object = Nothing) As RuntimeProperty" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.PropertyAccessMode * bool * bool * Microsoft.EntityFrameworkCore.Metadata.ValueGenerated * Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior * Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior * Nullable&lt;int&gt; * Nullable&lt;bool&gt; * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Type * Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter * Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * obj -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&#xA;override this.AddProperty : string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.PropertyAccessMode * bool * bool * Microsoft.EntityFrameworkCore.Metadata.ValueGenerated * Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior * Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior * Nullable&lt;int&gt; * Nullable&lt;bool&gt; * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Type * Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter * Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * obj -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty" Usage="runtimeTypeBase.AddProperty (name, clrType, propertyInfo, fieldInfo, propertyAccessMode, nullable, concurrencyToken, valueGenerated, beforeSaveBehavior, afterSaveBehavior, maxLength, unicode, precision, scale, providerPropertyType, valueGeneratorFactory, valueConverter, valueComparer, keyValueComparer, providerValueComparer, jsonValueReaderWriter, typeMapping, sentinel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-10.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="clrType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" />
        <Parameter Name="propertyAccessMode" Type="Microsoft.EntityFrameworkCore.PropertyAccessMode" />
        <Parameter Name="nullable" Type="System.Boolean" />
        <Parameter Name="concurrencyToken" Type="System.Boolean" />
        <Parameter Name="valueGenerated" Type="Microsoft.EntityFrameworkCore.Metadata.ValueGenerated" />
        <Parameter Name="beforeSaveBehavior" Type="Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior" />
        <Parameter Name="afterSaveBehavior" Type="Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior" />
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="providerPropertyType" Type="System.Type" />
        <Parameter Name="valueGeneratorFactory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1, 1, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="valueConverter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
        <Parameter Name="valueComparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
        <Parameter Name="keyValueComparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
        <Parameter Name="providerValueComparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
        <Parameter Name="jsonValueReaderWriter" Type="Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter" />
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" />
        <Parameter Name="sentinel" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property to add.</param>
        <param name="clrType">The type of value the property will hold.</param>
        <param name="propertyInfo">The corresponding CLR property or <see langword="null" /> for a shadow property.</param>
        <param name="fieldInfo">The corresponding CLR field or <see langword="null" /> for a shadow property.</param>
        <param name="propertyAccessMode">The <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> used for this property.</param>
        <param name="nullable">A value indicating whether this property can contain <see langword="null" />.</param>
        <param name="concurrencyToken">A value indicating whether this property is used as a concurrency token.</param>
        <param name="valueGenerated">A value indicating when a value for this property will be generated by the database.</param>
        <param name="beforeSaveBehavior">
                A value indicating whether this property can be modified before the entity is saved to the database.
            </param>
        <param name="afterSaveBehavior">
                A value indicating whether this property can be modified after the entity is saved to the database.
            </param>
        <param name="maxLength">The maximum length of data that is allowed in this property.</param>
        <param name="unicode">A value indicating whether the property can persist Unicode characters.</param>
        <param name="precision">The precision of data that is allowed in this property.</param>
        <param name="scale">The scale of data that is allowed in this property.</param>
        <param name="providerPropertyType">
                The type that the property value will be converted to before being sent to the database provider.
            </param>
        <param name="valueGeneratorFactory">The factory that has been set to generate values for this property, if any.</param>
        <param name="valueConverter">The custom <see cref="T:Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" /> set for this property.</param>
        <param name="valueComparer">The <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" /> for this property.</param>
        <param name="keyValueComparer">The <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" /> to use with keys for this property.</param>
        <param name="providerValueComparer">The <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" /> to use for the provider values for this property.</param>
        <param name="jsonValueReaderWriter">The <see cref="T:Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter" /> for this property.</param>
        <param name="typeMapping">The <see cref="T:Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" /> for this property.</param>
        <param name="sentinel">The property value to use to consider the property not set.</param>
        <summary>
                Adds a property to this entity type.
            </summary>
        <returns>The newly created property.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase? BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseType As RuntimeTypeBase" />
      <MemberSignature Language="F#" Value="member this.BaseType : Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the base type of this type. Returns <see langword="null" /> if this is not a
                derived type in an inheritance hierarchy.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CalculateCounts">
      <MemberSignature Language="C#" Value="public abstract Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts CalculateCounts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts CalculateCounts() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.CalculateCounts" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CalculateCounts () As PropertyCounts" />
      <MemberSignature Language="F#" Value="abstract member CalculateCounts : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts" Usage="runtimeTypeBase.CalculateCounts " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.CalculateCounts</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClrType">
      <MemberSignature Language="C#" Value="public virtual Type ClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.ClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClrType As Type" />
      <MemberSignature Language="F#" Value="member this.ClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.ClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="ConstructorBinding">
      <MemberSignature Language="C#" Value="public abstract Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? ConstructorBinding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding ConstructorBinding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.ConstructorBinding" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ConstructorBinding As InstantiationBinding" />
      <MemberSignature Language="F#" Value="member this.ConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.ConstructorBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets or sets the <see cref="T:Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" /> for the preferred constructor.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt; DirectlyDerivedTypes { get; }" FrameworkAlternate="efcore-10.0;efcore-9.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt; DirectlyDerivedTypes" FrameworkAlternate="efcore-10.0;efcore-9.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.DirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DirectlyDerivedTypes As IEnumerable(Of RuntimeTypeBase)" FrameworkAlternate="efcore-10.0;efcore-9.0" />
      <MemberSignature Language="F#" Value="member this.DirectlyDerivedTypes : seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.DirectlyDerivedTypes" FrameworkAlternate="efcore-10.0;efcore-9.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.SortedSet&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt; DirectlyDerivedTypes { get; }" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedSet`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt; DirectlyDerivedTypes" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DirectlyDerivedTypes As SortedSet(Of RuntimeTypeBase)" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.DirectlyDerivedTypes : System.Collections.Generic.SortedSet&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.DirectlyDerivedTypes" FrameworkAlternate="efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0;efcore-9.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-10.0;efcore-9.0">System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-8.0">System.Collections.Generic.SortedSet&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets all types in the model that directly derive from this type.
            </summary>
        <value>The derived types.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyShadowValuesFactory">
      <MemberSignature Language="C#" Value="public Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; EmptyShadowValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; EmptyShadowValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.EmptyShadowValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EmptyShadowValuesFactory As Func(Of ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.EmptyShadowValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.EmptyShadowValuesFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.EmptyShadowValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FinalizeType">
      <MemberSignature Language="C#" Value="public virtual void FinalizeType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinalizeType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FinalizeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub FinalizeType ()" />
      <MemberSignature Language="F#" Value="abstract member FinalizeType : unit -&gt; unit&#xA;override this.FinalizeType : unit -&gt; unit" Usage="runtimeTypeBase.FinalizeType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0;efcore-9.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindComplexPropertiesInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt; FindComplexPropertiesInHierarchy (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt; FindComplexPropertiesInHierarchy(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindComplexPropertiesInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindComplexPropertiesInHierarchy (propertyName As String) As IEnumerable(Of RuntimeComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindComplexPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;&#xA;override this.FindComplexPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;" Usage="runtimeTypeBase.FindComplexPropertiesInHierarchy propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                Gets the complex properties with the given name on this type, base types or derived types.
            </summary>
        <returns>Type complex properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty? FindComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty FindComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindComplexProperty (name As String) As RuntimeComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&#xA;override this.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty" Usage="runtimeTypeBase.FindComplexProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-10.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property.</param>
        <summary>
                Gets the complex property with a given name. Returns <see langword="null" /> if no property with the given name is defined.
            </summary>
        <returns>The property, or <see langword="null" /> if none is found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredProperty">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty? FindDeclaredProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty FindDeclaredProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindDeclaredProperty (name As String) As RuntimeProperty" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&#xA;override this.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty" Usage="runtimeTypeBase.FindDeclaredProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-10.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndexerProperty">
      <MemberSignature Language="C#" Value="public static System.Reflection.PropertyInfo? FindIndexerProperty (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.PropertyInfo FindIndexerProperty(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindIndexerProperty(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndexerProperty (type As Type) As PropertyInfo" />
      <MemberSignature Language="F#" Value="static member FindIndexerProperty : Type -&gt; System.Reflection.PropertyInfo" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindIndexerProperty type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-10.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">The type to look for the indexer on.</param>
        <summary>
                Returns the default indexer property that takes a <see cref="T:System.String" /> value if one exists.
            </summary>
        <returns>An indexer property or <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndexerPropertyInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.PropertyInfo? FindIndexerPropertyInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo FindIndexerPropertyInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindIndexerPropertyInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndexerPropertyInfo () As PropertyInfo" />
      <MemberSignature Language="F#" Value="abstract member FindIndexerPropertyInfo : unit -&gt; System.Reflection.PropertyInfo&#xA;override this.FindIndexerPropertyInfo : unit -&gt; System.Reflection.PropertyInfo" Usage="runtimeTypeBase.FindIndexerPropertyInfo " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindIndexerPropertyInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="FindMember">
      <MemberSignature Language="C#" Value="public abstract Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase? FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindMember (name As String) As RuntimePropertyBase" />
      <MemberSignature Language="F#" Value="abstract member FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase" Usage="runtimeTypeBase.FindMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-10.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindMembersInHierarchy (name As String) As IEnumerable(Of RuntimePropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;" Usage="runtimeTypeBase.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;? FindProperties (System.Collections.Generic.IEnumerable&lt;string&gt; propertyNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; FindProperties(class System.Collections.Generic.IEnumerable`1&lt;string&gt; propertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindProperties(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindProperties (propertyNames As IEnumerable(Of String)) As IReadOnlyList(Of RuntimeProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindProperties : seq&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;&#xA;override this.FindProperties : seq&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;" Usage="runtimeTypeBase.FindProperties propertyNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-10.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyNames">The property names.</param>
        <summary>
                Finds matching properties on the given entity type. Returns <see langword="null" /> if any property is not found.
            </summary>
        <returns>The properties, or <see langword="null" /> if any property is not found.</returns>
        <remarks>
                This API only finds scalar properties and does not find navigations or service properties.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindPropertiesInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; FindPropertiesInHierarchy (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; FindPropertiesInHierarchy(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindPropertiesInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindPropertiesInHierarchy (propertyName As String) As IEnumerable(Of RuntimeProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;&#xA;override this.FindPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;" Usage="runtimeTypeBase.FindPropertiesInHierarchy propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                Gets the properties with the given name on this type, base types or derived types.
            </summary>
        <returns>Type properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty? FindProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindProperty (name As String) As RuntimeProperty" />
      <MemberSignature Language="F#" Value="abstract member FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&#xA;override this.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty" Usage="runtimeTypeBase.FindProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-10.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property.</param>
        <summary>
                Gets the property with a given name. Returns <see langword="null" /> if no property with the given name is defined.
            </summary>
        <returns>The property, or <see langword="null" /> if none is found.</returns>
        <remarks>
                This API only finds scalar properties and does not find navigation properties.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetComplexProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt; GetComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt; GetComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetComplexProperties () As IEnumerable(Of RuntimeComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;&#xA;override this.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;" Usage="runtimeTypeBase.GetComplexProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the complex properties defined on this type.
            </summary>
        <returns>The complex properties defined on this type.</returns>
        <remarks>
                This API only returns complex properties and does not find navigation, scalar or service properties.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredComplexProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt; GetDeclaredComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt; GetDeclaredComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetDeclaredComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredComplexProperties () As IEnumerable(Of RuntimeComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;&#xA;override this.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;" Usage="runtimeTypeBase.GetDeclaredComplexProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the complex properties declared on this type.
            </summary>
        <returns>Declared complex properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredMembers">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetDeclaredMembers () As IEnumerable(Of RuntimePropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;" Usage="runtimeTypeBase.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredProperties () As IEnumerable(Of RuntimeProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;&#xA;override this.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;" Usage="runtimeTypeBase.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all scalar properties declared on this type.
            </summary>
        <returns>Declared scalar properties.</returns>
        <remarks>
                This method does not return properties declared on base types.
                It is useful when iterating over all types to avoid processing the same property more than once.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetProperties" /> to also return properties declared on base types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt; GetDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt; GetDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedTypes () As IEnumerable(Of RuntimeTypeBase)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt;&#xA;override this.GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt;" Usage="runtimeTypeBase.GetDerivedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedTypes&lt;T&gt;">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;T&gt; GetDerivedTypes&lt;T&gt; () where T : Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase;" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; GetDerivedTypes&lt;(class Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase) T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetDerivedTypes``1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDerivedTypes(Of T As RuntimeTypeBase) () As IEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedTypes : unit -&gt; seq&lt;'T (requires 'T :&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase)&gt; (requires 'T :&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase)&#xA;override this.GetDerivedTypes : unit -&gt; seq&lt;'T (requires 'T :&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase)&gt; (requires 'T :&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase)" Usage="runtimeTypeBase.GetDerivedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlattenedComplexProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt; GetFlattenedComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt; GetFlattenedComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetFlattenedComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFlattenedComplexProperties () As IEnumerable(Of RuntimeComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetFlattenedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;&#xA;override this.GetFlattenedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;" Usage="runtimeTypeBase.GetFlattenedComplexProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlattenedDeclaredProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetFlattenedDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetFlattenedDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetFlattenedDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFlattenedDeclaredProperties () As IEnumerable(Of RuntimeProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetFlattenedDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;&#xA;override this.GetFlattenedDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;" Usage="runtimeTypeBase.GetFlattenedDeclaredProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlattenedProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetFlattenedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetFlattenedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetFlattenedProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFlattenedProperties () As IEnumerable(Of RuntimeProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetFlattenedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;&#xA;override this.GetFlattenedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;" Usage="runtimeTypeBase.GetFlattenedProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlattenedValueGeneratingProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetFlattenedValueGeneratingProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetFlattenedValueGeneratingProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetFlattenedValueGeneratingProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFlattenedValueGeneratingProperties () As IEnumerable(Of RuntimeProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetFlattenedValueGeneratingProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;&#xA;override this.GetFlattenedValueGeneratingProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;" Usage="runtimeTypeBase.GetFlattenedValueGeneratingProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers () As IEnumerable(Of RuntimePropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;" Usage="runtimeTypeBase.GetMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateEmptyMaterializer">
      <MemberSignature Language="C#" Value="public abstract Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetOrCreateEmptyMaterializer (Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetOrCreateEmptyMaterializer(class Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetOrCreateEmptyMaterializer(Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetOrCreateEmptyMaterializer (source As IStructuralTypeMaterializerSource) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateEmptyMaterializer : Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="runtimeTypeBase.GetOrCreateEmptyMaterializer source" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetOrCreateEmptyMaterializer(Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource" Index="0" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateMaterializer">
      <MemberSignature Language="C#" Value="public abstract Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetOrCreateMaterializer (Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetOrCreateMaterializer(class Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetOrCreateMaterializer(Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetOrCreateMaterializer (source As IStructuralTypeMaterializerSource) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateMaterializer : Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="runtimeTypeBase.GetOrCreateMaterializer source" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetOrCreateMaterializer(Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource" Index="0" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetProperties () As IEnumerable(Of RuntimeProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;&#xA;override this.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;" Usage="runtimeTypeBase.GetProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSnapshottableMembers">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetSnapshottableMembers ();" FrameworkAlternate="efcore-10.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetSnapshottableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.GetSnapshottableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSnapshottableMembers () As IEnumerable(Of RuntimePropertyBase)" FrameworkAlternate="efcore-10.0" />
      <MemberSignature Language="F#" Value="abstract member GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;&#xA;override this.GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;" Usage="runtimeTypeBase.GetSnapshottableMembers " FrameworkAlternate="efcore-10.0" />
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetSnapshottableMembers ();" FrameworkAlternate="efcore-8.0;efcore-9.0" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetSnapshottableMembers () As IEnumerable(Of RuntimePropertyBase)" FrameworkAlternate="efcore-8.0;efcore-9.0" />
      <MemberSignature Language="F#" Value="abstract member GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;" Usage="runtimeTypeBase.GetSnapshottableMembers " FrameworkAlternate="efcore-8.0;efcore-9.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="protected virtual bool HasDirectlyDerivedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasDirectlyDerivedTypes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.HasDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property HasDirectlyDerivedTypes As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasDirectlyDerivedTypes : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.HasDirectlyDerivedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0;efcore-9.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetConstructorBindingConfigurationSource">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? IRuntimeTypeBase.GetConstructorBindingConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetConstructorBindingConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#Internal#IRuntimeTypeBase#GetConstructorBindingConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Function GetConstructorBindingConfigurationSource () As Nullable(Of ConfigurationSource) Implements IRuntimeTypeBase.GetConstructorBindingConfigurationSource" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetConstructorBindingConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetConstructorBindingConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#Internal#IRuntimeTypeBase#GetServiceOnlyConstructorBindingConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Function GetServiceOnlyConstructorBindingConfigurationSource () As Nullable(Of ConfigurationSource) Implements IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.BaseType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase? Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#BaseType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property BaseType As IReadOnlyTypeBase Implements IReadOnlyTypeBase.BaseType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.BaseType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty IReadOnlyTypeBase.FindComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindComplexProperty (name As String) As IReadOnlyComplexProperty Implements IReadOnlyTypeBase.FindComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty IReadOnlyTypeBase.FindDeclaredComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindDeclaredComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredComplexProperty (name As String) As IReadOnlyComplexProperty Implements IReadOnlyTypeBase.FindDeclaredComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty IReadOnlyTypeBase.FindDeclaredProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredProperty (name As String) As IReadOnlyProperty Implements IReadOnlyTypeBase.FindDeclaredProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase IReadOnlyTypeBase.FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMember (name As String) As IReadOnlyPropertyBase Implements IReadOnlyTypeBase.FindMember" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; IReadOnlyTypeBase.FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMembersInHierarchy (name As String) As IEnumerable(Of IReadOnlyPropertyBase) Implements IReadOnlyTypeBase.FindMembersInHierarchy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyTypeBase.FindProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties(class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; propertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindProperties(System.Collections.Generic.IReadOnlyList{System.String})" />
      <MemberSignature Language="VB.NET" Value="Function FindProperties (propertyNames As IReadOnlyList(Of String)) As IReadOnlyList(Of IReadOnlyProperty) Implements IReadOnlyTypeBase.FindProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties propertyNames" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties(System.Collections.Generic.IReadOnlyList{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IReadOnlyList&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyNames">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty IReadOnlyTypeBase.FindProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IReadOnlyProperty Implements IReadOnlyTypeBase.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy IReadOnlyTypeBase.GetChangeTrackingStrategy ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetChangeTrackingStrategy() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetChangeTrackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Function GetChangeTrackingStrategy () As ChangeTrackingStrategy Implements IReadOnlyTypeBase.GetChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetChangeTrackingStrategy : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetChangeTrackingStrategy : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetChangeTrackingStrategy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetChangeTrackingStrategy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTrackingStrategy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; IReadOnlyTypeBase.GetComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetComplexProperties () As IEnumerable(Of IReadOnlyComplexProperty) Implements IReadOnlyTypeBase.GetComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; IReadOnlyTypeBase.GetDeclaredComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDeclaredComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredComplexProperties () As IEnumerable(Of IReadOnlyComplexProperty) Implements IReadOnlyTypeBase.GetDeclaredComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; IReadOnlyTypeBase.GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredMembers () As IEnumerable(Of IReadOnlyPropertyBase) Implements IReadOnlyTypeBase.GetDeclaredMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyTypeBase.GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredProperties () As IEnumerable(Of IReadOnlyProperty) Implements IReadOnlyTypeBase.GetDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; IReadOnlyTypeBase.GetDerivedComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDerivedComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedComplexProperties () As IEnumerable(Of IReadOnlyComplexProperty) Implements IReadOnlyTypeBase.GetDerivedComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyTypeBase.GetDerivedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDerivedProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedProperties () As IEnumerable(Of IReadOnlyProperty) Implements IReadOnlyTypeBase.GetDerivedProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt; IReadOnlyTypeBase.GetDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedTypes () As IEnumerable(Of IReadOnlyTypeBase) Implements IReadOnlyTypeBase.GetDerivedTypes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypesInclusive">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt; IReadOnlyTypeBase.GetDerivedTypesInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypesInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDerivedTypesInclusive" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedTypesInclusive () As IEnumerable(Of IReadOnlyTypeBase) Implements IReadOnlyTypeBase.GetDerivedTypesInclusive" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypesInclusive " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedTypesInclusive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt; IReadOnlyTypeBase.GetDirectlyDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDirectlyDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Function GetDirectlyDerivedTypes () As IEnumerable(Of IReadOnlyTypeBase) Implements IReadOnlyTypeBase.GetDirectlyDerivedTypes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDirectlyDerivedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDirectlyDerivedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorPropertyName">
      <MemberSignature Language="C#" Value="string IReadOnlyTypeBase.GetDiscriminatorPropertyName ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorPropertyName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDiscriminatorPropertyName" />
      <MemberSignature Language="VB.NET" Value="Function GetDiscriminatorPropertyName () As String Implements IReadOnlyTypeBase.GetDiscriminatorPropertyName" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorPropertyName : unit -&gt; string&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorPropertyName : unit -&gt; string" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorPropertyName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorPropertyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorValue">
      <MemberSignature Language="C#" Value="object IReadOnlyTypeBase.GetDiscriminatorValue ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDiscriminatorValue" />
      <MemberSignature Language="VB.NET" Value="Function GetDiscriminatorValue () As Object Implements IReadOnlyTypeBase.GetDiscriminatorValue" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorValue : unit -&gt; obj&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorValue : unit -&gt; obj" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorValue " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDiscriminatorValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; IReadOnlyTypeBase.GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetMembers () As IEnumerable(Of IReadOnlyPropertyBase) Implements IReadOnlyTypeBase.GetMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyTypeBase.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IReadOnlyProperty) Implements IReadOnlyTypeBase.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetPropertyAccessMode">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.PropertyAccessMode IReadOnlyTypeBase.GetPropertyAccessMode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetPropertyAccessMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetPropertyAccessMode" />
      <MemberSignature Language="VB.NET" Value="Function GetPropertyAccessMode () As PropertyAccessMode Implements IReadOnlyTypeBase.GetPropertyAccessMode" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetPropertyAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetPropertyAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetPropertyAccessMode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetPropertyAccessMode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.PropertyAccessMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType">
      <MemberSignature Language="C#" Value="bool Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#HasSharedClrType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasSharedClrType As Boolean Implements IReadOnlyTypeBase.HasSharedClrType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsPropertyBag">
      <MemberSignature Language="C#" Value="bool Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsPropertyBag { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsPropertyBag" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#IsPropertyBag" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPropertyBag As Boolean Implements IReadOnlyTypeBase.IsPropertyBag" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsPropertyBag : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsPropertyBag" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsPropertyBag</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IReadOnlyModel Implements IReadOnlyTypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.BaseType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ITypeBase? Microsoft.EntityFrameworkCore.Metadata.ITypeBase.BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.ITypeBase Microsoft.EntityFrameworkCore.Metadata.ITypeBase.BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#BaseType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property BaseType As ITypeBase Implements ITypeBase.BaseType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.BaseType : Microsoft.EntityFrameworkCore.Metadata.ITypeBase" Usage="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ITypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty ITypeBase.FindComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindComplexProperty (name As String) As IComplexProperty Implements ITypeBase.FindComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IProperty ITypeBase.FindDeclaredProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IProperty Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredProperty (name As String) As IProperty Implements ITypeBase.FindDeclaredProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase ITypeBase.FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMember (name As String) As IPropertyBase Implements ITypeBase.FindMember" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IPropertyBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; ITypeBase.FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMembersInHierarchy (name As String) As IEnumerable(Of IPropertyBase) Implements ITypeBase.FindMembersInHierarchy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IProperty ITypeBase.FindProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IProperty Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IProperty Implements ITypeBase.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; ITypeBase.GetComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetComplexProperties () As IEnumerable(Of IComplexProperty) Implements ITypeBase.GetComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; ITypeBase.GetDeclaredComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetDeclaredComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredComplexProperties () As IEnumerable(Of IComplexProperty) Implements ITypeBase.GetDeclaredComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; ITypeBase.GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredMembers () As IEnumerable(Of IPropertyBase) Implements ITypeBase.GetDeclaredMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ITypeBase.GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredProperties () As IEnumerable(Of IProperty) Implements ITypeBase.GetDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ITypeBase&gt; ITypeBase.GetDirectlyDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.ITypeBase&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDirectlyDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Function GetDirectlyDerivedTypes () As IEnumerable(Of ITypeBase) Implements ITypeBase.GetDirectlyDerivedTypes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.ITypeBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.ITypeBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDirectlyDerivedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDirectlyDerivedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ITypeBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; ITypeBase.GetFlattenedComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetFlattenedComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetFlattenedComplexProperties () As IEnumerable(Of IComplexProperty) Implements ITypeBase.GetFlattenedComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all properties that implement <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />, including those on non-collection complex types.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ITypeBase.GetFlattenedDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetFlattenedDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetFlattenedDeclaredProperties () As IEnumerable(Of IProperty) Implements ITypeBase.GetFlattenedDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all properties declared properties that implement <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IProperty" />, including those on non-collection complex types.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ITypeBase.GetFlattenedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetFlattenedProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetFlattenedProperties () As IEnumerable(Of IProperty) Implements ITypeBase.GetFlattenedProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all properties that implement <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IProperty" />, including those on non-collection complex types.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedValueGeneratingProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ITypeBase.GetFlattenedValueGeneratingProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedValueGeneratingProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetFlattenedValueGeneratingProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetFlattenedValueGeneratingProperties () As IEnumerable(Of IProperty) Implements ITypeBase.GetFlattenedValueGeneratingProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedValueGeneratingProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedValueGeneratingProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedValueGeneratingProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedValueGeneratingProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; ITypeBase.GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetMembers () As IEnumerable(Of IPropertyBase) Implements ITypeBase.GetMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ITypeBase.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IProperty) Implements ITypeBase.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; ITypeBase.GetSnapshottableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetSnapshottableMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetSnapshottableMembers () As IEnumerable(Of IPropertyBase) Implements ITypeBase.GetSnapshottableMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;" Usage="runtimeTypeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all members that may need a snapshot value when change tracking.
            </summary>
        <returns>The members.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IModel Implements ITypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IModel" Usage="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Model">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeModel Model { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeModel Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Model" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Model As RuntimeModel" />
      <MemberSignature Language="F#" Value="member this.Model : Microsoft.EntityFrameworkCore.Metadata.RuntimeModel with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Model" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the model that this type belongs to.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the name of this type.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalValuesFactory">
      <MemberSignature Language="C#" Value="public Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; OriginalValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; OriginalValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.OriginalValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalValuesFactory As Func(Of IInternalEntry, ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.OriginalValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.OriginalValuesFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.OriginalValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.SortedDictionary&lt;string,Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedDictionary`2&lt;string, class Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Properties" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property Properties As SortedDictionary(Of String, RuntimeProperty)" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.SortedDictionary&lt;string, Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;System.String,Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEmptyShadowValuesFactory">
      <MemberSignature Language="C#" Value="public virtual void SetEmptyShadowValuesFactory (Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEmptyShadowValuesFactory(class System.Func`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.SetEmptyShadowValuesFactory(System.Func{Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetEmptyShadowValuesFactory (factory As Func(Of ISnapshot))" />
      <MemberSignature Language="F#" Value="abstract member SetEmptyShadowValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit&#xA;override this.SetEmptyShadowValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit" Usage="runtimeTypeBase.SetEmptyShadowValuesFactory factory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Index="0" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="factory">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetOriginalValuesFactory">
      <MemberSignature Language="C#" Value="public virtual void SetOriginalValuesFactory (Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetOriginalValuesFactory(class System.Func`2&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.SetOriginalValuesFactory(System.Func{Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetOriginalValuesFactory (factory As Func(Of IInternalEntry, ISnapshot))" />
      <MemberSignature Language="F#" Value="abstract member SetOriginalValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit&#xA;override this.SetOriginalValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit" Usage="runtimeTypeBase.SetOriginalValuesFactory factory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Index="0" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="factory">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetShadowValuesFactory">
      <MemberSignature Language="C#" Value="public virtual void SetShadowValuesFactory (Func&lt;System.Collections.Generic.IDictionary&lt;string,object?&gt;,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowValuesFactory(class System.Func`2&lt;class System.Collections.Generic.IDictionary`2&lt;string, object&gt;, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.SetShadowValuesFactory(System.Func{System.Collections.Generic.IDictionary{System.String,System.Object},Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetShadowValuesFactory (factory As Func(Of IDictionary(Of String, Object), ISnapshot))" />
      <MemberSignature Language="F#" Value="abstract member SetShadowValuesFactory : Func&lt;System.Collections.Generic.IDictionary&lt;string, obj&gt;, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit&#xA;override this.SetShadowValuesFactory : Func&lt;System.Collections.Generic.IDictionary&lt;string, obj&gt;, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit" Usage="runtimeTypeBase.SetShadowValuesFactory factory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Index="0" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 1, 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 1, 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="factory">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStoreGeneratedValuesFactory">
      <MemberSignature Language="C#" Value="public virtual void SetStoreGeneratedValuesFactory (Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStoreGeneratedValuesFactory(class System.Func`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.SetStoreGeneratedValuesFactory(System.Func{Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetStoreGeneratedValuesFactory (factory As Func(Of ISnapshot))" />
      <MemberSignature Language="F#" Value="abstract member SetStoreGeneratedValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit&#xA;override this.SetStoreGeneratedValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit" Usage="runtimeTypeBase.SetStoreGeneratedValuesFactory factory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Index="0" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="factory">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTemporaryValuesFactory">
      <MemberSignature Language="C#" Value="public virtual void SetTemporaryValuesFactory (Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetTemporaryValuesFactory(class System.Func`2&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.SetTemporaryValuesFactory(System.Func{Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetTemporaryValuesFactory (factory As Func(Of IInternalEntry, ISnapshot))" />
      <MemberSignature Language="F#" Value="abstract member SetTemporaryValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit&#xA;override this.SetTemporaryValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; -&gt; unit" Usage="runtimeTypeBase.SetTemporaryValuesFactory factory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Index="0" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="factory">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShadowValuesFactory">
      <MemberSignature Language="C#" Value="public Func&lt;System.Collections.Generic.IDictionary&lt;string,object?&gt;,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; ShadowValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class System.Collections.Generic.IDictionary`2&lt;string, object&gt;, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; ShadowValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.ShadowValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowValuesFactory As Func(Of IDictionary(Of String, Object), ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.ShadowValuesFactory : Func&lt;System.Collections.Generic.IDictionary&lt;string, obj&gt;, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.ShadowValuesFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.ShadowValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 1, 2, 1 })]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 1, 2, 1 })&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StoreGeneratedValuesFactory">
      <MemberSignature Language="C#" Value="public Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; StoreGeneratedValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; StoreGeneratedValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.StoreGeneratedValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StoreGeneratedValuesFactory As Func(Of ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.StoreGeneratedValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.StoreGeneratedValuesFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.StoreGeneratedValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TemporaryValuesFactory">
      <MemberSignature Language="C#" Value="public Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; TemporaryValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; TemporaryValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.TemporaryValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemporaryValuesFactory As Func(Of IInternalEntry, ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.TemporaryValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.TemporaryValuesFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.TemporaryValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToEnumerable&lt;T&gt;">
      <MemberSignature Language="C#" Value="protected static System.Collections.Generic.IEnumerable&lt;T&gt; ToEnumerable&lt;T&gt; (T? element) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; ToEnumerable&lt;class T&gt;(!!T element) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.ToEnumerable``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ToEnumerable(Of T As Class) (element As T) As IEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="static member ToEnumerable : 'T -&gt; seq&lt;'T (requires 'T : null)&gt; (requires 'T : null)" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase.ToEnumerable element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="element">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
