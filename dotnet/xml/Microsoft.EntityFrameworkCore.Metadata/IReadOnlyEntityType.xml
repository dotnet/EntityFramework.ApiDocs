<Type Name="IReadOnlyEntityType" FullName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType">
  <TypeSignature Language="C#" Value="public interface IReadOnlyEntityType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IReadOnlyEntityType implements class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase" FrameworkAlternate="efcore-6.0;efcore-7.0" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
  <TypeSignature Language="VB.NET" Value="Public Interface IReadOnlyEntityType&#xA;Implements IReadOnlyTypeBase" />
  <TypeSignature Language="F#" Value="type IReadOnlyEntityType = interface&#xA;    interface IReadOnlyTypeBase&#xA;    interface IReadOnlyAnnotatable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract beforefieldinit IReadOnlyEntityType implements class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase" FrameworkAlternate="efcore-8.0" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                Represents an entity type in a model.
            </summary>
    <remarks>
                See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see> for more information and examples.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType? BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As IReadOnlyEntityType" />
      <MemberSignature Language="F#" Value="member this.BaseType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the base type of this entity type. Returns <see langword="null" /> if this is not a
                derived type in an inheritance hierarchy.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefiningEntityType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType? DefiningEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType DefiningEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.DefiningEntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefiningEntityType As IReadOnlyEntityType" />
      <MemberSignature Language="F#" Value="member this.DefiningEntityType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.DefiningEntityType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0">
          <AttributeName Language="C#">[System.Obsolete("Entity types with defining navigations have been replaced by shared-type entity types")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Entity types with defining navigations have been replaced by shared-type entity types")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the defining entity type.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefiningNavigationName">
      <MemberSignature Language="C#" Value="public virtual string? DefiningNavigationName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefiningNavigationName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.DefiningNavigationName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefiningNavigationName As String" />
      <MemberSignature Language="F#" Value="member this.DefiningNavigationName : string" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.DefiningNavigationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0">
          <AttributeName Language="C#">[System.Obsolete("Entity types with defining navigations have been replaced by shared-type entity types")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Entity types with defining navigations have been replaced by shared-type entity types")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the name of the defining navigation.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindClosestCommonParent">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType? FindClosestCommonParent (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType otherEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType FindClosestCommonParent(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType otherEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindClosestCommonParent(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindClosestCommonParent (otherEntityType As IReadOnlyEntityType) As IReadOnlyEntityType" />
      <MemberSignature Language="F#" Value="abstract member FindClosestCommonParent : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&#xA;override this.FindClosestCommonParent : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="iReadOnlyEntityType.FindClosestCommonParent otherEntityType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
      </Parameters>
      <Docs>
        <param name="otherEntityType">Another entity type.</param>
        <summary>
                Returns the closest entity type that is a parent of both given entity types. If one of the given entities is
                a parent of the other, that parent is returned. Returns <see langword="null" /> if the two entity types aren't
                in the same hierarchy.
            </summary>
        <returns>
                The closest common parent of this entity type and <paramref name="otherEntityType" />,
                or <see langword="null" /> if they have not common parent.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredForeignKeys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; FindDeclaredForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; FindDeclaredForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindDeclaredForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of IReadOnlyForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="iReadOnlyEntityType.FindDeclaredForeignKeys properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">The properties to find the foreign keys on.</param>
        <summary>
                Gets the foreign keys declared on this entity type using the given properties.
            </summary>
        <returns>Declared foreign keys.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredNavigation">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation? FindDeclaredNavigation (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation FindDeclaredNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindDeclaredNavigation (name As String) As IReadOnlyNavigation" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation" Usage="iReadOnlyEntityType.FindDeclaredNavigation name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the navigation property on the entity class.</param>
        <summary>
                Gets a navigation property on the given entity type. Does not return navigation properties defined on a base type.
                Returns <see langword="null" /> if no navigation property is found.
            </summary>
        <returns>The navigation property, or <see langword="null" /> if none is found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredProperty">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty? FindDeclaredProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty FindDeclaredProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindDeclaredProperty (name As String) As IReadOnlyProperty" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="iReadOnlyEntityType.FindDeclaredProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">The property name.</param>
        <summary>
                Finds a property declared on the type with the given name.
                Does not return properties defined on a base type.
            </summary>
        <returns>The property, or <see langword="null" /> if none is found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredSkipNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation? FindDeclaredSkipNavigation (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation FindDeclaredSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredSkipNavigation (name As String) As IReadOnlySkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&#xA;override this.FindDeclaredSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation" Usage="iReadOnlyEntityType.FindDeclaredSkipNavigation name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the navigation property on the entity class.</param>
        <summary>
                Gets a skip navigation property on this entity type.
            </summary>
        <returns>The navigation property, or <see langword="null" /> if none is found.</returns>
        <remarks>
                Does not return skip navigation properties defined on a base type.
                Returns <see langword="null" /> if no skip navigation property is found.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredTrigger">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger? FindDeclaredTrigger (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger FindDeclaredTrigger(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindDeclaredTrigger (name As String) As IReadOnlyTrigger" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger" Usage="iReadOnlyEntityType.FindDeclaredTrigger name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">The trigger name.</param>
        <summary>
                Finds a trigger with the given name.
            </summary>
        <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDiscriminatorProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty? FindDiscriminatorProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty FindDiscriminatorProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDiscriminatorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDiscriminatorProperty () As IReadOnlyProperty" />
      <MemberSignature Language="F#" Value="abstract member FindDiscriminatorProperty : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&#xA;override this.FindDiscriminatorProperty : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="iReadOnlyEntityType.FindDiscriminatorProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns the property that will be used for storing a discriminator value.
            </summary>
        <returns>The property that will be used for storing a discriminator value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey? FindForeignKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey FindForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKey (property As IReadOnlyProperty, principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As IReadOnlyForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&#xA;override this.FindForeignKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey" Usage="iReadOnlyEntityType.FindForeignKey (property, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
      </Parameters>
      <Docs>
        <param name="property">The property that the foreign key is defined on.</param>
        <param name="principalKey">The primary or alternate key that is referenced.</param>
        <param name="principalEntityType">
                The entity type that the relationship targets. This may be different from the type that <paramref name="principalKey" />
                is defined on when the relationship targets a derived type in an inheritance hierarchy (since the key is defined on the
                base type of the hierarchy).
            </param>
        <summary>
                Gets the foreign key for the given properties that points to a given primary or alternate key. Returns <see langword="null" />
                if no foreign key is found.
            </summary>
        <returns>The foreign key, or <see langword="null" /> if none is defined.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKey">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey? FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As IReadOnlyForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey" Usage="iReadOnlyEntityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
      </Parameters>
      <Docs>
        <param name="properties">The properties that the foreign key is defined on.</param>
        <param name="principalKey">The primary or alternate key that is referenced.</param>
        <param name="principalEntityType">
                The entity type that the relationship targets. This may be different from the type that <paramref name="principalKey" />
                is defined on when the relationship targets a derived type in an inheritance hierarchy (since the key is defined on the
                base type of the hierarchy).
            </param>
        <summary>
                Gets the foreign key for the given properties that points to a given primary or alternate key.
                Returns <see langword="null" /> if no foreign key is found.
            </summary>
        <returns>The foreign key, or <see langword="null" /> if none is defined.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; FindForeignKeys (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; FindForeignKeys(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKeys(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKeys (property As IReadOnlyProperty) As IEnumerable(Of IReadOnlyForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeys : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;&#xA;override this.FindForeignKeys : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="iReadOnlyEntityType.FindForeignKeys property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" />
      </Parameters>
      <Docs>
        <param name="property">The property to find the foreign keys on.</param>
        <summary>
                Gets the foreign keys defined on the given property. Only foreign keys that are defined on exactly the specified
                property are returned. Composite foreign keys that include the specified property are not returned.
            </summary>
        <returns>The foreign keys.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; FindForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; FindForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of IReadOnlyForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="iReadOnlyEntityType.FindForeignKeys properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">The properties to find the foreign keys on.</param>
        <summary>
                Gets the foreign keys defined on the given properties. Only foreign keys that are defined on exactly the specified
                set of properties are returned.
            </summary>
        <returns>The foreign keys.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex? FindIndex (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex FindIndex(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndex (property As IReadOnlyProperty) As IReadOnlyIndex" />
      <MemberSignature Language="F#" Value="abstract member FindIndex : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&#xA;override this.FindIndex : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex" Usage="iReadOnlyEntityType.FindIndex property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" />
      </Parameters>
      <Docs>
        <param name="property">The property to find the index on.</param>
        <summary>
                Gets the unnamed index defined on the given property. Returns <see langword="null" /> if no such index is defined.
            </summary>
        <returns>The index, or <see langword="null" /> if none is found.</returns>
        <remarks>
                Named indexes will not be returned even if the list of properties matches.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex? FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As IReadOnlyIndex" />
      <MemberSignature Language="F#" Value="abstract member FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex" Usage="iReadOnlyEntityType.FindIndex properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">The properties to find the index on.</param>
        <summary>
                Gets the unnamed index defined on the given properties. Returns <see langword="null" /> if no such index is defined.
            </summary>
        <returns>The index, or <see langword="null" /> if none is found.</returns>
        <remarks>
                Named indexes will not be returned even if the list of properties matches.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex? FindIndex (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex FindIndex(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (name As String) As IReadOnlyIndex" />
      <MemberSignature Language="F#" Value="abstract member FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex" Usage="iReadOnlyEntityType.FindIndex name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the index to find.</param>
        <summary>
                Gets the index with the given name. Returns <see langword="null" /> if no such index exists.
            </summary>
        <returns>The index, or <see langword="null" /> if none is found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey? FindKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey FindKey(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindKey (property As IReadOnlyProperty) As IReadOnlyKey" />
      <MemberSignature Language="F#" Value="abstract member FindKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&#xA;override this.FindKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Usage="iReadOnlyEntityType.FindKey property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" />
      </Parameters>
      <Docs>
        <param name="property">The property that the key is defined on.</param>
        <summary>
                Gets the primary or alternate key that is defined on the given property. Returns <see langword="null" /> if no key is defined
                for the given property.
            </summary>
        <returns>The key, or null if none is defined.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindKey">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey? FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As IReadOnlyKey" />
      <MemberSignature Language="F#" Value="abstract member FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Usage="iReadOnlyEntityType.FindKey properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">The properties that make up the key.</param>
        <summary>
                Gets the primary or alternate key that is defined on the given properties.
                Returns <see langword="null" /> if no key is defined for the given properties.
            </summary>
        <returns>The key, or <see langword="null" /> if none is defined.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation? FindNavigation (System.Reflection.MemberInfo memberInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation FindNavigation(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindNavigation(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindNavigation (memberInfo As MemberInfo) As IReadOnlyNavigation" />
      <MemberSignature Language="F#" Value="abstract member FindNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&#xA;override this.FindNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation" Usage="iReadOnlyEntityType.FindNavigation memberInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="memberInfo">The navigation property on the entity class.</param>
        <summary>
                Gets a navigation property on the given entity type. Returns <see langword="null" /> if no navigation property is found.
            </summary>
        <returns>The navigation property, or <see langword="null" /> if none is found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation? FindNavigation (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation FindNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindNavigation (name As String) As IReadOnlyNavigation" />
      <MemberSignature Language="F#" Value="abstract member FindNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&#xA;override this.FindNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation" Usage="iReadOnlyEntityType.FindNavigation name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the navigation property on the entity class.</param>
        <summary>
                Gets a navigation property on the given entity type. Returns <see langword="null" /> if no navigation property is found.
            </summary>
        <returns>The navigation property, or <see langword="null" /> if none is found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindOwnership">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey? FindOwnership ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey FindOwnership() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindOwnership" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindOwnership () As IReadOnlyForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindOwnership : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&#xA;override this.FindOwnership : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey" Usage="iReadOnlyEntityType.FindOwnership " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns the relationship to the owner if this is an owned type or <see langword="null" /> otherwise.
            </summary>
        <returns>The relationship to the owner if this is an owned type or <see langword="null" /> otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindPrimaryKey">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey? FindPrimaryKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey FindPrimaryKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindPrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Function FindPrimaryKey () As IReadOnlyKey" />
      <MemberSignature Language="F#" Value="abstract member FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Usage="iReadOnlyEntityType.FindPrimaryKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets primary key for this entity type. Returns <see langword="null" /> if no primary key is defined.
            </summary>
        <returns>The primary key, or <see langword="null" /> if none is defined.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;? FindProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; FindProperties(class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; propertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperties(System.Collections.Generic.IReadOnlyList{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindProperties (propertyNames As IReadOnlyList(Of String)) As IReadOnlyList(Of IReadOnlyProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="iReadOnlyEntityType.FindProperties propertyNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IReadOnlyList&lt;System.String&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="propertyNames">The property names.</param>
        <summary>
                Finds matching properties on the given entity type. Returns <see langword="null" /> if any property is not found.
            </summary>
        <returns>The properties, or <see langword="null" /> if any property is not found.</returns>
        <remarks>
                This API only finds scalar properties and does not find navigation properties.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty? FindProperty (System.Reflection.MemberInfo memberInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty FindProperty(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperty(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindProperty (memberInfo As MemberInfo) As IReadOnlyProperty" />
      <MemberSignature Language="F#" Value="abstract member FindProperty : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&#xA;override this.FindProperty : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="iReadOnlyEntityType.FindProperty memberInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">The member on the entity class.</param>
        <summary>
                Gets a property with the given member info. Returns <see langword="null" /> if no property is found.
            </summary>
        <returns>The property, or <see langword="null" /> if none is found.</returns>
        <remarks>
                This API only finds scalar properties and does not find navigation properties. Use
                <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindNavigation(System.Reflection.MemberInfo)" /> to find a navigation property.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperty">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty? FindProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindProperty (name As String) As IReadOnlyProperty" />
      <MemberSignature Language="F#" Value="abstract member FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="iReadOnlyEntityType.FindProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property.</param>
        <summary>
                Gets the property with a given name. Returns <see langword="null" /> if no property with the given name is defined.
            </summary>
        <returns>The property, or <see langword="null" /> if none is found.</returns>
        <remarks>
                This API only finds scalar properties and does not find navigation properties. Use
                <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindNavigation(System.String)" /> to find a navigation property.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindServiceProperty">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty? FindServiceProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty FindServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindServiceProperty (name As String) As IReadOnlyServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty" Usage="iReadOnlyEntityType.FindServiceProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the service property.</param>
        <summary>
                Gets the service property with a given name.
                Returns <see langword="null" /> if no property with the given name is defined.
            </summary>
        <returns>The service property, or <see langword="null" /> if none is found.</returns>
        <remarks>
                This API only finds service properties and does not find scalar or navigation properties.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSkipNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation? FindSkipNavigation (System.Reflection.MemberInfo memberInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation FindSkipNavigation(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindSkipNavigation (memberInfo As MemberInfo) As IReadOnlySkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member FindSkipNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&#xA;override this.FindSkipNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation" Usage="iReadOnlyEntityType.FindSkipNavigation memberInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="memberInfo">The navigation property on the entity class.</param>
        <summary>
                Gets a skip navigation property on this entity type. Returns <see langword="null" /> if no navigation property is found.
            </summary>
        <returns>The navigation property, or <see langword="null" /> if none is found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSkipNavigation">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation? FindSkipNavigation (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation FindSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindSkipNavigation (name As String) As IReadOnlySkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation" Usage="iReadOnlyEntityType.FindSkipNavigation name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the navigation property on the entity class.</param>
        <summary>
                Gets a skip navigation property on this entity type. Returns <see langword="null" /> if no skip navigation property is found.
            </summary>
        <returns>The navigation property, or <see langword="null" /> if none is found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllBaseTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetAllBaseTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetAllBaseTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetAllBaseTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllBaseTypes () As IEnumerable(Of IReadOnlyEntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetAllBaseTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;&#xA;override this.GetAllBaseTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="iReadOnlyEntityType.GetAllBaseTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all types in the model from which this entity type derives, starting with the root.
            </summary>
        <returns>
                The base types.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllBaseTypesAscending">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetAllBaseTypesAscending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetAllBaseTypesAscending() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetAllBaseTypesAscending" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllBaseTypesAscending () As IEnumerable(Of IReadOnlyEntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetAllBaseTypesAscending : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;&#xA;override this.GetAllBaseTypesAscending : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="iReadOnlyEntityType.GetAllBaseTypesAscending " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all types in the model from which this entity type derives, starting with the closest one.
            </summary>
        <returns>
                The base types.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllBaseTypesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetAllBaseTypesInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetAllBaseTypesInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetAllBaseTypesInclusive" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllBaseTypesInclusive () As IEnumerable(Of IReadOnlyEntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetAllBaseTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;&#xA;override this.GetAllBaseTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="iReadOnlyEntityType.GetAllBaseTypesInclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all base types of this entity type, including the type itself, top to bottom.
            </summary>
        <returns>Base types.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllBaseTypesInclusiveAscending">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetAllBaseTypesInclusiveAscending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetAllBaseTypesInclusiveAscending() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetAllBaseTypesInclusiveAscending" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Overridable Function GetAllBaseTypesInclusiveAscending () As IEnumerable(Of IReadOnlyEntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetAllBaseTypesInclusiveAscending : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;&#xA;override this.GetAllBaseTypesInclusiveAscending : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="iReadOnlyEntityType.GetAllBaseTypesInclusiveAscending " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType+&lt;GetAllBaseTypesInclusiveAscending&gt;d__17))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType+&lt;GetAllBaseTypesInclusiveAscending&gt;d__17))&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-7.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType+&lt;GetAllBaseTypesInclusiveAscending&gt;d__13))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType+&lt;GetAllBaseTypesInclusiveAscending&gt;d__13))&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType+&lt;GetAllBaseTypesInclusiveAscending&gt;d__12))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType+&lt;GetAllBaseTypesInclusiveAscending&gt;d__12))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all base types of this entity type, including the type itself, bottom to top.
            </summary>
        <returns>Base types.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.ChangeTrackingStrategy GetChangeTrackingStrategy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy GetChangeTrackingStrategy() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetChangeTrackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeTrackingStrategy () As ChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member GetChangeTrackingStrategy : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Usage="iReadOnlyEntityType.GetChangeTrackingStrategy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTrackingStrategy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the change tracking strategy being used for this entity type. This strategy indicates how the
                context detects changes to properties for an instance of the entity type.
            </summary>
        <returns>The change tracking strategy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConcreteDerivedTypesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetConcreteDerivedTypesInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetConcreteDerivedTypesInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetConcreteDerivedTypesInclusive" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConcreteDerivedTypesInclusive () As IEnumerable(Of IReadOnlyEntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetConcreteDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;&#xA;override this.GetConcreteDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="iReadOnlyEntityType.GetConcreteDerivedTypesInclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all the derived types of this entity type, including the type itself,
                which are not <see langword="abstract" />.
            </summary>
        <returns>Non-abstract, derived types.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredForeignKeys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetDeclaredForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetDeclaredForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeclaredForeignKeys () As IEnumerable(Of IReadOnlyForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="iReadOnlyEntityType.GetDeclaredForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all foreign keys declared on this entity type..
            </summary>
        <returns>Declared foreign keys.</returns>
        <remarks>
                This method does not return foreign keys declared on base types.
                It is useful when iterating over all entity types to avoid processing the same foreign key more than once.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys" /> to also return foreign keys declared on base types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredIndexes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; GetDeclaredIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; GetDeclaredIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredIndexes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeclaredIndexes () As IEnumerable(Of IReadOnlyIndex)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;" Usage="iReadOnlyEntityType.GetDeclaredIndexes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all indexes declared on this entity type.
            </summary>
        <returns>Declared indexes.</returns>
        <remarks>
                This method does not return indexes declared on base types.
                It is useful when iterating over all entity types to avoid processing the same index more than once.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys" /> to also return indexes declared on base types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredKeys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; GetDeclaredKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; GetDeclaredKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredKeys" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeclaredKeys () As IEnumerable(Of IReadOnlyKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;" Usage="iReadOnlyEntityType.GetDeclaredKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all keys declared on this entity type.
            </summary>
        <returns>Declared keys.</returns>
        <remarks>
                This method does not return keys declared on base types.
                It is useful when iterating over all entity types to avoid processing the same key more than once.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetKeys" /> to also return keys declared on base types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredNavigations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; GetDeclaredNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; GetDeclaredNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeclaredNavigations () As IEnumerable(Of IReadOnlyNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;" Usage="iReadOnlyEntityType.GetDeclaredNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all navigation properties declared on this entity type.
            </summary>
        <returns>Declared navigation properties.</returns>
        <remarks>
                This method does not return navigation properties declared on base types.
                It is useful when iterating over all entity types to avoid processing the same navigation property more than once.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations" /> to also return navigation properties declared on base types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeclaredProperties () As IEnumerable(Of IReadOnlyProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="iReadOnlyEntityType.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all non-navigation properties declared on this entity type.
            </summary>
        <returns>Declared non-navigation properties.</returns>
        <remarks>
                This method does not return properties declared on base types.
                It is useful when iterating over all entity types to avoid processing the same property more than once.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperties" /> to also return properties declared on base types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredReferencingForeignKeys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetDeclaredReferencingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetDeclaredReferencingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredReferencingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeclaredReferencingForeignKeys () As IEnumerable(Of IReadOnlyForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="iReadOnlyEntityType.GetDeclaredReferencingForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all foreign keys that target a given entity type (i.e. foreign keys where the given entity type
                is the principal).
            </summary>
        <returns>The foreign keys that reference the given entity type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredServiceProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; GetDeclaredServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; GetDeclaredServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeclaredServiceProperties () As IEnumerable(Of IReadOnlyServiceProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;" Usage="iReadOnlyEntityType.GetDeclaredServiceProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all service properties declared on this entity type.
            </summary>
        <returns>Declared service properties.</returns>
        <remarks>
                This method does not return properties declared on base types.
                It is useful when iterating over all entity types to avoid processing the same property more than once.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetServiceProperties" /> to also return properties declared on base types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSkipNavigations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; GetDeclaredSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; GetDeclaredSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeclaredSkipNavigations () As IEnumerable(Of IReadOnlySkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;" Usage="iReadOnlyEntityType.GetDeclaredSkipNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all skip navigation properties declared on this entity type.
            </summary>
        <returns>Declared skip navigations.</returns>
        <remarks>
                This method does not return skip navigation properties declared declared on base types.
                It is useful when iterating over all entity types to avoid processing the same foreign key more than once.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSkipNavigations" /> to also return skip navigation properties declared on base types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredTriggers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&gt; GetDeclaredTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&gt; GetDeclaredTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeclaredTriggers () As IEnumerable(Of IReadOnlyTrigger)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&gt;" Usage="iReadOnlyEntityType.GetDeclaredTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns the declared triggers on the entity type.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultDiscriminatorValue">
      <MemberSignature Language="C#" Value="public virtual string GetDefaultDiscriminatorValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetDefaultDiscriminatorValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDefaultDiscriminatorValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultDiscriminatorValue () As String" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultDiscriminatorValue : unit -&gt; string&#xA;override this.GetDefaultDiscriminatorValue : unit -&gt; string" Usage="iReadOnlyEntityType.GetDefaultDiscriminatorValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns the default discriminator value that would be used for this entity type.
            </summary>
        <returns>The default discriminator value for this entity type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedForeignKeys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetDerivedForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetDerivedForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDerivedForeignKeys () As IEnumerable(Of IReadOnlyForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="iReadOnlyEntityType.GetDerivedForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all foreign keys declared on the types derived from this entity type.
            </summary>
        <returns>Derived foreign keys.</returns>
        <remarks>
                This method does not return foreign keys declared on the given entity type itself.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys" /> to return foreign keys declared on this
                and base entity typed types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedIndexes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; GetDerivedIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; GetDerivedIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedIndexes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDerivedIndexes () As IEnumerable(Of IReadOnlyIndex)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;" Usage="iReadOnlyEntityType.GetDerivedIndexes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all indexes declared on the types derived from this entity type.
            </summary>
        <returns>Derived indexes.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedNavigations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; GetDerivedNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; GetDerivedNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDerivedNavigations () As IEnumerable(Of IReadOnlyNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;" Usage="iReadOnlyEntityType.GetDerivedNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all navigation properties declared on the types derived from this entity type.
            </summary>
        <returns>Derived navigation properties.</returns>
        <remarks>
                This method does not return navigation properties declared on the given entity type itself.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations" /> to return navigation properties declared on this
                and base entity typed types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; GetDerivedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; GetDerivedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDerivedProperties () As IEnumerable(Of IReadOnlyProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="iReadOnlyEntityType.GetDerivedProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all non-navigation properties declared on the types derived from this entity type.
            </summary>
        <returns>Derived non-navigation properties.</returns>
        <remarks>
                This method does not return properties declared on the given entity type itself.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperties" /> to return properties declared on this
                and base entity typed types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedServiceProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; GetDerivedServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; GetDerivedServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDerivedServiceProperties () As IEnumerable(Of IReadOnlyServiceProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;" Usage="iReadOnlyEntityType.GetDerivedServiceProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all service properties declared on the types derived from this entity type.
            </summary>
        <returns>Derived service properties.</returns>
        <remarks>
                This method does not return service properties declared on the given entity type itself.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetServiceProperties" /> to return service properties declared on this
                and base entity typed types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedSkipNavigations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; GetDerivedSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; GetDerivedSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDerivedSkipNavigations () As IEnumerable(Of IReadOnlySkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;" Usage="iReadOnlyEntityType.GetDerivedSkipNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all skip navigation properties declared on the types derived from this entity type.
            </summary>
        <returns>Derived skip navigation properties.</returns>
        <remarks>
                This method does not return skip navigation properties declared on the given entity type itself.
                Use <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSkipNavigations" /> to return skip navigation properties declared on this
                and base entity typed types.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDerivedTypes () As IEnumerable(Of IReadOnlyEntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="iReadOnlyEntityType.GetDerivedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all types in the model that derive from this entity type.
            </summary>
        <returns>The derived types.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedTypesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetDerivedTypesInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetDerivedTypesInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedTypesInclusive" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedTypesInclusive () As IEnumerable(Of IReadOnlyEntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;&#xA;override this.GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="iReadOnlyEntityType.GetDerivedTypesInclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all derived types of this entity type, including the type itself.
            </summary>
        <returns>Derived types.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetDirectlyDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; GetDirectlyDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectlyDerivedTypes () As IEnumerable(Of IReadOnlyEntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="iReadOnlyEntityType.GetDirectlyDerivedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all types in the model that directly derive from this entity type.
            </summary>
        <returns>The derived types.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiscriminatorPropertyName">
      <MemberSignature Language="C#" Value="public string? GetDiscriminatorPropertyName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetDiscriminatorPropertyName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDiscriminatorPropertyName" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDiscriminatorPropertyName () As String" />
      <MemberSignature Language="F#" Value="abstract member GetDiscriminatorPropertyName : unit -&gt; string" Usage="iReadOnlyEntityType.GetDiscriminatorPropertyName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns the name of the property that will be used for storing a discriminator value.
            </summary>
        <returns>The name of the property that will be used for storing a discriminator value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiscriminatorValue">
      <MemberSignature Language="C#" Value="public virtual object? GetDiscriminatorValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetDiscriminatorValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDiscriminatorValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDiscriminatorValue () As Object" />
      <MemberSignature Language="F#" Value="abstract member GetDiscriminatorValue : unit -&gt; obj&#xA;override this.GetDiscriminatorValue : unit -&gt; obj" Usage="iReadOnlyEntityType.GetDiscriminatorValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns the discriminator value for this entity type.
            </summary>
        <returns>The discriminator value for this entity type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetForeignKeys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Function GetForeignKeys () As IEnumerable(Of IReadOnlyForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="iReadOnlyEntityType.GetForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the foreign keys defined on this entity type.
            </summary>
        <returns>The foreign keys defined on this entity type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIndexes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; GetIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; GetIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetIndexes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIndexes () As IEnumerable(Of IReadOnlyIndex)" />
      <MemberSignature Language="F#" Value="abstract member GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;" Usage="iReadOnlyEntityType.GetIndexes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the indexes defined on this entity type.
            </summary>
        <returns>The indexes defined on this entity type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsDiscriminatorMappingComplete">
      <MemberSignature Language="C#" Value="public virtual bool GetIsDiscriminatorMappingComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetIsDiscriminatorMappingComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetIsDiscriminatorMappingComplete" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsDiscriminatorMappingComplete () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member GetIsDiscriminatorMappingComplete : unit -&gt; bool&#xA;override this.GetIsDiscriminatorMappingComplete : unit -&gt; bool" Usage="iReadOnlyEntityType.GetIsDiscriminatorMappingComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns the value indicating whether the discriminator mapping is complete for this entity type.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKeys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; GetKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; GetKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetKeys" />
      <MemberSignature Language="VB.NET" Value="Public Function GetKeys () As IEnumerable(Of IReadOnlyKey)" />
      <MemberSignature Language="F#" Value="abstract member GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;" Usage="iReadOnlyEntityType.GetKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the primary and alternate keys for this entity type.
            </summary>
        <returns>The primary and alternate keys.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNavigationAccessMode">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.PropertyAccessMode GetNavigationAccessMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode GetNavigationAccessMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigationAccessMode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNavigationAccessMode () As PropertyAccessMode" />
      <MemberSignature Language="F#" Value="abstract member GetNavigationAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode" Usage="iReadOnlyEntityType.GetNavigationAccessMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.PropertyAccessMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> being used for navigations of this entity type.
            </summary>
        <returns>The access mode being used.</returns>
        <remarks>
                Note that individual navigations can override this access mode. The value returned here will
                be used for any navigation for which no override has been specified.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNavigations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; GetNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; GetNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNavigations () As IEnumerable(Of IReadOnlyNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;" Usage="iReadOnlyEntityType.GetNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all navigation properties on the given entity type.
            </summary>
        <returns>All navigation properties on the given entity type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateEmptyMaterializer">
      <MemberSignature Language="C#" Value="public Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetOrCreateEmptyMaterializer (Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetOrCreateEmptyMaterializer(class Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetOrCreateEmptyMaterializer(Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateEmptyMaterializer (source As IEntityMaterializerSource) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateEmptyMaterializer : Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="iReadOnlyEntityType.GetOrCreateEmptyMaterializer source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateMaterializer">
      <MemberSignature Language="C#" Value="public Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetOrCreateMaterializer (Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetOrCreateMaterializer(class Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetOrCreateMaterializer(Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateMaterializer (source As IEntityMaterializerSource) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateMaterializer : Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="iReadOnlyEntityType.GetOrCreateMaterializer source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As IEnumerable(Of IReadOnlyProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="iReadOnlyEntityType.GetProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the properties defined on this entity type.
            </summary>
        <returns>The properties defined on this entity type.</returns>
        <remarks>
                This API only returns scalar properties and does not return navigation properties. Use
                <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations" /> to get navigation properties.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProperty (name As String) As IReadOnlyProperty" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&#xA;override this.GetProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="iReadOnlyEntityType.GetProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">The property name.</param>
        <summary>
                Gets a property with the given name.
            </summary>
        <returns>The property.</returns>
        <remarks>
                This API only finds scalar properties and does not find navigation properties. Use
                <see cref="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindNavigation(System.String)" /> to find a navigation property.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetQueryFilter">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.LambdaExpression? GetQueryFilter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.LambdaExpression GetQueryFilter() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetQueryFilter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetQueryFilter () As LambdaExpression" />
      <MemberSignature Language="F#" Value="abstract member GetQueryFilter : unit -&gt; System.Linq.Expressions.LambdaExpression" Usage="iReadOnlyEntityType.GetQueryFilter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the LINQ expression filter automatically applied to queries for this entity type.
            </summary>
        <returns>The LINQ expression filter.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReferencingForeignKeys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetReferencingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; GetReferencingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetReferencingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReferencingForeignKeys () As IEnumerable(Of IReadOnlyForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="iReadOnlyEntityType.GetReferencingForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all foreign keys that target a given entity type (i.e. foreign keys where the given entity type
                or a base type is the principal).
            </summary>
        <returns>The foreign keys that reference the given entity type or a base type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRootType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType GetRootType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType GetRootType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetRootType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRootType () As IReadOnlyEntityType" />
      <MemberSignature Language="F#" Value="abstract member GetRootType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&#xA;override this.GetRootType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="iReadOnlyEntityType.GetRootType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the root base type for a given entity type.
            </summary>
        <returns>
                The root base type. If the given entity type is not a derived type, then the same entity type is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSeedData">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IDictionary&lt;string,object?&gt;&gt; GetSeedData (bool providerValues = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Collections.Generic.IDictionary`2&lt;string, object&gt;&gt; GetSeedData(bool providerValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSeedData(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSeedData (Optional providerValues As Boolean = false) As IEnumerable(Of IDictionary(Of String, Object))" />
      <MemberSignature Language="F#" Value="abstract member GetSeedData : bool -&gt; seq&lt;System.Collections.Generic.IDictionary&lt;string, obj&gt;&gt;" Usage="iReadOnlyEntityType.GetSeedData providerValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerValues" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="providerValues">
                If <see langword="true" /> then provider values are returned for properties with value converters.
            </param>
        <summary>
                Gets the data stored in the model for the given entity type.
            </summary>
        <returns>The data.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetServiceProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; GetServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; GetServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetServiceProperties () As IEnumerable(Of IReadOnlyServiceProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;" Usage="iReadOnlyEntityType.GetServiceProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets all the <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty" /> defined on this entity type.
            </summary>
        <returns>The service properties defined on this entity type.</returns>
        <remarks>
                This API only returns service properties and does not return scalar or navigation properties.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSkipNavigations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; GetSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; GetSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSkipNavigations () As IEnumerable(Of IReadOnlySkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;" Usage="iReadOnlyEntityType.GetSkipNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets the skip navigation properties on this entity type.
            </summary>
        <returns>All skip navigation properties on this entity type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasDefiningNavigation">
      <MemberSignature Language="C#" Value="public virtual bool HasDefiningNavigation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasDefiningNavigation() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.HasDefiningNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasDefiningNavigation () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member HasDefiningNavigation : unit -&gt; bool&#xA;override this.HasDefiningNavigation : unit -&gt; bool" Usage="iReadOnlyEntityType.HasDefiningNavigation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0">
          <AttributeName Language="C#">[System.Obsolete("Entity types with defining navigations have been replaced by shared-type entity types")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Entity types with defining navigations have been replaced by shared-type entity types")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets a value indicating whether this entity type has a defining navigation.
            </summary>
        <returns>
          <see langword="true" /> if this entity type has a defining navigation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasServiceProperties">
      <MemberSignature Language="C#" Value="public bool HasServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.HasServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function HasServiceProperties () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member HasServiceProperties : unit -&gt; bool" Usage="iReadOnlyEntityType.HasServiceProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Checks whether or not this entity type has any <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IServiceProperty" /> defined.
            </summary>
        <returns>
          <see langword="true" /> if there are any service properties defined on this entity type or base types.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType derivedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType derivedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.IsAssignableFrom(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (derivedType As IReadOnlyEntityType) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; bool&#xA;override this.IsAssignableFrom : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; bool" Usage="iReadOnlyEntityType.IsAssignableFrom derivedType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="derivedType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
      </Parameters>
      <Docs>
        <param name="derivedType">The entity type to check whether it derives from this entity type.</param>
        <summary>
                Determines if this entity type derives from (or is the same as) a given entity type.
            </summary>
        <returns>
          <see langword="true" /> if <paramref name="derivedType" /> derives from (or is the same as) this entity type,
                otherwise <see langword="false" />.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInOwnershipPath">
      <MemberSignature Language="C#" Value="public virtual bool IsInOwnershipPath (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInOwnershipPath(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.IsInOwnershipPath(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInOwnershipPath (targetType As IReadOnlyEntityType) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsInOwnershipPath : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; bool&#xA;override this.IsInOwnershipPath : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; bool" Usage="iReadOnlyEntityType.IsInOwnershipPath targetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
      </Parameters>
      <Docs>
        <param name="targetType">Entity type to search for in ownership path.</param>
        <summary>
                Gets a value indicating whether given entity type is in ownership path for this entity type.
            </summary>
        <returns>
          <see langword="true" /> if <paramref name="targetType" /> is in ownership path of this entity type,
                otherwise <see langword="false" />.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOwned">
      <MemberSignature Language="C#" Value="public virtual bool IsOwned ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsOwned() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.IsOwned" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsOwned () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsOwned : unit -&gt; bool&#xA;override this.IsOwned : unit -&gt; bool" Usage="iReadOnlyEntityType.IsOwned " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Gets a value indicating whether this entity type is owned by another entity type.
            </summary>
        <returns>
          <see langword="true" /> if this entity type is owned by another entity type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStrictlyDerivedFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsStrictlyDerivedFrom (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType baseType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStrictlyDerivedFrom(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType baseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.IsStrictlyDerivedFrom(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStrictlyDerivedFrom (baseType As IReadOnlyEntityType) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsStrictlyDerivedFrom : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; bool&#xA;override this.IsStrictlyDerivedFrom : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; bool" Usage="iReadOnlyEntityType.IsStrictlyDerivedFrom baseType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="baseType">The entity type to check if it is a base type of this entity type.</param>
        <summary>
                Determines if this entity type derives from (but is not the same as) a given entity type.
            </summary>
        <returns>
          <see langword="true" /> if this entity type derives from (but is not the same as) <paramref name="baseType" />,
                otherwise <see langword="false" />.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeastDerivedType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType? LeastDerivedType (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType otherEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType LeastDerivedType(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType otherEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.LeastDerivedType(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LeastDerivedType (otherEntityType As IReadOnlyEntityType) As IReadOnlyEntityType" />
      <MemberSignature Language="F#" Value="abstract member LeastDerivedType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&#xA;override this.LeastDerivedType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="iReadOnlyEntityType.LeastDerivedType otherEntityType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
      </Parameters>
      <Docs>
        <param name="otherEntityType">The other entity type to compare with.</param>
        <summary>
                Gets the least derived type between the specified two.
            </summary>
        <returns>
                The least derived type between the specified two.
                If the given entity types are not related, then <see langword="null" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsAssignableFrom">
      <MemberSignature Language="C#" Value="override sealed bool IReadOnlyTypeBase.IsAssignableFrom (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase derivedType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig virtual instance bool Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsAssignableFrom(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase derivedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#IsAssignableFrom(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase)" />
      <MemberSignature Language="VB.NET" Value=" Overrides NotOverridable Function IsAssignableFrom (derivedType As IReadOnlyTypeBase) As Boolean Implements IReadOnlyTypeBase.IsAssignableFrom" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsAssignableFrom : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsAssignableFrom : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase -&gt; bool" Usage="iReadOnlyEntityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsAssignableFrom derivedType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsAssignableFrom(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="derivedType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="derivedType">The type to check whether it derives from this type.</param>
        <summary>
                Determines if this type derives from (or is the same as) a given type.
            </summary>
        <returns>
          <see langword="true" /> if <paramref name="derivedType" /> derives from (or is the same as) this type,
                otherwise <see langword="false" />.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDebugString">
      <MemberSignature Language="C#" Value="public virtual string ToDebugString (Microsoft.EntityFrameworkCore.Infrastructure.MetadataDebugStringOptions options = Microsoft.EntityFrameworkCore.Infrastructure.MetadataDebugStringOptions.ShortDefault, int indent = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToDebugString(valuetype Microsoft.EntityFrameworkCore.Infrastructure.MetadataDebugStringOptions options, int32 indent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.ToDebugString(Microsoft.EntityFrameworkCore.Infrastructure.MetadataDebugStringOptions,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToDebugString (Optional options As MetadataDebugStringOptions = Microsoft.EntityFrameworkCore.Infrastructure.MetadataDebugStringOptions.ShortDefault, Optional indent As Integer = 0) As String" />
      <MemberSignature Language="F#" Value="abstract member ToDebugString : Microsoft.EntityFrameworkCore.Infrastructure.MetadataDebugStringOptions * int -&gt; string&#xA;override this.ToDebugString : Microsoft.EntityFrameworkCore.Infrastructure.MetadataDebugStringOptions * int -&gt; string" Usage="iReadOnlyEntityType.ToDebugString (options, indent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Microsoft.EntityFrameworkCore.Infrastructure.MetadataDebugStringOptions" />
        <Parameter Name="indent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="options">Options for generating the string.</param>
        <param name="indent">The number of indent spaces to use before each new line.</param>
        <summary>
          <para>
                    Creates a human-readable representation of the given metadata.
                </para>
          <para>
                    Warning: Do not rely on the format of the returned string.
                    It is designed for debugging only and may change arbitrarily between releases.
                </para>
        </summary>
        <returns>A human-readable representation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
