<Type Name="RuntimeComplexType" FullName="Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType">
  <TypeSignature Language="C#" Value="public class RuntimeComplexType : Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase, Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeComplexType" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RuntimeComplexType extends Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IComplexType, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeComplexType, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType" />
  <TypeSignature Language="VB.NET" Value="Public Class RuntimeComplexType&#xA;Inherits RuntimeTypeBase&#xA;Implements IRuntimeComplexType" />
  <TypeSignature Language="F#" Value="type RuntimeComplexType = class&#xA;    inherit RuntimeTypeBase&#xA;    interface IRuntimeComplexType&#xA;    interface IComplexType&#xA;    interface IReadOnlyComplexType&#xA;    interface IReadOnlyTypeBase&#xA;    interface IReadOnlyAnnotatable&#xA;    interface ITypeBase&#xA;    interface IAnnotatable&#xA;    interface IRuntimeTypeBase" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.RuntimeTypeBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IComplexType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeComplexType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.ITypeBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
                Represents the type of a complex property of a structural type.
            </summary>
    <remarks>
                See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see> for more information and examples.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RuntimeComplexType (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty complexProperty, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, System.Reflection.PropertyInfo? indexerPropertyInfo, bool propertyBag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty complexProperty, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, class System.Reflection.PropertyInfo indexerPropertyInfo, bool propertyBag) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Reflection.PropertyInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, type As Type, complexProperty As RuntimeComplexProperty, changeTrackingStrategy As ChangeTrackingStrategy, indexerPropertyInfo As PropertyInfo, propertyBag As Boolean)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType : string * Type * Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType" Usage="new Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType (name, type, complexProperty, changeTrackingStrategy, indexerPropertyInfo, propertyBag)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="complexProperty" Type="Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="indexerPropertyInfo" Type="System.Reflection.PropertyInfo" Index="4" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyBag" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="complexProperty">To be added.</param>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="indexerPropertyInfo">To be added.</param>
        <param name="propertyBag">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RuntimeComplexType (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty complexProperty, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, System.Reflection.PropertyInfo? indexerPropertyInfo, bool propertyBag, int propertyCount, int complexPropertyCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty complexProperty, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, class System.Reflection.PropertyInfo indexerPropertyInfo, bool propertyBag, int32 propertyCount, int32 complexPropertyCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Reflection.PropertyInfo,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, type As Type, complexProperty As RuntimeComplexProperty, changeTrackingStrategy As ChangeTrackingStrategy, indexerPropertyInfo As PropertyInfo, propertyBag As Boolean, propertyCount As Integer, complexPropertyCount As Integer)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType : string * Type * Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool * int * int -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType" Usage="new Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType (name, type, complexProperty, changeTrackingStrategy, indexerPropertyInfo, propertyBag, propertyCount, complexPropertyCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-9.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="efcore-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="complexProperty" Type="Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty" Index="2" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="3" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="indexerPropertyInfo" Type="System.Reflection.PropertyInfo" Index="4" FrameworkAlternate="efcore-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyBag" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="propertyCount" Type="System.Int32" Index="6" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="complexPropertyCount" Type="System.Int32" Index="7" FrameworkAlternate="efcore-9.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="complexProperty">To be added.</param>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="indexerPropertyInfo">To be added.</param>
        <param name="propertyBag">To be added.</param>
        <param name="propertyCount">To be added.</param>
        <param name="complexPropertyCount">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RuntimeComplexType (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty complexProperty, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, System.Reflection.PropertyInfo? indexerPropertyInfo, bool propertyBag, string? discriminatorProperty, object? discriminatorValue, int propertyCount, int complexPropertyCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty complexProperty, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy, class System.Reflection.PropertyInfo indexerPropertyInfo, bool propertyBag, string discriminatorProperty, object discriminatorValue, int32 propertyCount, int32 complexPropertyCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Reflection.PropertyInfo,System.Boolean,System.String,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, type As Type, complexProperty As RuntimeComplexProperty, changeTrackingStrategy As ChangeTrackingStrategy, indexerPropertyInfo As PropertyInfo, propertyBag As Boolean, discriminatorProperty As String, discriminatorValue As Object, propertyCount As Integer, complexPropertyCount As Integer)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType : string * Type * Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * System.Reflection.PropertyInfo * bool * string * obj * int * int -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType" Usage="new Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType (name, type, complexProperty, changeTrackingStrategy, indexerPropertyInfo, propertyBag, discriminatorProperty, discriminatorValue, propertyCount, complexPropertyCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="complexProperty" Type="Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty" Index="2" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="3" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="indexerPropertyInfo" Type="System.Reflection.PropertyInfo" Index="4" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyBag" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="discriminatorProperty" Type="System.String" Index="6" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="discriminatorValue" Type="System.Object" Index="7" FrameworkAlternate="efcore-10.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyCount" Type="System.Int32" Index="8" FrameworkAlternate="efcore-10.0" />
        <Parameter Name="complexPropertyCount" Type="System.Int32" Index="9" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="complexProperty">To be added.</param>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="indexerPropertyInfo">To be added.</param>
        <param name="propertyBag">To be added.</param>
        <param name="discriminatorProperty">To be added.</param>
        <param name="discriminatorValue">To be added.</param>
        <param name="propertyCount">To be added.</param>
        <param name="complexPropertyCount">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CalculateCounts">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts CalculateCounts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts CalculateCounts() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.CalculateCounts" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CalculateCounts () As PropertyCounts" />
      <MemberSignature Language="F#" Value="override this.CalculateCounts : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts" Usage="runtimeComplexType.CalculateCounts " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.CalculateCounts</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty ComplexProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty ComplexProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.ComplexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ComplexProperty As RuntimeComplexProperty" />
      <MemberSignature Language="F#" Value="member this.ComplexProperty : Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.ComplexProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructorBinding">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? ConstructorBinding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding ConstructorBinding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.ConstructorBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConstructorBinding As InstantiationBinding" />
      <MemberSignature Language="F#" Value="member this.ConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.ConstructorBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets or sets the <see cref="T:Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" /> for the preferred constructor.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DebugView">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.DebugView" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DebugView As DebugView" />
      <MemberSignature Language="F#" Value="member this.DebugView : Microsoft.EntityFrameworkCore.Infrastructure.DebugView" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.DebugView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Infrastructure.DebugView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMember">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase? FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindMember (name As String) As RuntimePropertyBase" />
      <MemberSignature Language="F#" Value="override this.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase" Usage="runtimeComplexType.FindMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-10.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindMembersInHierarchy (name As String) As IEnumerable(Of RuntimePropertyBase)" />
      <MemberSignature Language="F#" Value="override this.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;" Usage="runtimeComplexType.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredMembers">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDeclaredMembers () As IEnumerable(Of RuntimePropertyBase)" />
      <MemberSignature Language="F#" Value="override this.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;" Usage="runtimeComplexType.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers () As IEnumerable(Of RuntimePropertyBase)" />
      <MemberSignature Language="F#" Value="override this.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;" Usage="runtimeComplexType.GetMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateEmptyMaterializer">
      <MemberSignature Language="C#" Value="public override Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetOrCreateEmptyMaterializer (Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetOrCreateEmptyMaterializer(class Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.GetOrCreateEmptyMaterializer(Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetOrCreateEmptyMaterializer (source As IStructuralTypeMaterializerSource) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="override this.GetOrCreateEmptyMaterializer : Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="runtimeComplexType.GetOrCreateEmptyMaterializer source" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetOrCreateEmptyMaterializer(Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource" Index="0" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateMaterializer">
      <MemberSignature Language="C#" Value="public override Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetOrCreateMaterializer (Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetOrCreateMaterializer(class Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.GetOrCreateMaterializer(Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetOrCreateMaterializer (source As IStructuralTypeMaterializerSource) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="override this.GetOrCreateMaterializer : Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="runtimeComplexType.GetOrCreateMaterializer source" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetOrCreateMaterializer(Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource" Index="0" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSnapshottableMembers">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetSnapshottableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt; GetSnapshottableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.GetSnapshottableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSnapshottableMembers () As IEnumerable(Of RuntimePropertyBase)" />
      <MemberSignature Language="F#" Value="override this.GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;" Usage="runtimeComplexType.GetSnapshottableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IComplexType.BaseType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IComplexType? Microsoft.EntityFrameworkCore.Metadata.IComplexType.BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IComplexType Microsoft.EntityFrameworkCore.Metadata.IComplexType.BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IComplexType#BaseType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property BaseType As IComplexType Implements IComplexType.BaseType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IComplexType.BaseType : Microsoft.EntityFrameworkCore.Metadata.IComplexType" Usage="Microsoft.EntityFrameworkCore.Metadata.IComplexType.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IComplexType.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IComplexType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IComplexType#ComplexProperty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ComplexProperty As IComplexProperty Implements IComplexType.ComplexProperty" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IComplexProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IComplexType.GetDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexType&gt; IComplexType.GetDirectlyDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IComplexType&gt; Microsoft.EntityFrameworkCore.Metadata.IComplexType.GetDirectlyDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IComplexType#GetDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Function GetDirectlyDerivedTypes () As IEnumerable(Of IComplexType) Implements IComplexType.GetDirectlyDerivedTypes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IComplexType.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexType&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IComplexType.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexType&gt;" Usage="runtimeComplexType.Microsoft.EntityFrameworkCore.Metadata.IComplexType.GetDirectlyDerivedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IComplexType.GetDirectlyDerivedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.ContainingEntryType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.ContainingEntryType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.ContainingEntryType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#Internal#IRuntimeTypeBase#ContainingEntryType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainingEntryType As IRuntimeTypeBase Implements IRuntimeTypeBase.ContainingEntryType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.ContainingEntryType : Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.ContainingEntryType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.ContainingEntryType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.BaseType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType? Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyComplexType#BaseType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property BaseType As IReadOnlyComplexType Implements IReadOnlyComplexType.BaseType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.BaseType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyComplexType#ComplexProperty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ComplexProperty As IReadOnlyComplexProperty Implements IReadOnlyComplexType.ComplexProperty" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt; IReadOnlyComplexType.GetDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyComplexType#GetDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedTypes () As IEnumerable(Of IReadOnlyComplexType) Implements IReadOnlyComplexType.GetDerivedTypes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt;" Usage="runtimeComplexType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypesInclusive">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt; IReadOnlyComplexType.GetDerivedTypesInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypesInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyComplexType#GetDerivedTypesInclusive" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedTypesInclusive () As IEnumerable(Of IReadOnlyComplexType) Implements IReadOnlyComplexType.GetDerivedTypesInclusive" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt;" Usage="runtimeComplexType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypesInclusive " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDerivedTypesInclusive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt; IReadOnlyComplexType.GetDirectlyDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDirectlyDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyComplexType#GetDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Function GetDirectlyDerivedTypes () As IEnumerable(Of IReadOnlyComplexType) Implements IReadOnlyComplexType.GetDirectlyDerivedTypes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt;" Usage="runtimeComplexType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDirectlyDerivedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.GetDirectlyDerivedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-10.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#ContainingEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainingEntityType As IReadOnlyEntityType Implements IReadOnlyTypeBase.ContainingEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType">
      <MemberSignature Language="C#" Value="bool Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#HasSharedClrType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasSharedClrType As Boolean Implements IReadOnlyTypeBase.HasSharedClrType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IReadOnlyModel Implements IReadOnlyTypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#ContainingEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainingEntityType As IEntityType Implements ITypeBase.ContainingEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IComplexType.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IModel Implements ITypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IModel" Usage="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="ServiceOnlyConstructorBinding">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? ServiceOnlyConstructorBinding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding ServiceOnlyConstructorBinding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.ServiceOnlyConstructorBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ServiceOnlyConstructorBinding As InstantiationBinding" />
      <MemberSignature Language="F#" Value="member this.ServiceOnlyConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.ServiceOnlyConstructorBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCounts">
      <MemberSignature Language="C#" Value="public virtual void SetCounts (Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCounts(class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.SetCounts(Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetCounts (value As PropertyCounts)" />
      <MemberSignature Language="F#" Value="abstract member SetCounts : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts -&gt; unit&#xA;override this.SetCounts : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts -&gt; unit" Usage="runtimeComplexType.SetCounts value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeComplexType.SetCounts(Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts" Index="0" FrameworkAlternate="efcore-10.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.RuntimeComplexType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="runtimeComplexType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns a string that represents the current object.
            </summary>
        <returns>A string that represents the current object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
