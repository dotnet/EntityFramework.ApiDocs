<Type Name="StructuralTypeMaterializerSource" FullName="Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource">
  <TypeSignature Language="C#" Value="public class StructuralTypeMaterializerSource : Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StructuralTypeMaterializerSource extends System.Object implements class Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource" />
  <TypeSignature Language="VB.NET" Value="Public Class StructuralTypeMaterializerSource&#xA;Implements IStructuralTypeMaterializerSource" />
  <TypeSignature Language="F#" Value="type StructuralTypeMaterializerSource = class&#xA;    interface IStructuralTypeMaterializerSource" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StructuralTypeMaterializerSource (Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSourceDependencies dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSourceDependencies dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.#ctor(Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSourceDependencies)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dependencies As StructuralTypeMaterializerSourceDependencies)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource : Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSourceDependencies -&gt; Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource" Usage="new Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource dependencies" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dependencies" Type="Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSourceDependencies" />
      </Parameters>
      <Docs>
        <param name="dependencies">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInitializeExpression">
      <MemberSignature Language="C#" Value="protected virtual void AddInitializeExpression (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase property, Microsoft.EntityFrameworkCore.Metadata.ParameterBindingInfo bindingInfo, System.Linq.Expressions.Expression instanceVariable, System.Linq.Expressions.MethodCallExpression getValueBufferExpression, System.Collections.Generic.List&lt;System.Linq.Expressions.Expression&gt; blockExpressions);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddInitializeExpression(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase property, valuetype Microsoft.EntityFrameworkCore.Metadata.ParameterBindingInfo bindingInfo, class System.Linq.Expressions.Expression instanceVariable, class System.Linq.Expressions.MethodCallExpression getValueBufferExpression, class System.Collections.Generic.List`1&lt;class System.Linq.Expressions.Expression&gt; blockExpressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.AddInitializeExpression(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,Microsoft.EntityFrameworkCore.Metadata.ParameterBindingInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.MethodCallExpression,System.Collections.Generic.List{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddInitializeExpression (property As IPropertyBase, bindingInfo As ParameterBindingInfo, instanceVariable As Expression, getValueBufferExpression As MethodCallExpression, blockExpressions As List(Of Expression))" />
      <MemberSignature Language="F#" Value="abstract member AddInitializeExpression : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * Microsoft.EntityFrameworkCore.Metadata.ParameterBindingInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.MethodCallExpression * System.Collections.Generic.List&lt;System.Linq.Expressions.Expression&gt; -&gt; unit&#xA;override this.AddInitializeExpression : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * Microsoft.EntityFrameworkCore.Metadata.ParameterBindingInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.MethodCallExpression * System.Collections.Generic.List&lt;System.Linq.Expressions.Expression&gt; -&gt; unit" Usage="structuralTypeMaterializerSource.AddInitializeExpression (property, bindingInfo, instanceVariable, getValueBufferExpression, blockExpressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
        <Parameter Name="bindingInfo" Type="Microsoft.EntityFrameworkCore.Metadata.ParameterBindingInfo" />
        <Parameter Name="instanceVariable" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="getValueBufferExpression" Type="System.Linq.Expressions.MethodCallExpression" />
        <Parameter Name="blockExpressions" Type="System.Collections.Generic.List&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="bindingInfo">To be added.</param>
        <param name="instanceVariable">To be added.</param>
        <param name="getValueBufferExpression">To be added.</param>
        <param name="blockExpressions">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMaterializeExpression">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression CreateMaterializeExpression (Microsoft.EntityFrameworkCore.Query.StructuralTypeMaterializerSourceParameters parameters, System.Linq.Expressions.Expression materializationContextExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression CreateMaterializeExpression(valuetype Microsoft.EntityFrameworkCore.Query.StructuralTypeMaterializerSourceParameters parameters, class System.Linq.Expressions.Expression materializationContextExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.CreateMaterializeExpression(Microsoft.EntityFrameworkCore.Query.StructuralTypeMaterializerSourceParameters,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateMaterializeExpression (parameters As StructuralTypeMaterializerSourceParameters, materializationContextExpression As Expression) As Expression" />
      <MemberSignature Language="F#" Value="abstract member CreateMaterializeExpression : Microsoft.EntityFrameworkCore.Query.StructuralTypeMaterializerSourceParameters * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.Expression&#xA;override this.CreateMaterializeExpression : Microsoft.EntityFrameworkCore.Query.StructuralTypeMaterializerSourceParameters * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.Expression" Usage="structuralTypeMaterializerSource.CreateMaterializeExpression (parameters, materializationContextExpression)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource.CreateMaterializeExpression(Microsoft.EntityFrameworkCore.Query.StructuralTypeMaterializerSourceParameters,System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="Microsoft.EntityFrameworkCore.Query.StructuralTypeMaterializerSourceParameters" />
        <Parameter Name="materializationContextExpression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameters">To be added.</param>
        <param name="materializationContextExpression">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dependencies">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSourceDependencies Dependencies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSourceDependencies Dependencies" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.Dependencies" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property Dependencies As StructuralTypeMaterializerSourceDependencies" />
      <MemberSignature Language="F#" Value="member this.Dependencies : Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSourceDependencies" Usage="Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.Dependencies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSourceDependencies</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Dependencies for this service.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEmptyMaterializer">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetEmptyMaterializer (Microsoft.EntityFrameworkCore.Metadata.IComplexType complexType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetEmptyMaterializer(class Microsoft.EntityFrameworkCore.Metadata.IComplexType complexType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.GetEmptyMaterializer(Microsoft.EntityFrameworkCore.Metadata.IComplexType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEmptyMaterializer (complexType As IComplexType) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetEmptyMaterializer : Microsoft.EntityFrameworkCore.Metadata.IComplexType -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;&#xA;override this.GetEmptyMaterializer : Microsoft.EntityFrameworkCore.Metadata.IComplexType -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="structuralTypeMaterializerSource.GetEmptyMaterializer complexType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource.GetEmptyMaterializer(Microsoft.EntityFrameworkCore.Metadata.IComplexType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="complexType" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexType" />
      </Parameters>
      <Docs>
        <param name="complexType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEmptyMaterializer">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetEmptyMaterializer (Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetEmptyMaterializer(class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.GetEmptyMaterializer(Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEmptyMaterializer (entityType As IEntityType) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetEmptyMaterializer : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;&#xA;override this.GetEmptyMaterializer : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="structuralTypeMaterializerSource.GetEmptyMaterializer entityType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource.GetEmptyMaterializer(Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEmptyMaterializer">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetEmptyMaterializer (Microsoft.EntityFrameworkCore.Metadata.ITypeBase entityType, Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding binding, System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt; serviceProperties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetEmptyMaterializer(class Microsoft.EntityFrameworkCore.Metadata.ITypeBase entityType, class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding binding, class System.Collections.Generic.List`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt; serviceProperties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.GetEmptyMaterializer(Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding,System.Collections.Generic.List{Microsoft.EntityFrameworkCore.Metadata.IServiceProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEmptyMaterializer (entityType As ITypeBase, binding As InstantiationBinding, serviceProperties As List(Of IServiceProperty)) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetEmptyMaterializer : Microsoft.EntityFrameworkCore.Metadata.ITypeBase * Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt; -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;&#xA;override this.GetEmptyMaterializer : Microsoft.EntityFrameworkCore.Metadata.ITypeBase * Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt; -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="structuralTypeMaterializerSource.GetEmptyMaterializer (entityType, binding, serviceProperties)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.ITypeBase" />
        <Parameter Name="binding" Type="Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" />
        <Parameter Name="serviceProperties" Type="System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="binding">To be added.</param>
        <param name="serviceProperties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaterializer">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetMaterializer (Microsoft.EntityFrameworkCore.Metadata.IComplexType complexType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetMaterializer(class Microsoft.EntityFrameworkCore.Metadata.IComplexType complexType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.GetMaterializer(Microsoft.EntityFrameworkCore.Metadata.IComplexType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMaterializer (complexType As IComplexType) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetMaterializer : Microsoft.EntityFrameworkCore.Metadata.IComplexType -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;&#xA;override this.GetMaterializer : Microsoft.EntityFrameworkCore.Metadata.IComplexType -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="structuralTypeMaterializerSource.GetMaterializer complexType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource.GetMaterializer(Microsoft.EntityFrameworkCore.Metadata.IComplexType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="complexType" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexType" />
      </Parameters>
      <Docs>
        <param name="complexType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaterializer">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetMaterializer (Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetMaterializer(class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.GetMaterializer(Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMaterializer (entityType As IEntityType) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetMaterializer : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;&#xA;override this.GetMaterializer : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="structuralTypeMaterializerSource.GetMaterializer entityType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Query.IStructuralTypeMaterializerSource.GetMaterializer(Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopulateList&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IList&lt;T&gt; PopulateList&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; buffer, System.Collections.Generic.IList&lt;T&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IList`1&lt;!!T&gt; PopulateList&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; buffer, class System.Collections.Generic.IList`1&lt;!!T&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.PopulateList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PopulateList(Of T) (buffer As IEnumerable(Of T), target As IList(Of T)) As IList(Of T)" />
      <MemberSignature Language="F#" Value="static member PopulateList : seq&lt;'T&gt; * System.Collections.Generic.IList&lt;'T&gt; -&gt; System.Collections.Generic.IList&lt;'T&gt;" Usage="Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.PopulateList (buffer, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="buffer" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="target" Type="System.Collections.Generic.IList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="buffer">To be added.</param>
        <param name="target">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopulateListMethod">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MethodInfo PopulateListMethod;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MethodInfo PopulateListMethod" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.PopulateListMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PopulateListMethod As MethodInfo " />
      <MemberSignature Language="F#" Value=" staticval mutable PopulateListMethod : System.Reflection.MethodInfo" Usage="Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.PopulateListMethod" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadComplexTypeDirectly">
      <MemberSignature Language="C#" Value="protected virtual bool ReadComplexTypeDirectly (Microsoft.EntityFrameworkCore.Metadata.IComplexType complexType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReadComplexTypeDirectly(class Microsoft.EntityFrameworkCore.Metadata.IComplexType complexType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.Internal.StructuralTypeMaterializerSource.ReadComplexTypeDirectly(Microsoft.EntityFrameworkCore.Metadata.IComplexType)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ReadComplexTypeDirectly (complexType As IComplexType) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member ReadComplexTypeDirectly : Microsoft.EntityFrameworkCore.Metadata.IComplexType -&gt; bool&#xA;override this.ReadComplexTypeDirectly : Microsoft.EntityFrameworkCore.Metadata.IComplexType -&gt; bool" Usage="structuralTypeMaterializerSource.ReadComplexTypeDirectly complexType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="complexType" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexType" />
      </Parameters>
      <Docs>
        <param name="complexType">To be added.</param>
        <summary>
                Should complex type be read directly using e.g. DbDataReader.GetFieldValue
                or is it going to be handled separately (i.e. relational JSON).
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
