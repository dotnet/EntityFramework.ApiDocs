<Type Name="StateManager" FullName="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager">
  <TypeSignature Language="C#" Value="public class StateManager : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StateManager extends System.Object implements class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager" FrameworkAlternate="efcore-1.0;efcore-1.1" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager" />
  <TypeSignature Language="VB.NET" Value="Public Class StateManager&#xA;Implements IStateManager" />
  <TypeSignature Language="F#" Value="type StateManager = class&#xA;    interface IStateManager" FrameworkAlternate="efcore-1.0;efcore-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StateManager extends System.Object implements class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager, class Microsoft.EntityFrameworkCore.Infrastructure.IResettableService" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
  <TypeSignature Language="F#" Value="type StateManager = class&#xA;    interface IStateManager&#xA;    interface IResettableService" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <AssemblyVersion>1.0.6.0</AssemblyVersion>
    <AssemblyVersion>1.1.0.0</AssemblyVersion>
    <AssemblyVersion>1.1.6.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.3.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.11.0</AssemblyVersion>
    <AssemblyVersion>2.2.6.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IResettableService</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <para>
                    This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                    the same compatibility standards as public APIs. It may be changed or removed without notice in
                    any release. You should only use it directly in your code with extreme caution and knowing that
                    doing so can result in application failures when updating to a new Entity Framework Core release.
                </para>
      <para>
                    The service lifetime is <see cref="F:Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped" />. This means that each
                    <see cref="T:Microsoft.EntityFrameworkCore.DbContext" /> instance will use its own instance of this service.
                    The implementation may depend on other services registered with any lifetime.
                    The implementation does not need to be thread-safe.
                </para>
    </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StateManager (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManagerDependencies dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManagerDependencies dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.#ctor(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManagerDependencies)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dependencies As StateManagerDependencies)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManagerDependencies -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager" Usage="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager dependencies" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dependencies" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManagerDependencies" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="dependencies">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StateManager (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory factory, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber subscriber, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier notifier, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager valueGeneration, Microsoft.EntityFrameworkCore.Metadata.IModel model, Microsoft.EntityFrameworkCore.Storage.IDatabase database, Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector concurrencyDetector, Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext currentContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory factory, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber subscriber, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier notifier, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager valueGeneration, class Microsoft.EntityFrameworkCore.Metadata.IModel model, class Microsoft.EntityFrameworkCore.Storage.IDatabase database, class Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector concurrencyDetector, class Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext currentContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.#ctor(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager,Microsoft.EntityFrameworkCore.Metadata.IModel,Microsoft.EntityFrameworkCore.Storage.IDatabase,Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector,Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (factory As IInternalEntityEntryFactory, subscriber As IInternalEntityEntrySubscriber, notifier As IInternalEntityEntryNotifier, valueGeneration As IValueGenerationManager, model As IModel, database As IDatabase, concurrencyDetector As IConcurrencyDetector, currentContext As ICurrentDbContext)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager * Microsoft.EntityFrameworkCore.Metadata.IModel * Microsoft.EntityFrameworkCore.Storage.IDatabase * Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector * Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager" Usage="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager (factory, subscriber, notifier, valueGeneration, model, database, concurrencyDetector, currentContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="factory" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="subscriber" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="notifier" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="valueGeneration" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager" Index="3" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IModel" Index="4" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="database" Type="Microsoft.EntityFrameworkCore.Storage.IDatabase" Index="5" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="concurrencyDetector" Type="Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector" Index="6" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="currentContext" Type="Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext" Index="7" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="factory">To be added.</param>
        <param name="subscriber">To be added.</param>
        <param name="notifier">To be added.</param>
        <param name="valueGeneration">To be added.</param>
        <param name="model">To be added.</param>
        <param name="database">To be added.</param>
        <param name="concurrencyDetector">To be added.</param>
        <param name="currentContext">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StateManager (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory factory, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber subscriber, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier notifier, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager valueGeneration, Microsoft.EntityFrameworkCore.Metadata.IModel model, Microsoft.EntityFrameworkCore.Storage.IDatabase database, Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector concurrencyDetector, Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext currentContext, Microsoft.EntityFrameworkCore.Diagnostics.ILoggingOptions loggingOptions, Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; updateLogger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory factory, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber subscriber, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier notifier, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager valueGeneration, class Microsoft.EntityFrameworkCore.Metadata.IModel model, class Microsoft.EntityFrameworkCore.Storage.IDatabase database, class Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector concurrencyDetector, class Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext currentContext, class Microsoft.EntityFrameworkCore.Diagnostics.ILoggingOptions loggingOptions, class Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger`1&lt;class Microsoft.EntityFrameworkCore.DbLoggerCategory/Update&gt; updateLogger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.#ctor(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager,Microsoft.EntityFrameworkCore.Metadata.IModel,Microsoft.EntityFrameworkCore.Storage.IDatabase,Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector,Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext,Microsoft.EntityFrameworkCore.Diagnostics.ILoggingOptions,Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger{Microsoft.EntityFrameworkCore.DbLoggerCategory.Update})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (factory As IInternalEntityEntryFactory, subscriber As IInternalEntityEntrySubscriber, notifier As IInternalEntityEntryNotifier, valueGeneration As IValueGenerationManager, model As IModel, database As IDatabase, concurrencyDetector As IConcurrencyDetector, currentContext As ICurrentDbContext, loggingOptions As ILoggingOptions, updateLogger As IDiagnosticsLogger(Of DbLoggerCategory.Update))" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager * Microsoft.EntityFrameworkCore.Metadata.IModel * Microsoft.EntityFrameworkCore.Storage.IDatabase * Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector * Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext * Microsoft.EntityFrameworkCore.Diagnostics.ILoggingOptions * Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager" Usage="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager (factory, subscriber, notifier, valueGeneration, model, database, concurrencyDetector, currentContext, loggingOptions, updateLogger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="factory" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryFactory" Index="0" FrameworkAlternate="efcore-2.0" />
        <Parameter Name="subscriber" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntrySubscriber" Index="1" FrameworkAlternate="efcore-2.0" />
        <Parameter Name="notifier" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier" Index="2" FrameworkAlternate="efcore-2.0" />
        <Parameter Name="valueGeneration" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager" Index="3" FrameworkAlternate="efcore-2.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IModel" Index="4" FrameworkAlternate="efcore-2.0" />
        <Parameter Name="database" Type="Microsoft.EntityFrameworkCore.Storage.IDatabase" Index="5" FrameworkAlternate="efcore-2.0" />
        <Parameter Name="concurrencyDetector" Type="Microsoft.EntityFrameworkCore.Internal.IConcurrencyDetector" Index="6" FrameworkAlternate="efcore-2.0" />
        <Parameter Name="currentContext" Type="Microsoft.EntityFrameworkCore.Internal.ICurrentDbContext" Index="7" FrameworkAlternate="efcore-2.0" />
        <Parameter Name="loggingOptions" Type="Microsoft.EntityFrameworkCore.Diagnostics.ILoggingOptions" Index="8" FrameworkAlternate="efcore-2.0" />
        <Parameter Name="updateLogger" Type="Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory+Update&gt;" Index="9" FrameworkAlternate="efcore-2.0" />
      </Parameters>
      <Docs>
        <param name="factory">To be added.</param>
        <param name="subscriber">To be added.</param>
        <param name="notifier">To be added.</param>
        <param name="valueGeneration">To be added.</param>
        <param name="model">To be added.</param>
        <param name="database">To be added.</param>
        <param name="concurrencyDetector">To be added.</param>
        <param name="currentContext">To be added.</param>
        <param name="loggingOptions">To be added.</param>
        <param name="updateLogger">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public virtual void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AcceptAllChanges ()" />
      <MemberSignature Language="F#" Value="abstract member AcceptAllChanges : unit -&gt; unit&#xA;override this.AcceptAllChanges : unit -&gt; unit" Usage="stateManager.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.AcceptAllChanges</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTrackingQuery">
      <MemberSignature Language="C#" Value="public virtual void BeginTrackingQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginTrackingQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.BeginTrackingQuery" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginTrackingQuery ()" />
      <MemberSignature Language="F#" Value="abstract member BeginTrackingQuery : unit -&gt; unit&#xA;override this.BeginTrackingQuery : unit -&gt; unit" Usage="stateManager.BeginTrackingQuery " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.BeginTrackingQuery</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CascadeChanges">
      <MemberSignature Language="C#" Value="public virtual void CascadeChanges (bool force);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CascadeChanges(bool force) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.CascadeChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CascadeChanges (force As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member CascadeChanges : bool -&gt; unit&#xA;override this.CascadeChanges : bool -&gt; unit" Usage="stateManager.CascadeChanges force" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.CascadeChanges(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="force" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="force">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CascadeDelete">
      <MemberSignature Language="C#" Value="public virtual void CascadeDelete (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, bool force, System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; foreignKeys = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CascadeDelete(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, bool force, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; foreignKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.CascadeDelete(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,System.Boolean,System.Collections.Generic.IEnumerable{Microsoft.EntityFrameworkCore.Metadata.IForeignKey})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CascadeDelete (entry As InternalEntityEntry, force As Boolean, Optional foreignKeys As IEnumerable(Of IForeignKey) = Nothing)" />
      <MemberSignature Language="F#" Value="abstract member CascadeDelete : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * bool * seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; -&gt; unit&#xA;override this.CascadeDelete : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * bool * seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; -&gt; unit" Usage="stateManager.CascadeDelete (entry, force, foreignKeys)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.CascadeDelete(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,System.Boolean,System.Collections.Generic.IEnumerable{Microsoft.EntityFrameworkCore.Metadata.IForeignKey})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="foreignKeys" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="force">To be added.</param>
        <param name="foreignKeys">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CascadeDeleteTiming">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.CascadeTiming CascadeDeleteTiming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.ChangeTracking.CascadeTiming CascadeDeleteTiming" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.CascadeDeleteTiming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CascadeDeleteTiming As CascadeTiming" />
      <MemberSignature Language="F#" Value="member this.CascadeDeleteTiming : Microsoft.EntityFrameworkCore.ChangeTracking.CascadeTiming with get, set" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.CascadeDeleteTiming" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.CascadeDeleteTiming</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.CascadeTiming</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangedCount">
      <MemberSignature Language="C#" Value="public virtual int ChangedCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChangedCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.ChangedCount" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ChangedCount As Integer" />
      <MemberSignature Language="F#" Value="member this.ChangedCount : int with get, set" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.ChangedCount" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.ChangedCount</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.DbContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.DbContext Context" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Context" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Context As DbContext" />
      <MemberSignature Language="F#" Value="member this.Context : Microsoft.EntityFrameworkCore.DbContext" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Context" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.Context</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.DbContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityFinder">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Internal.IEntityFinder CreateEntityFinder (Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Internal.IEntityFinder CreateEntityFinder(class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.CreateEntityFinder(Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEntityFinder (entityType As IEntityType) As IEntityFinder" />
      <MemberSignature Language="F#" Value="abstract member CreateEntityFinder : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Internal.IEntityFinder&#xA;override this.CreateEntityFinder : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Internal.IEntityFinder" Usage="stateManager.CreateEntityFinder entityType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.CreateEntityFinder(Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Internal.IEntityFinder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry CreateEntry (System.Collections.Generic.IDictionary&lt;string,object&gt; values, Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry CreateEntry(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; values, class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.CreateEntry(System.Collections.Generic.IDictionary{System.String,System.Object},Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEntry (values As IDictionary(Of String, Object), entityType As IEntityType) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member CreateEntry : System.Collections.Generic.IDictionary&lt;string, obj&gt; * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.CreateEntry : System.Collections.Generic.IDictionary&lt;string, obj&gt; * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.CreateEntry (values, entityType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.CreateEntry(System.Collections.Generic.IDictionary{System.String,System.Object},Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="1" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="values">To be added.</param>
        <param name="entityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteOrphansTiming">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.CascadeTiming DeleteOrphansTiming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.ChangeTracking.CascadeTiming DeleteOrphansTiming" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.DeleteOrphansTiming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteOrphansTiming As CascadeTiming" />
      <MemberSignature Language="F#" Value="member this.DeleteOrphansTiming : Microsoft.EntityFrameworkCore.ChangeTracking.CascadeTiming with get, set" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.DeleteOrphansTiming" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.DeleteOrphansTiming</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.CascadeTiming</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dependencies">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManagerDependencies Dependencies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManagerDependencies Dependencies" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Dependencies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Dependencies As StateManagerDependencies" />
      <MemberSignature Language="F#" Value="member this.Dependencies : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManagerDependencies" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Dependencies" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.Dependencies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManagerDependencies</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndSingleQueryMode">
      <MemberSignature Language="C#" Value="public virtual void EndSingleQueryMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndSingleQueryMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.EndSingleQueryMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndSingleQueryMode ()" />
      <MemberSignature Language="F#" Value="abstract member EndSingleQueryMode : unit -&gt; unit&#xA;override this.EndSingleQueryMode : unit -&gt; unit" Usage="stateManager.EndSingleQueryMode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.EndSingleQueryMode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityFinderFactory">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Internal.IEntityFinderFactory EntityFinderFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Internal.IEntityFinderFactory EntityFinderFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.EntityFinderFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntityFinderFactory As IEntityFinderFactory" />
      <MemberSignature Language="F#" Value="member this.EntityFinderFactory : Microsoft.EntityFrameworkCore.Internal.IEntityFinderFactory" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.EntityFinderFactory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Internal.IEntityFinderFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityMaterializerSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.IEntityMaterializerSource EntityMaterializerSource { get; }" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.IEntityMaterializerSource EntityMaterializerSource" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.EntityMaterializerSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntityMaterializerSource As IEntityMaterializerSource" />
      <MemberSignature Language="F#" Value="member this.EntityMaterializerSource : Microsoft.EntityFrameworkCore.Metadata.Internal.IEntityMaterializerSource" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.EntityMaterializerSource" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource EntityMaterializerSource { get; }" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource EntityMaterializerSource" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="member this.EntityMaterializerSource : Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.EntityMaterializerSource" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.EntityMaterializerSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-2.1;efcore-2.2">Microsoft.EntityFrameworkCore.Metadata.Internal.IEntityMaterializerSource</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; Entries" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Entries" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Entries As IEnumerable(Of InternalEntityEntry)" />
      <MemberSignature Language="F#" Value="member this.Entries : seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Entries" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.Entries</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindPrincipal">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry FindPrincipal (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry FindPrincipal(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.FindPrincipal(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindPrincipal (dependentEntry As InternalEntityEntry, foreignKey As IForeignKey) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member FindPrincipal : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.FindPrincipal : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.FindPrincipal (dependentEntry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.FindPrincipal(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependentEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="dependentEntry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindPrincipalUsingPreStoreGeneratedValues">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry FindPrincipalUsingPreStoreGeneratedValues (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry FindPrincipalUsingPreStoreGeneratedValues(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.FindPrincipalUsingPreStoreGeneratedValues(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindPrincipalUsingPreStoreGeneratedValues (dependentEntry As InternalEntityEntry, foreignKey As IForeignKey) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member FindPrincipalUsingPreStoreGeneratedValues : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.FindPrincipalUsingPreStoreGeneratedValues : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.FindPrincipalUsingPreStoreGeneratedValues (dependentEntry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.FindPrincipalUsingPreStoreGeneratedValues(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependentEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="dependentEntry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindPrincipalUsingRelationshipSnapshot">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry FindPrincipalUsingRelationshipSnapshot (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry FindPrincipalUsingRelationshipSnapshot(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.FindPrincipalUsingRelationshipSnapshot(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindPrincipalUsingRelationshipSnapshot (dependentEntry As InternalEntityEntry, foreignKey As IForeignKey) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member FindPrincipalUsingRelationshipSnapshot : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.FindPrincipalUsingRelationshipSnapshot : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.FindPrincipalUsingRelationshipSnapshot (dependentEntry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.FindPrincipalUsingRelationshipSnapshot(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependentEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="dependentEntry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountForState">
      <MemberSignature Language="C#" Value="public virtual int GetCountForState (bool added = false, bool modified = false, bool deleted = false, bool unchanged = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountForState(bool added, bool modified, bool deleted, bool unchanged) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetCountForState(System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCountForState (Optional added As Boolean = false, Optional modified As Boolean = false, Optional deleted As Boolean = false, Optional unchanged As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="abstract member GetCountForState : bool * bool * bool * bool -&gt; int&#xA;override this.GetCountForState : bool * bool * bool * bool -&gt; int" Usage="stateManager.GetCountForState (added, modified, deleted, unchanged)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetCountForState(System.Boolean,System.Boolean,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="added" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="modified" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="deleted" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="unchanged" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="added">To be added.</param>
        <param name="modified">To be added.</param>
        <param name="deleted">To be added.</param>
        <param name="unchanged">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDependents">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetDependents (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry principalEntry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetDependents(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry principalEntry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetDependents(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDependents (principalEntry As InternalEntityEntry, foreignKey As IForeignKey) As IEnumerable(Of InternalEntityEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetDependents : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&#xA;override this.GetDependents : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Usage="stateManager.GetDependents (principalEntry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetDependents(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principalEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" />
      </Parameters>
      <Docs>
        <param name="principalEntry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDependentsFromNavigation">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetDependentsFromNavigation (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry principalEntry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetDependentsFromNavigation(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry principalEntry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetDependentsFromNavigation(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDependentsFromNavigation (principalEntry As InternalEntityEntry, foreignKey As IForeignKey) As IEnumerable(Of InternalEntityEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetDependentsFromNavigation : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&#xA;override this.GetDependentsFromNavigation : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Usage="stateManager.GetDependentsFromNavigation (principalEntry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetDependentsFromNavigation(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principalEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" />
      </Parameters>
      <Docs>
        <param name="principalEntry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDependentsUsingRelationshipSnapshot">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetDependentsUsingRelationshipSnapshot (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry principalEntry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetDependentsUsingRelationshipSnapshot(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry principalEntry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetDependentsUsingRelationshipSnapshot(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDependentsUsingRelationshipSnapshot (principalEntry As InternalEntityEntry, foreignKey As IForeignKey) As IEnumerable(Of InternalEntityEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetDependentsUsingRelationshipSnapshot : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&#xA;override this.GetDependentsUsingRelationshipSnapshot : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Usage="stateManager.GetDependentsUsingRelationshipSnapshot (principalEntry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetDependentsUsingRelationshipSnapshot(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principalEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" />
      </Parameters>
      <Docs>
        <param name="principalEntry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntriesForState">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetEntriesForState (bool added = false, bool modified = false, bool deleted = false, bool unchanged = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetEntriesForState(bool added, bool modified, bool deleted, bool unchanged) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetEntriesForState(System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntriesForState (Optional added As Boolean = false, Optional modified As Boolean = false, Optional deleted As Boolean = false, Optional unchanged As Boolean = false) As IEnumerable(Of InternalEntityEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetEntriesForState : bool * bool * bool * bool -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&#xA;override this.GetEntriesForState : bool * bool * bool * bool -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Usage="stateManager.GetEntriesForState (added, modified, deleted, unchanged)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetEntriesForState(System.Boolean,System.Boolean,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="added" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="modified" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="deleted" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="unchanged" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="added">To be added.</param>
        <param name="modified">To be added.</param>
        <param name="deleted">To be added.</param>
        <param name="unchanged">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntriesToSave">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; GetEntriesToSave ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; GetEntriesToSave() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetEntriesToSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntriesToSave () As IReadOnlyList(Of IUpdateEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetEntriesToSave : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt;&#xA;override this.GetEntriesToSave : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt;" Usage="stateManager.GetEntriesToSave " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetEntriesToSave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntriesToSave">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; GetEntriesToSave (bool cascadeChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; GetEntriesToSave(bool cascadeChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetEntriesToSave(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntriesToSave (cascadeChanges As Boolean) As IList(Of IUpdateEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetEntriesToSave : bool -&gt; System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt;&#xA;override this.GetEntriesToSave : bool -&gt; System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt;" Usage="stateManager.GetEntriesToSave cascadeChanges" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetEntriesToSave(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cascadeChanges" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="cascadeChanges">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInternalEntriesToSave">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetInternalEntriesToSave ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; GetInternalEntriesToSave() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetInternalEntriesToSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInternalEntriesToSave () As IReadOnlyList(Of InternalEntityEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetInternalEntriesToSave : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&#xA;override this.GetInternalEntriesToSave : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Usage="stateManager.GetInternalEntriesToSave " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNonDeletedEntities&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;TEntity&gt; GetNonDeletedEntities&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;!!TEntity&gt; GetNonDeletedEntities&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetNonDeletedEntities``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNonDeletedEntities(Of TEntity As Class) () As IEnumerable(Of TEntity)" />
      <MemberSignature Language="F#" Value="abstract member GetNonDeletedEntities : unit -&gt; seq&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)&#xA;override this.GetNonDeletedEntities : unit -&gt; seq&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="stateManager.GetNonDeletedEntities " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetNonDeletedEntities``1</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetOrCreateEntry (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetOrCreateEntry(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetOrCreateEntry(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrCreateEntry (entity As Object) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateEntry : obj -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.GetOrCreateEntry : obj -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.GetOrCreateEntry entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetOrCreateEntry(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetOrCreateEntry (object entity, Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetOrCreateEntry(object entity, class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetOrCreateEntry(System.Object,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrCreateEntry (entity As Object, entityType As IEntityType) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateEntry : obj * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.GetOrCreateEntry : obj * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.GetOrCreateEntry (entity, entityType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetOrCreateEntry(System.Object,Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entity">To be added.</param>
        <param name="entityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrincipal">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetPrincipal (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetPrincipal(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetPrincipal(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrincipal (dependentEntry As InternalEntityEntry, foreignKey As IForeignKey) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member GetPrincipal : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.GetPrincipal : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.GetPrincipal (dependentEntry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetPrincipal(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependentEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="dependentEntry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrincipalUsingPreStoreGeneratedValues">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetPrincipalUsingPreStoreGeneratedValues (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetPrincipalUsingPreStoreGeneratedValues(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetPrincipalUsingPreStoreGeneratedValues(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrincipalUsingPreStoreGeneratedValues (dependentEntry As InternalEntityEntry, foreignKey As IForeignKey) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member GetPrincipalUsingPreStoreGeneratedValues : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.GetPrincipalUsingPreStoreGeneratedValues : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.GetPrincipalUsingPreStoreGeneratedValues (dependentEntry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetPrincipalUsingPreStoreGeneratedValues(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependentEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" Index="1" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="dependentEntry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrincipalUsingRelationshipSnapshot">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetPrincipalUsingRelationshipSnapshot (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry GetPrincipalUsingRelationshipSnapshot(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry dependentEntry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetPrincipalUsingRelationshipSnapshot(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrincipalUsingRelationshipSnapshot (dependentEntry As InternalEntityEntry, foreignKey As IForeignKey) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member GetPrincipalUsingRelationshipSnapshot : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.GetPrincipalUsingRelationshipSnapshot : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.GetPrincipalUsingRelationshipSnapshot (dependentEntry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetPrincipalUsingRelationshipSnapshot(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependentEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="dependentEntry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRecordedReferers">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Tuple&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&gt; GetRecordedReferers (object referencedEntity, bool clear);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Tuple`2&lt;class Microsoft.EntityFrameworkCore.Metadata.INavigation, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&gt; GetRecordedReferers(object referencedEntity, bool clear) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetRecordedReferers(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRecordedReferers (referencedEntity As Object, clear As Boolean) As IEnumerable(Of Tuple(Of INavigation, InternalEntityEntry))" />
      <MemberSignature Language="F#" Value="abstract member GetRecordedReferers : obj * bool -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&#xA;override this.GetRecordedReferers : obj * bool -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Usage="stateManager.GetRecordedReferers (referencedEntity, clear)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetRecordedReferers(System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Tuple&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="referencedEntity" Type="System.Object" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1" />
        <Parameter Name="clear" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1" />
      </Parameters>
      <Docs>
        <param name="referencedEntity">To be added.</param>
        <param name="clear">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRecordedReferrers">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Tuple&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&gt; GetRecordedReferrers (object referencedEntity, bool clear);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Tuple`2&lt;class Microsoft.EntityFrameworkCore.Metadata.INavigation, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&gt; GetRecordedReferrers(object referencedEntity, bool clear) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetRecordedReferrers(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRecordedReferrers (referencedEntity As Object, clear As Boolean) As IEnumerable(Of Tuple(Of INavigation, InternalEntityEntry))" />
      <MemberSignature Language="F#" Value="abstract member GetRecordedReferrers : obj * bool -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&#xA;override this.GetRecordedReferrers : obj * bool -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Usage="stateManager.GetRecordedReferrers (referencedEntity, clear)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetRecordedReferrers(System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Tuple&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="referencedEntity" Type="System.Object" Index="0" FrameworkAlternate="efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="clear" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="referencedEntity">To be added.</param>
        <param name="clear">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTrackingQueryMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.TrackingQueryMode GetTrackingQueryMode (Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.ChangeTracking.Internal.TrackingQueryMode GetTrackingQueryMode(class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetTrackingQueryMode(Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTrackingQueryMode (entityType As IEntityType) As TrackingQueryMode" />
      <MemberSignature Language="F#" Value="abstract member GetTrackingQueryMode : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.TrackingQueryMode&#xA;override this.GetTrackingQueryMode : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.TrackingQueryMode" Usage="stateManager.GetTrackingQueryMode entityType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.GetTrackingQueryMode(Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.TrackingQueryMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalEntityEntryNotifier">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier InternalEntityEntryNotifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier InternalEntityEntryNotifier" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.InternalEntityEntryNotifier" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property InternalEntityEntryNotifier As IInternalEntityEntryNotifier" />
      <MemberSignature Language="F#" Value="member this.InternalEntityEntryNotifier : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.InternalEntityEntryNotifier" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.InternalEntityEntryNotifier</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleQueryMode">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleQueryMode (Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSingleQueryMode(class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.IsSingleQueryMode(Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSingleQueryMode (entityType As IEntityType) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsSingleQueryMode : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; bool&#xA;override this.IsSingleQueryMode : Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; bool" Usage="stateManager.IsSingleQueryMode entityType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.IsSingleQueryMode(Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="0" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Model">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IModel Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IModel Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Model" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Model As IModel" />
      <MemberSignature Language="F#" Value="member this.Model : Microsoft.EntityFrameworkCore.Metadata.IModel" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Notify">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier Notify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier Notify" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Notify" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Notify As IInternalEntityEntryNotifier" />
      <MemberSignature Language="F#" Value="member this.Notify : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Notify" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.Notify</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntityEntryNotifier</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="public virtual void OnStateChanged (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry internalEntityEntry, Microsoft.EntityFrameworkCore.EntityState oldState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnStateChanged(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry internalEntityEntry, valuetype Microsoft.EntityFrameworkCore.EntityState oldState) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.OnStateChanged(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.EntityState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnStateChanged (internalEntityEntry As InternalEntityEntry, oldState As EntityState)" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.EntityState -&gt; unit&#xA;override this.OnStateChanged : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.EntityState -&gt; unit" Usage="stateManager.OnStateChanged (internalEntityEntry, oldState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.OnStateChanged(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.EntityState)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="internalEntityEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="oldState" Type="Microsoft.EntityFrameworkCore.EntityState" Index="1" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="internalEntityEntry">To be added.</param>
        <param name="oldState">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTracked">
      <MemberSignature Language="C#" Value="public virtual void OnTracked (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry internalEntityEntry, bool fromQuery);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnTracked(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry internalEntityEntry, bool fromQuery) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.OnTracked(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnTracked (internalEntityEntry As InternalEntityEntry, fromQuery As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member OnTracked : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * bool -&gt; unit&#xA;override this.OnTracked : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * bool -&gt; unit" Usage="stateManager.OnTracked (internalEntityEntry, fromQuery)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.OnTracked(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="internalEntityEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="fromQuery" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="internalEntityEntry">To be added.</param>
        <param name="fromQuery">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RecordReferencedUntrackedEntity">
      <MemberSignature Language="C#" Value="public virtual void RecordReferencedUntrackedEntity (object referencedEntity, Microsoft.EntityFrameworkCore.Metadata.INavigation navigation, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry referencedFromEntry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RecordReferencedUntrackedEntity(object referencedEntity, class Microsoft.EntityFrameworkCore.Metadata.INavigation navigation, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry referencedFromEntry) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.RecordReferencedUntrackedEntity(System.Object,Microsoft.EntityFrameworkCore.Metadata.INavigation,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RecordReferencedUntrackedEntity (referencedEntity As Object, navigation As INavigation, referencedFromEntry As InternalEntityEntry)" />
      <MemberSignature Language="F#" Value="abstract member RecordReferencedUntrackedEntity : obj * Microsoft.EntityFrameworkCore.Metadata.INavigation * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry -&gt; unit&#xA;override this.RecordReferencedUntrackedEntity : obj * Microsoft.EntityFrameworkCore.Metadata.INavigation * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry -&gt; unit" Usage="stateManager.RecordReferencedUntrackedEntity (referencedEntity, navigation, referencedFromEntry)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.RecordReferencedUntrackedEntity(System.Object,Microsoft.EntityFrameworkCore.Metadata.INavigation,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="referencedEntity" Type="System.Object" />
        <Parameter Name="navigation" Type="Microsoft.EntityFrameworkCore.Metadata.INavigation" />
        <Parameter Name="referencedFromEntry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" />
      </Parameters>
      <Docs>
        <param name="referencedEntity">To be added.</param>
        <param name="navigation">To be added.</param>
        <param name="referencedFromEntry">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public virtual void ResetState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetState() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.ResetState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetState ()" />
      <MemberSignature Language="F#" Value="abstract member ResetState : unit -&gt; unit&#xA;override this.ResetState : unit -&gt; unit" Usage="stateManager.ResetState " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Infrastructure.IResettableService.ResetState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetStateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task ResetStateAsync (System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task ResetStateAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.ResetStateAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResetStateAsync (Optional cancellationToken As CancellationToken = Nothing) As Task" />
      <MemberSignature Language="F#" Value="abstract member ResetStateAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.ResetStateAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stateManager.ResetStateAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Infrastructure.IResettableService.ResetStateAsync(System.Threading.CancellationToken)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"> A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete. </param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (bool acceptAllChangesOnSuccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(bool acceptAllChangesOnSuccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (acceptAllChangesOnSuccess As Boolean) As Integer" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : bool -&gt; int&#xA;override this.SaveChanges : bool -&gt; int" Usage="stateManager.SaveChanges acceptAllChangesOnSuccess" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.SaveChanges(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptAllChangesOnSuccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptAllChangesOnSuccess">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="protected virtual int SaveChanges (System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; entriesToSave);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 SaveChanges(class System.Collections.Generic.IList`1&lt;class Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; entriesToSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChanges(System.Collections.Generic.IList{Microsoft.EntityFrameworkCore.Update.IUpdateEntry})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveChanges (entriesToSave As IList(Of IUpdateEntry)) As Integer" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; -&gt; int&#xA;override this.SaveChanges : System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; -&gt; int" Usage="stateManager.SaveChanges entriesToSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entriesToSave" Type="System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entriesToSave">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="protected virtual int SaveChanges (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; entriesToSave);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 SaveChanges(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; entriesToSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChanges(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveChanges (entriesToSave As IReadOnlyList(Of InternalEntityEntry)) As Integer" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; -&gt; int&#xA;override this.SaveChanges : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; -&gt; int" Usage="stateManager.SaveChanges entriesToSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entriesToSave" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="entriesToSave">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveChangesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; SaveChangesAsync (bool acceptAllChangesOnSuccess, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; SaveChangesAsync(bool acceptAllChangesOnSuccess, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChangesAsync(System.Boolean,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChangesAsync (acceptAllChangesOnSuccess As Boolean, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SaveChangesAsync : bool * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.SaveChangesAsync : bool * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stateManager.SaveChangesAsync (acceptAllChangesOnSuccess, cancellationToken)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.SaveChangesAsync(System.Boolean,System.Threading.CancellationToken)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptAllChangesOnSuccess" Type="System.Boolean" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="acceptAllChangesOnSuccess">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveChangesAsync">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.Tasks.Task&lt;int&gt; SaveChangesAsync (System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; entriesToSave, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; SaveChangesAsync(class System.Collections.Generic.IList`1&lt;class Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; entriesToSave, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChangesAsync(System.Collections.Generic.IList{Microsoft.EntityFrameworkCore.Update.IUpdateEntry},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveChangesAsync (entriesToSave As IList(Of IUpdateEntry), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SaveChangesAsync : System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.SaveChangesAsync : System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stateManager.SaveChangesAsync (entriesToSave, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entriesToSave" Type="System.Collections.Generic.IList&lt;Microsoft.EntityFrameworkCore.Update.IUpdateEntry&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entriesToSave">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveChangesAsync">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.Tasks.Task&lt;int&gt; SaveChangesAsync (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; entriesToSave, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; SaveChangesAsync(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; entriesToSave, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChangesAsync(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveChangesAsync (entriesToSave As IReadOnlyList(Of InternalEntityEntry), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SaveChangesAsync : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.SaveChangesAsync : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stateManager.SaveChangesAsync (entriesToSave, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entriesToSave" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="entriesToSave">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SensitiveLoggingEnabled">
      <MemberSignature Language="C#" Value="public virtual bool SensitiveLoggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SensitiveLoggingEnabled" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SensitiveLoggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SensitiveLoggingEnabled As Boolean" />
      <MemberSignature Language="F#" Value="member this.SensitiveLoggingEnabled : bool" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SensitiveLoggingEnabled" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.SensitiveLoggingEnabled</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartTracking">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry StartTracking (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry StartTracking(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.StartTracking(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StartTracking (entry As InternalEntityEntry) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member StartTracking : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.StartTracking : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.StartTracking entry" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.StartTracking(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartTrackingFromQuery">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry StartTrackingFromQuery (Microsoft.EntityFrameworkCore.Metadata.IEntityType baseEntityType, object entity, Microsoft.EntityFrameworkCore.Storage.ValueBuffer valueBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry StartTrackingFromQuery(class Microsoft.EntityFrameworkCore.Metadata.IEntityType baseEntityType, object entity, [in]valuetype Microsoft.EntityFrameworkCore.Storage.ValueBuffer valueBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.StartTrackingFromQuery(Microsoft.EntityFrameworkCore.Metadata.IEntityType,System.Object,Microsoft.EntityFrameworkCore.Storage.ValueBuffer@|System.Runtime.InteropServices.InAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StartTrackingFromQuery (baseEntityType As IEntityType, entity As Object, valueBuffer As ValueBuffer) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member StartTrackingFromQuery : Microsoft.EntityFrameworkCore.Metadata.IEntityType * obj * ValueBuffer -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.StartTrackingFromQuery : Microsoft.EntityFrameworkCore.Metadata.IEntityType * obj * ValueBuffer -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.StartTrackingFromQuery (baseEntityType, entity, valueBuffer)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.StartTrackingFromQuery(Microsoft.EntityFrameworkCore.Metadata.IEntityType,System.Object,Microsoft.EntityFrameworkCore.Storage.ValueBuffer@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="0" FrameworkAlternate="efcore-1.0;efcore-3.0;efcore-3.1" />
        <Parameter Name="entity" Type="System.Object" Index="1" FrameworkAlternate="efcore-1.0;efcore-3.0;efcore-3.1" />
        <Parameter Name="valueBuffer" Type="Microsoft.EntityFrameworkCore.Storage.ValueBuffer" Index="2" FrameworkAlternate="efcore-1.0;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="baseEntityType">To be added.</param>
        <param name="entity">To be added.</param>
        <param name="valueBuffer">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartTrackingFromQuery">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry StartTrackingFromQuery (Microsoft.EntityFrameworkCore.Metadata.IEntityType baseEntityType, object entity, Microsoft.EntityFrameworkCore.Storage.ValueBuffer valueBuffer, System.Collections.Generic.ISet&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; handledForeignKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry StartTrackingFromQuery(class Microsoft.EntityFrameworkCore.Metadata.IEntityType baseEntityType, object entity, [in]valuetype Microsoft.EntityFrameworkCore.Storage.ValueBuffer valueBuffer, class System.Collections.Generic.ISet`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; handledForeignKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.StartTrackingFromQuery(Microsoft.EntityFrameworkCore.Metadata.IEntityType,System.Object,Microsoft.EntityFrameworkCore.Storage.ValueBuffer@|System.Runtime.InteropServices.InAttribute,System.Collections.Generic.ISet{Microsoft.EntityFrameworkCore.Metadata.IForeignKey})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StartTrackingFromQuery (baseEntityType As IEntityType, entity As Object, valueBuffer As ValueBuffer, handledForeignKeys As ISet(Of IForeignKey)) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member StartTrackingFromQuery : Microsoft.EntityFrameworkCore.Metadata.IEntityType * obj * ValueBuffer * System.Collections.Generic.ISet&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.StartTrackingFromQuery : Microsoft.EntityFrameworkCore.Metadata.IEntityType * obj * ValueBuffer * System.Collections.Generic.ISet&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.StartTrackingFromQuery (baseEntityType, entity, valueBuffer, handledForeignKeys)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.StartTrackingFromQuery(Microsoft.EntityFrameworkCore.Metadata.IEntityType,System.Object,Microsoft.EntityFrameworkCore.Storage.ValueBuffer@,System.Collections.Generic.ISet{Microsoft.EntityFrameworkCore.Metadata.IForeignKey})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="entity" Type="System.Object" Index="1" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="valueBuffer" Type="Microsoft.EntityFrameworkCore.Storage.ValueBuffer" Index="2" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="handledForeignKeys" Type="System.Collections.Generic.ISet&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Index="3" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="baseEntityType">To be added.</param>
        <param name="entity">To be added.</param>
        <param name="valueBuffer">To be added.</param>
        <param name="handledForeignKeys">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityStateChangedEventArgs&gt; StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.EntityStateChangedEventArgs&gt; StateChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event StateChanged As EventHandler(Of EntityStateChangedEventArgs) " />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityStateChangedEventArgs&gt; " Usage="member this.StateChanged : System.EventHandler&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityStateChangedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.StateChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityStateChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanging">
      <MemberSignature Language="C#" Value="public virtual void StateChanging (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, Microsoft.EntityFrameworkCore.EntityState newState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StateChanging(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, valuetype Microsoft.EntityFrameworkCore.EntityState newState) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.StateChanging(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.EntityState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub StateChanging (entry As InternalEntityEntry, newState As EntityState)" />
      <MemberSignature Language="F#" Value="abstract member StateChanging : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.EntityState -&gt; unit&#xA;override this.StateChanging : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.EntityState -&gt; unit" Usage="stateManager.StateChanging (entry, newState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.StateChanging(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.EntityState)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="newState" Type="Microsoft.EntityFrameworkCore.EntityState" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="newState">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopTracking">
      <MemberSignature Language="C#" Value="public virtual void StopTracking (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopTracking(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.StopTracking(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub StopTracking (entry As InternalEntityEntry)" />
      <MemberSignature Language="F#" Value="abstract member StopTracking : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry -&gt; unit&#xA;override this.StopTracking : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry -&gt; unit" Usage="stateManager.StopTracking entry" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.StopTracking(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopTracking">
      <MemberSignature Language="C#" Value="public virtual void StopTracking (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, Microsoft.EntityFrameworkCore.EntityState oldState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopTracking(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, valuetype Microsoft.EntityFrameworkCore.EntityState oldState) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.StopTracking(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.EntityState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub StopTracking (entry As InternalEntityEntry, oldState As EntityState)" />
      <MemberSignature Language="F#" Value="abstract member StopTracking : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.EntityState -&gt; unit&#xA;override this.StopTracking : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.EntityState -&gt; unit" Usage="stateManager.StopTracking (entry, oldState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.StopTracking(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.EntityState)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="oldState" Type="Microsoft.EntityFrameworkCore.EntityState" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="oldState">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tracked">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityTrackedEventArgs&gt; Tracked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.EntityTrackedEventArgs&gt; Tracked" />
      <MemberSignature Language="DocId" Value="E:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Tracked" />
      <MemberSignature Language="VB.NET" Value="Public Event Tracked As EventHandler(Of EntityTrackedEventArgs) " />
      <MemberSignature Language="F#" Value="member this.Tracked : EventHandler&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityTrackedEventArgs&gt; " Usage="member this.Tracked : System.EventHandler&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityTrackedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.Tracked</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityTrackedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.TryGetEntry(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetEntry (entity As Object) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member TryGetEntry : obj -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.TryGetEntry : obj -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.TryGetEntry entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.TryGetEntry(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0" />
      </Parameters>
      <Docs>
        <param name="entity">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry (Microsoft.EntityFrameworkCore.Metadata.IKey key, object[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry(class Microsoft.EntityFrameworkCore.Metadata.IKey key, object[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.TryGetEntry(Microsoft.EntityFrameworkCore.Metadata.IKey,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetEntry (key As IKey, keyValues As Object()) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member TryGetEntry : Microsoft.EntityFrameworkCore.Metadata.IKey * obj[] -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.TryGetEntry : Microsoft.EntityFrameworkCore.Metadata.IKey * obj[] -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.TryGetEntry (key, keyValues)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.TryGetEntry(Microsoft.EntityFrameworkCore.Metadata.IKey,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="keyValues" Type="System.Object[]" Index="1" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="keyValues">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry (object entity, Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry(object entity, class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.TryGetEntry(System.Object,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetEntry (entity As Object, entityType As IEntityType) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member TryGetEntry : obj * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.TryGetEntry : obj * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.TryGetEntry (entity, entityType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.TryGetEntry(System.Object,Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="entity">To be added.</param>
        <param name="entityType">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry (object entity, bool throwOnNonUniqueness = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry(object entity, bool throwOnNonUniqueness) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.TryGetEntry(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetEntry (entity As Object, Optional throwOnNonUniqueness As Boolean = true) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member TryGetEntry : obj * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.TryGetEntry : obj * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.TryGetEntry (entity, throwOnNonUniqueness)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.TryGetEntry(System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="throwOnNonUniqueness" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entity">To be added.</param>
        <param name="throwOnNonUniqueness">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry (Microsoft.EntityFrameworkCore.Metadata.IKey key, Microsoft.EntityFrameworkCore.Storage.ValueBuffer valueBuffer, bool throwOnNullKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry(class Microsoft.EntityFrameworkCore.Metadata.IKey key, [in]valuetype Microsoft.EntityFrameworkCore.Storage.ValueBuffer valueBuffer, bool throwOnNullKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.TryGetEntry(Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Storage.ValueBuffer@|System.Runtime.InteropServices.InAttribute,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetEntry (key As IKey, valueBuffer As ValueBuffer, throwOnNullKey As Boolean) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member TryGetEntry : Microsoft.EntityFrameworkCore.Metadata.IKey * ValueBuffer * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.TryGetEntry : Microsoft.EntityFrameworkCore.Metadata.IKey * ValueBuffer * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.TryGetEntry (key, valueBuffer, throwOnNullKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.TryGetEntry(Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Storage.ValueBuffer@,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="valueBuffer" Type="Microsoft.EntityFrameworkCore.Storage.ValueBuffer" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="throwOnNullKey" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="valueBuffer">To be added.</param>
        <param name="throwOnNullKey">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry (object entity, Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, bool throwOnTypeMismatch = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry(object entity, class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, bool throwOnTypeMismatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.TryGetEntry(System.Object,Microsoft.EntityFrameworkCore.Metadata.IEntityType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetEntry (entity As Object, entityType As IEntityType, Optional throwOnTypeMismatch As Boolean = true) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member TryGetEntry : obj * Microsoft.EntityFrameworkCore.Metadata.IEntityType * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.TryGetEntry : obj * Microsoft.EntityFrameworkCore.Metadata.IEntityType * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.TryGetEntry (entity, entityType, throwOnTypeMismatch)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.TryGetEntry(System.Object,Microsoft.EntityFrameworkCore.Metadata.IEntityType,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="throwOnTypeMismatch" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entity">To be added.</param>
        <param name="entityType">To be added.</param>
        <param name="throwOnTypeMismatch">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry (Microsoft.EntityFrameworkCore.Metadata.IKey key, object[] keyValues, bool throwOnNullKey, out bool hasNullKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry TryGetEntry(class Microsoft.EntityFrameworkCore.Metadata.IKey key, object[] keyValues, bool throwOnNullKey, [out] bool&amp; hasNullKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.TryGetEntry(Microsoft.EntityFrameworkCore.Metadata.IKey,System.Object[],System.Boolean,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetEntry (key As IKey, keyValues As Object(), throwOnNullKey As Boolean, ByRef hasNullKey As Boolean) As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="abstract member TryGetEntry : Microsoft.EntityFrameworkCore.Metadata.IKey * obj[] * bool * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry&#xA;override this.TryGetEntry : Microsoft.EntityFrameworkCore.Metadata.IKey * obj[] * bool * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="stateManager.TryGetEntry (key, keyValues, throwOnNullKey, hasNullKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.TryGetEntry(Microsoft.EntityFrameworkCore.Metadata.IKey,System.Object[],System.Boolean,System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="keyValues" Type="System.Object[]" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="throwOnNullKey" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="hasNullKey" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="keyValues">To be added.</param>
        <param name="throwOnNullKey">To be added.</param>
        <param name="hasNullKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsubscribe">
      <MemberSignature Language="C#" Value="public virtual void Unsubscribe ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unsubscribe() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.Unsubscribe" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unsubscribe ()" />
      <MemberSignature Language="F#" Value="abstract member Unsubscribe : unit -&gt; unit&#xA;override this.Unsubscribe : unit -&gt; unit" Usage="stateManager.Unsubscribe " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.Unsubscribe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDependentMap">
      <MemberSignature Language="C#" Value="public virtual void UpdateDependentMap (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateDependentMap(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.UpdateDependentMap(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateDependentMap (entry As InternalEntityEntry, foreignKey As IForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member UpdateDependentMap : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; unit&#xA;override this.UpdateDependentMap : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IForeignKey -&gt; unit" Usage="stateManager.UpdateDependentMap (entry, foreignKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.UpdateDependentMap(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateIdentityMap">
      <MemberSignature Language="C#" Value="public virtual void UpdateIdentityMap (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, Microsoft.EntityFrameworkCore.Metadata.IKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateIdentityMap(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry entry, class Microsoft.EntityFrameworkCore.Metadata.IKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.UpdateIdentityMap(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateIdentityMap (entry As InternalEntityEntry, key As IKey)" />
      <MemberSignature Language="F#" Value="abstract member UpdateIdentityMap : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IKey -&gt; unit&#xA;override this.UpdateIdentityMap : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry * Microsoft.EntityFrameworkCore.Metadata.IKey -&gt; unit" Usage="stateManager.UpdateIdentityMap (entry, key)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.UpdateIdentityMap(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.Metadata.IKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" />
        <Parameter Name="key" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="key">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateLogger">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; UpdateLogger { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger`1&lt;class Microsoft.EntityFrameworkCore.DbLoggerCategory/Update&gt; UpdateLogger" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.UpdateLogger" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UpdateLogger As IDiagnosticsLogger(Of DbLoggerCategory.Update)" />
      <MemberSignature Language="F#" Value="member this.UpdateLogger : Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt;" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.UpdateLogger" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.UpdateLogger</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory+Update&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueGeneration">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager ValueGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager ValueGeneration" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.ValueGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueGeneration As IValueGenerationManager" />
      <MemberSignature Language="F#" Value="member this.ValueGeneration : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.ValueGeneration" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.ValueGeneration</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueGenerationManager">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager ValueGenerationManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager ValueGenerationManager" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.ValueGenerationManager" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueGenerationManager As IValueGenerationManager" />
      <MemberSignature Language="F#" Value="member this.ValueGenerationManager : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.ValueGenerationManager" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager.ValueGenerationManager</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IValueGenerationManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
