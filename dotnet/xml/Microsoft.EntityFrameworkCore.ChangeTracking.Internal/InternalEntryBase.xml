<Type Name="InternalEntryBase" FullName="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase">
  <TypeSignature Language="C#" Value="public abstract class InternalEntryBase : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit InternalEntryBase extends System.Object implements class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class InternalEntryBase&#xA;Implements IInternalEntry" />
  <TypeSignature Language="F#" Value="type InternalEntryBase = class&#xA;    interface IInternalEntry" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalEntryBase (Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase structuralType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase structuralType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (structuralType As IRuntimeTypeBase)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase : Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase" Usage="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase structuralType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="structuralType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase" />
      </Parameters>
      <Docs>
        <param name="structuralType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalEntryBase (Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase structuralType, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot shadowValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase structuralType, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot shadowValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (structuralType As IRuntimeTypeBase, shadowValues As ISnapshot)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase : Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase * Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase" Usage="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase (structuralType, shadowValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="structuralType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase" />
        <Parameter Name="shadowValues" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot" />
      </Parameters>
      <Docs>
        <param name="structuralType">To be added.</param>
        <param name="shadowValues">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalEntryBase (Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase structuralType, System.Collections.Generic.IDictionary&lt;string,object?&gt; shadowValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase structuralType, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; shadowValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (structuralType As IRuntimeTypeBase, shadowValues As IDictionary(Of String, Object))" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase : Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase" Usage="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase (structuralType, shadowValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="structuralType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase" />
        <Parameter Name="shadowValues" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="structuralType">To be added.</param>
        <param name="shadowValues">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public virtual void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AcceptChanges ()" />
      <MemberSignature Language="F#" Value="abstract member AcceptChanges : unit -&gt; unit&#xA;override this.AcceptChanges : unit -&gt; unit" Usage="internalEntryBase.AcceptChanges " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.AcceptChanges</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanHaveOriginalValue">
      <MemberSignature Language="C#" Value="public bool CanHaveOriginalValue (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanHaveOriginalValue(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.CanHaveOriginalValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanHaveOriginalValue (propertyBase As IPropertyBase) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanHaveOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; bool&#xA;override this.CanHaveOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; bool" Usage="internalEntryBase.CanHaveOriginalValue propertyBase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase ContainingEntry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase ContainingEntry" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.ContainingEntry" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainingEntry As InternalEntryBase" />
      <MemberSignature Language="F#" Value="member this.ContainingEntry : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.ContainingEntry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.DbContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.DbContext Context" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.Context" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Context As DbContext" />
      <MemberSignature Language="F#" Value="member this.Context : Microsoft.EntityFrameworkCore.DbContext" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.Context" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.Context</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.DbContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardStoreGeneratedValues">
      <MemberSignature Language="C#" Value="public void DiscardStoreGeneratedValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DiscardStoreGeneratedValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.DiscardStoreGeneratedValues" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardStoreGeneratedValues ()" />
      <MemberSignature Language="F#" Value="abstract member DiscardStoreGeneratedValues : unit -&gt; unit&#xA;override this.DiscardStoreGeneratedValues : unit -&gt; unit" Usage="internalEntryBase.DiscardStoreGeneratedValues " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.DiscardStoreGeneratedValues</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureComplexCollectionEntriesCapacity">
      <MemberSignature Language="C#" Value="public virtual void EnsureComplexCollectionEntriesCapacity (Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, int capacity, int originalCapacity, bool trim = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EnsureComplexCollectionEntriesCapacity(class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, int32 capacity, int32 originalCapacity, bool trim) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.EnsureComplexCollectionEntriesCapacity(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EnsureComplexCollectionEntriesCapacity (property As IComplexProperty, capacity As Integer, originalCapacity As Integer, Optional trim As Boolean = true)" />
      <MemberSignature Language="F#" Value="abstract member EnsureComplexCollectionEntriesCapacity : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * int * int * bool -&gt; unit&#xA;override this.EnsureComplexCollectionEntriesCapacity : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * int * int * bool -&gt; unit" Usage="internalEntryBase.EnsureComplexCollectionEntriesCapacity (property, capacity, originalCapacity, trim)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="originalCapacity" Type="System.Int32" />
        <Parameter Name="trim" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="capacity">To be added.</param>
        <param name="originalCapacity">To be added.</param>
        <param name="trim">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureOriginalValues">
      <MemberSignature Language="C#" Value="public void EnsureOriginalValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EnsureOriginalValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.EnsureOriginalValues" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnsureOriginalValues ()" />
      <MemberSignature Language="F#" Value="abstract member EnsureOriginalValues : unit -&gt; unit&#xA;override this.EnsureOriginalValues : unit -&gt; unit" Usage="internalEntryBase.EnsureOriginalValues " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.EnsureOriginalValues</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureStoreGeneratedValues">
      <MemberSignature Language="C#" Value="public void EnsureStoreGeneratedValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EnsureStoreGeneratedValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.EnsureStoreGeneratedValues" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnsureStoreGeneratedValues ()" />
      <MemberSignature Language="F#" Value="abstract member EnsureStoreGeneratedValues : unit -&gt; unit&#xA;override this.EnsureStoreGeneratedValues : unit -&gt; unit" Usage="internalEntryBase.EnsureStoreGeneratedValues " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.EnsureStoreGeneratedValues</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureTemporaryValues">
      <MemberSignature Language="C#" Value="public void EnsureTemporaryValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EnsureTemporaryValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.EnsureTemporaryValues" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnsureTemporaryValues ()" />
      <MemberSignature Language="F#" Value="abstract member EnsureTemporaryValues : unit -&gt; unit&#xA;override this.EnsureTemporaryValues : unit -&gt; unit" Usage="internalEntryBase.EnsureTemporaryValues " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.EnsureTemporaryValues</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityEntry">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry EntityEntry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry EntityEntry" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.EntityEntry" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntityEntry As InternalEntityEntry" />
      <MemberSignature Language="F#" Value="member this.EntityEntry : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.EntityEntry" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.EntityEntry</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityState">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.EntityState EntityState { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.EntityState EntityState" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.EntityState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EntityState As EntityState" />
      <MemberSignature Language="F#" Value="member this.EntityState : Microsoft.EntityFrameworkCore.EntityState with get, set" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.EntityState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.EntityState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlaggedAsStoreGenerated">
      <MemberSignature Language="C#" Value="public bool FlaggedAsStoreGenerated (int propertyIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool FlaggedAsStoreGenerated(int32 propertyIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.FlaggedAsStoreGenerated(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FlaggedAsStoreGenerated (propertyIndex As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member FlaggedAsStoreGenerated : int -&gt; bool&#xA;override this.FlaggedAsStoreGenerated : int -&gt; bool" Usage="internalEntryBase.FlaggedAsStoreGenerated propertyIndex" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.FlaggedAsStoreGenerated(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="propertyIndex">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlaggedAsStoreGeneratedMethod">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MethodInfo FlaggedAsStoreGeneratedMethod;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MethodInfo FlaggedAsStoreGeneratedMethod" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.FlaggedAsStoreGeneratedMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlaggedAsStoreGeneratedMethod As MethodInfo " />
      <MemberSignature Language="F#" Value=" staticval mutable FlaggedAsStoreGeneratedMethod : System.Reflection.MethodInfo" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.FlaggedAsStoreGeneratedMethod" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlaggedAsTemporary">
      <MemberSignature Language="C#" Value="public bool FlaggedAsTemporary (int propertyIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool FlaggedAsTemporary(int32 propertyIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.FlaggedAsTemporary(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FlaggedAsTemporary (propertyIndex As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member FlaggedAsTemporary : int -&gt; bool&#xA;override this.FlaggedAsTemporary : int -&gt; bool" Usage="internalEntryBase.FlaggedAsTemporary propertyIndex" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.FlaggedAsTemporary(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="propertyIndex">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlaggedAsTemporaryMethod">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MethodInfo FlaggedAsTemporaryMethod;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MethodInfo FlaggedAsTemporaryMethod" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.FlaggedAsTemporaryMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlaggedAsTemporaryMethod As MethodInfo " />
      <MemberSignature Language="F#" Value=" staticval mutable FlaggedAsTemporaryMethod : System.Reflection.MethodInfo" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.FlaggedAsTemporaryMethod" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetComplexCollectionEntries">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry?&gt; GetComplexCollectionEntries (Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt; GetComplexCollectionEntries(class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetComplexCollectionEntries(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComplexCollectionEntries (property As IComplexProperty) As IReadOnlyList(Of InternalComplexEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetComplexCollectionEntries : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt;&#xA;override this.GetComplexCollectionEntries : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt;" Usage="internalEntryBase.GetComplexCollectionEntries property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetComplexCollectionEntries(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 2 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 2 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetComplexCollectionEntry">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry GetComplexCollectionEntry (Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry GetComplexCollectionEntry(class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetComplexCollectionEntry(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComplexCollectionEntry (property As IComplexProperty, ordinal As Integer) As InternalComplexEntry" />
      <MemberSignature Language="F#" Value="abstract member GetComplexCollectionEntry : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * int -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&#xA;override this.GetComplexCollectionEntry : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * int -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry" Usage="internalEntryBase.GetComplexCollectionEntry (property, ordinal)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetComplexCollectionEntry(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="ordinal">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetComplexCollectionOriginalEntries">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry?&gt; GetComplexCollectionOriginalEntries (Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt; GetComplexCollectionOriginalEntries(class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetComplexCollectionOriginalEntries(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComplexCollectionOriginalEntries (property As IComplexProperty) As IReadOnlyList(Of InternalComplexEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetComplexCollectionOriginalEntries : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt;&#xA;override this.GetComplexCollectionOriginalEntries : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt;" Usage="internalEntryBase.GetComplexCollectionOriginalEntries property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetComplexCollectionOriginalEntries(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 2 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 2 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetComplexCollectionOriginalEntry">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry GetComplexCollectionOriginalEntry (Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry GetComplexCollectionOriginalEntry(class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetComplexCollectionOriginalEntry(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComplexCollectionOriginalEntry (property As IComplexProperty, ordinal As Integer) As InternalComplexEntry" />
      <MemberSignature Language="F#" Value="abstract member GetComplexCollectionOriginalEntry : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * int -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&#xA;override this.GetComplexCollectionOriginalEntry : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * int -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry" Usage="internalEntryBase.GetComplexCollectionOriginalEntry (property, ordinal)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetComplexCollectionOriginalEntry(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="ordinal">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValue">
      <MemberSignature Language="C#" Value="public object? GetCurrentValue (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetCurrentValue(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetCurrentValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValue (propertyBase As IPropertyBase) As Object" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; obj&#xA;override this.GetCurrentValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; obj" Usage="internalEntryBase.GetCurrentValue propertyBase" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetCurrentValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValue&lt;TProperty&gt;">
      <MemberSignature Language="C#" Value="public TProperty GetCurrentValue&lt;TProperty&gt; (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!TProperty GetCurrentValue&lt;TProperty&gt;(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetCurrentValue``1(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValue(Of TProperty) (propertyBase As IPropertyBase) As TProperty" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; 'Property&#xA;override this.GetCurrentValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; 'Property" Usage="internalEntryBase.GetCurrentValue propertyBase" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetCurrentValue``1(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TProperty</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProperty">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <typeparam name="TProperty">To be added.</typeparam>
        <param name="propertyBase">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlattenedComplexEntries">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt; GetFlattenedComplexEntries ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt; GetFlattenedComplexEntries() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetFlattenedComplexEntries" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFlattenedComplexEntries () As IEnumerable(Of InternalComplexEntry)" />
      <MemberSignature Language="F#" Value="abstract member GetFlattenedComplexEntries : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt;&#xA;override this.GetFlattenedComplexEntries : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt;" Usage="internalEntryBase.GetFlattenedComplexEntries " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetFlattenedComplexEntries</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateShadowCollection">
      <MemberSignature Language="C#" Value="protected virtual object GetOrCreateShadowCollection (Microsoft.EntityFrameworkCore.Metadata.INavigationBase navigation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object GetOrCreateShadowCollection(class Microsoft.EntityFrameworkCore.Metadata.INavigationBase navigation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetOrCreateShadowCollection(Microsoft.EntityFrameworkCore.Metadata.INavigationBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetOrCreateShadowCollection (navigation As INavigationBase) As Object" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateShadowCollection : Microsoft.EntityFrameworkCore.Metadata.INavigationBase -&gt; obj&#xA;override this.GetOrCreateShadowCollection : Microsoft.EntityFrameworkCore.Metadata.INavigationBase -&gt; obj" Usage="internalEntryBase.GetOrCreateShadowCollection navigation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigation" Type="Microsoft.EntityFrameworkCore.Metadata.INavigationBase" />
      </Parameters>
      <Docs>
        <param name="navigation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrdinals">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;int&gt; GetOrdinals ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;int32&gt; GetOrdinals() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetOrdinals" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrdinals () As IReadOnlyList(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member GetOrdinals : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;int&gt;&#xA;override this.GetOrdinals : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;int&gt;" Usage="internalEntryBase.GetOrdinals " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetOrdinals</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                For complex element entries this returns an indices array that contains an index for each level of nested complex collection properties
                indicating the position of the current instance in the corresponding collection.
            </summary>
        <returns>To be added.</returns>
        <remarks>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOriginalValue">
      <MemberSignature Language="C#" Value="public virtual object? GetOriginalValue (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetOriginalValue(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetOriginalValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOriginalValue (propertyBase As IPropertyBase) As Object" />
      <MemberSignature Language="F#" Value="abstract member GetOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; obj&#xA;override this.GetOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; obj" Usage="internalEntryBase.GetOriginalValue propertyBase" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetOriginalValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOriginalValue&lt;TProperty&gt;">
      <MemberSignature Language="C#" Value="public TProperty GetOriginalValue&lt;TProperty&gt; (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!TProperty GetOriginalValue&lt;TProperty&gt;(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetOriginalValue``1(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOriginalValue(Of TProperty) (property As IProperty) As TProperty" />
      <MemberSignature Language="F#" Value="abstract member GetOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; 'Property&#xA;override this.GetOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; 'Property" Usage="internalEntryBase.GetOriginalValue property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetOriginalValue``1(Microsoft.EntityFrameworkCore.Metadata.IProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TProperty</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProperty">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <typeparam name="TProperty">To be added.</typeparam>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreStoreGeneratedCurrentValue">
      <MemberSignature Language="C#" Value="public object? GetPreStoreGeneratedCurrentValue (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetPreStoreGeneratedCurrentValue(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetPreStoreGeneratedCurrentValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPreStoreGeneratedCurrentValue (propertyBase As IPropertyBase) As Object" />
      <MemberSignature Language="F#" Value="abstract member GetPreStoreGeneratedCurrentValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; obj&#xA;override this.GetPreStoreGeneratedCurrentValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; obj" Usage="internalEntryBase.GetPreStoreGeneratedCurrentValue propertyBase" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.GetPreStoreGeneratedCurrentValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueType">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.CurrentValueType GetValueType (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase/CurrentValueType GetValueType(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.GetValueType(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetValueType (property As IProperty) As InternalEntryBase.CurrentValueType" />
      <MemberSignature Language="F#" Value="abstract member GetValueType : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.CurrentValueType&#xA;override this.GetValueType : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.CurrentValueType" Usage="internalEntryBase.GetValueType property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase+CurrentValueType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleConceptualNulls">
      <MemberSignature Language="C#" Value="public virtual void HandleConceptualNulls (bool sensitiveLoggingEnabled, bool force, bool isCascadeDelete);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HandleConceptualNulls(bool sensitiveLoggingEnabled, bool force, bool isCascadeDelete) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.HandleConceptualNulls(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub HandleConceptualNulls (sensitiveLoggingEnabled As Boolean, force As Boolean, isCascadeDelete As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member HandleConceptualNulls : bool * bool * bool -&gt; unit&#xA;override this.HandleConceptualNulls : bool * bool * bool -&gt; unit" Usage="internalEntryBase.HandleConceptualNulls (sensitiveLoggingEnabled, force, isCascadeDelete)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.HandleConceptualNulls(System.Boolean,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sensitiveLoggingEnabled" Type="System.Boolean" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="isCascadeDelete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sensitiveLoggingEnabled">To be added.</param>
        <param name="force">To be added.</param>
        <param name="isCascadeDelete">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleNullForeignKey">
      <MemberSignature Language="C#" Value="public virtual void HandleNullForeignKey (Microsoft.EntityFrameworkCore.Metadata.IProperty property, bool setModified = false, bool isCascadeDelete = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HandleNullForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IProperty property, bool setModified, bool isCascadeDelete) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.HandleNullForeignKey(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub HandleNullForeignKey (property As IProperty, Optional setModified As Boolean = false, Optional isCascadeDelete As Boolean = false)" />
      <MemberSignature Language="F#" Value="abstract member HandleNullForeignKey : Microsoft.EntityFrameworkCore.Metadata.IProperty * bool * bool -&gt; unit&#xA;override this.HandleNullForeignKey : Microsoft.EntityFrameworkCore.Metadata.IProperty * bool * bool -&gt; unit" Usage="internalEntryBase.HandleNullForeignKey (property, setModified, isCascadeDelete)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
        <Parameter Name="setModified" Type="System.Boolean" />
        <Parameter Name="isCascadeDelete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="setModified">To be added.</param>
        <param name="isCascadeDelete">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConceptualNull">
      <MemberSignature Language="C#" Value="public bool HasConceptualNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasConceptualNull" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.HasConceptualNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasConceptualNull As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasConceptualNull : bool" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.HasConceptualNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.HasConceptualNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasExplicitValue">
      <MemberSignature Language="C#" Value="public bool HasExplicitValue (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasExplicitValue(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.HasExplicitValue(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasExplicitValue (property As IProperty) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member HasExplicitValue : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool&#xA;override this.HasExplicitValue : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool" Usage="internalEntryBase.HasExplicitValue property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.HasExplicitValue(Microsoft.EntityFrameworkCore.Metadata.IProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasOriginalValuesSnapshot">
      <MemberSignature Language="C#" Value="public virtual bool HasOriginalValuesSnapshot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasOriginalValuesSnapshot" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.HasOriginalValuesSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasOriginalValuesSnapshot As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasOriginalValuesSnapshot : bool" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.HasOriginalValuesSnapshot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasStoreGeneratedValue">
      <MemberSignature Language="C#" Value="public bool HasStoreGeneratedValue (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasStoreGeneratedValue(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.HasStoreGeneratedValue(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasStoreGeneratedValue (property As IProperty) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member HasStoreGeneratedValue : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool&#xA;override this.HasStoreGeneratedValue : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool" Usage="internalEntryBase.HasStoreGeneratedValue property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasTemporaryValue">
      <MemberSignature Language="C#" Value="public bool HasTemporaryValue (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasTemporaryValue(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.HasTemporaryValue(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasTemporaryValue (property As IProperty) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member HasTemporaryValue : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool&#xA;override this.HasTemporaryValue : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool" Usage="internalEntryBase.HasTemporaryValue property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.HasTemporaryValue(Microsoft.EntityFrameworkCore.Metadata.IProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConceptualNull">
      <MemberSignature Language="C#" Value="public bool IsConceptualNull (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsConceptualNull(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.IsConceptualNull(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsConceptualNull (property As IProperty) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsConceptualNull : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool&#xA;override this.IsConceptualNull : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool" Usage="internalEntryBase.IsConceptualNull property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.IsConceptualNull(Microsoft.EntityFrameworkCore.Metadata.IProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsModified">
      <MemberSignature Language="C#" Value="public bool IsModified (Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsModified(class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.IsModified(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsModified (property As IComplexProperty) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsModified : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty -&gt; bool&#xA;override this.IsModified : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty -&gt; bool" Usage="internalEntryBase.IsModified property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.IsModified(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsModified">
      <MemberSignature Language="C#" Value="public bool IsModified (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsModified(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.IsModified(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsModified (property As IProperty) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsModified : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool&#xA;override this.IsModified : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool" Usage="internalEntryBase.IsModified property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.IsModified(Microsoft.EntityFrameworkCore.Metadata.IProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStoreGenerated">
      <MemberSignature Language="C#" Value="public bool IsStoreGenerated (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStoreGenerated(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.IsStoreGenerated(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStoreGenerated (property As IProperty) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsStoreGenerated : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool&#xA;override this.IsStoreGenerated : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool" Usage="internalEntryBase.IsStoreGenerated property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.IsStoreGenerated(Microsoft.EntityFrameworkCore.Metadata.IProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUnknown(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.IsUnknown(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUnknown (property As IProperty) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsUnknown : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool&#xA;override this.IsUnknown : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; bool" Usage="internalEntryBase.IsUnknown property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.IsUnknown(Microsoft.EntityFrameworkCore.Metadata.IProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object? this[Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.Item(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(propertyBase As IPropertyBase) As Object" />
      <MemberSignature Language="F#" Value="member this.Item(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase) : obj with get, set" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.Item(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkAsTemporary">
      <MemberSignature Language="C#" Value="public void MarkAsTemporary (Microsoft.EntityFrameworkCore.Metadata.IProperty property, bool temporary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkAsTemporary(class Microsoft.EntityFrameworkCore.Metadata.IProperty property, bool temporary) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.MarkAsTemporary(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MarkAsTemporary (property As IProperty, temporary As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member MarkAsTemporary : Microsoft.EntityFrameworkCore.Metadata.IProperty * bool -&gt; unit&#xA;override this.MarkAsTemporary : Microsoft.EntityFrameworkCore.Metadata.IProperty * bool -&gt; unit" Usage="internalEntryBase.MarkAsTemporary (property, temporary)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.MarkAsTemporary(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
        <Parameter Name="temporary" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="temporary">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkUnchangedFromQuery">
      <MemberSignature Language="C#" Value="public virtual void MarkUnchangedFromQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkUnchangedFromQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.MarkUnchangedFromQuery" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkUnchangedFromQuery ()" />
      <MemberSignature Language="F#" Value="abstract member MarkUnchangedFromQuery : unit -&gt; unit&#xA;override this.MarkUnchangedFromQuery : unit -&gt; unit" Usage="internalEntryBase.MarkUnchangedFromQuery " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkUnknown">
      <MemberSignature Language="C#" Value="public void MarkUnknown (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkUnknown(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.MarkUnknown(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MarkUnknown (property As IProperty)" />
      <MemberSignature Language="F#" Value="abstract member MarkUnknown : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; unit&#xA;override this.MarkUnknown : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; unit" Usage="internalEntryBase.MarkUnknown property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.MarkUnknown(Microsoft.EntityFrameworkCore.Metadata.IProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ContainingEntry">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ContainingEntry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ContainingEntry" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.Microsoft#EntityFrameworkCore#ChangeTracking#Internal#IInternalEntry#ContainingEntry" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainingEntry As IInternalEntry Implements IInternalEntry.ContainingEntry" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ContainingEntry : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ContainingEntry" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ContainingEntry</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveComplexCollectionEntry">
      <MemberSignature Language="C#" Value="public virtual void MoveComplexCollectionEntry (Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, int fromOrdinal, int toOrdinal, bool original = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveComplexCollectionEntry(class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, int32 fromOrdinal, int32 toOrdinal, bool original) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.MoveComplexCollectionEntry(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveComplexCollectionEntry (property As IComplexProperty, fromOrdinal As Integer, toOrdinal As Integer, Optional original As Boolean = false)" />
      <MemberSignature Language="F#" Value="abstract member MoveComplexCollectionEntry : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * int * int * bool -&gt; unit&#xA;override this.MoveComplexCollectionEntry : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * int * int * bool -&gt; unit" Usage="internalEntryBase.MoveComplexCollectionEntry (property, fromOrdinal, toOrdinal, original)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />
        <Parameter Name="fromOrdinal" Type="System.Int32" />
        <Parameter Name="toOrdinal" Type="System.Int32" />
        <Parameter Name="original" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="fromOrdinal">To be added.</param>
        <param name="toOrdinal">To be added.</param>
        <param name="original">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnComplexElementStateChange">
      <MemberSignature Language="C#" Value="public void OnComplexElementStateChange (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry entry, Microsoft.EntityFrameworkCore.EntityState oldState, Microsoft.EntityFrameworkCore.EntityState newState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnComplexElementStateChange(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry entry, valuetype Microsoft.EntityFrameworkCore.EntityState oldState, valuetype Microsoft.EntityFrameworkCore.EntityState newState) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.OnComplexElementStateChange(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry,Microsoft.EntityFrameworkCore.EntityState,Microsoft.EntityFrameworkCore.EntityState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnComplexElementStateChange (entry As InternalComplexEntry, oldState As EntityState, newState As EntityState)" />
      <MemberSignature Language="F#" Value="abstract member OnComplexElementStateChange : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry * Microsoft.EntityFrameworkCore.EntityState * Microsoft.EntityFrameworkCore.EntityState -&gt; unit&#xA;override this.OnComplexElementStateChange : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry * Microsoft.EntityFrameworkCore.EntityState * Microsoft.EntityFrameworkCore.EntityState -&gt; unit" Usage="internalEntryBase.OnComplexElementStateChange (entry, oldState, newState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.OnComplexElementStateChange(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry,Microsoft.EntityFrameworkCore.EntityState,Microsoft.EntityFrameworkCore.EntityState)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry" />
        <Parameter Name="oldState" Type="Microsoft.EntityFrameworkCore.EntityState" />
        <Parameter Name="newState" Type="Microsoft.EntityFrameworkCore.EntityState" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="oldState">To be added.</param>
        <param name="newState">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnComplexPropertyModified">
      <MemberSignature Language="C#" Value="public virtual void OnComplexPropertyModified (Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, bool isModified = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnComplexPropertyModified(class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, bool isModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.OnComplexPropertyModified(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnComplexPropertyModified (property As IComplexProperty, Optional isModified As Boolean = true)" />
      <MemberSignature Language="F#" Value="abstract member OnComplexPropertyModified : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * bool -&gt; unit&#xA;override this.OnComplexPropertyModified : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * bool -&gt; unit" Usage="internalEntryBase.OnComplexPropertyModified (property, isModified)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.OnComplexPropertyModified(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />
        <Parameter Name="isModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="isModified">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase, object? value, bool setModified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase, object value, bool setModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.OnPropertyChanged(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (propertyBase As IPropertyBase, value As Object, setModified As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * obj * bool -&gt; unit&#xA;override this.OnPropertyChanged : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * obj * bool -&gt; unit" Usage="internalEntryBase.OnPropertyChanged (propertyBase, value, setModified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
        <Parameter Name="value" Type="System.Object">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="setModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <param name="value">To be added.</param>
        <param name="setModified">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (Microsoft.EntityFrameworkCore.EntityState oldState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(valuetype Microsoft.EntityFrameworkCore.EntityState oldState) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.OnStateChanged(Microsoft.EntityFrameworkCore.EntityState)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (oldState As EntityState)" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : Microsoft.EntityFrameworkCore.EntityState -&gt; unit&#xA;override this.OnStateChanged : Microsoft.EntityFrameworkCore.EntityState -&gt; unit" Usage="internalEntryBase.OnStateChanged oldState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldState" Type="Microsoft.EntityFrameworkCore.EntityState" />
      </Parameters>
      <Docs>
        <param name="oldState">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanging (Microsoft.EntityFrameworkCore.EntityState newState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanging(valuetype Microsoft.EntityFrameworkCore.EntityState newState) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.OnStateChanging(Microsoft.EntityFrameworkCore.EntityState)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanging (newState As EntityState)" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanging : Microsoft.EntityFrameworkCore.EntityState -&gt; unit&#xA;override this.OnStateChanging : Microsoft.EntityFrameworkCore.EntityState -&gt; unit" Usage="internalEntryBase.OnStateChanging newState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newState" Type="Microsoft.EntityFrameworkCore.EntityState" />
      </Parameters>
      <Docs>
        <param name="newState">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareForAdd">
      <MemberSignature Language="C#" Value="protected virtual bool PrepareForAdd (Microsoft.EntityFrameworkCore.EntityState newState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool PrepareForAdd(valuetype Microsoft.EntityFrameworkCore.EntityState newState) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.PrepareForAdd(Microsoft.EntityFrameworkCore.EntityState)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function PrepareForAdd (newState As EntityState) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member PrepareForAdd : Microsoft.EntityFrameworkCore.EntityState -&gt; bool&#xA;override this.PrepareForAdd : Microsoft.EntityFrameworkCore.EntityState -&gt; bool" Usage="internalEntryBase.PrepareForAdd newState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newState" Type="Microsoft.EntityFrameworkCore.EntityState" />
      </Parameters>
      <Docs>
        <param name="newState">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareToSave">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry PrepareToSave ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry PrepareToSave() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.PrepareToSave" />
      <MemberSignature Language="VB.NET" Value="Public Function PrepareToSave () As IInternalEntry" />
      <MemberSignature Language="F#" Value="abstract member PrepareToSave : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry&#xA;override this.PrepareToSave : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry" Usage="internalEntryBase.PrepareToSave " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.PrepareToSave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyStateData">
      <MemberSignature Language="C#" Value="protected virtual ref Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.StateData PropertyStateData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase/StateData PropertyStateData" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.PropertyStateData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property PropertyStateData As InternalEntryBase.StateData" />
      <MemberSignature Language="F#" Value="member this.PropertyStateData : StateData" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.PropertyStateData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase+StateData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOriginalValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public virtual T ReadOriginalValue&lt;T&gt; (Microsoft.EntityFrameworkCore.Metadata.IProperty property, int originalValueIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T ReadOriginalValue&lt;T&gt;(class Microsoft.EntityFrameworkCore.Metadata.IProperty property, int32 originalValueIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.ReadOriginalValue``1(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOriginalValue(Of T) (property As IProperty, originalValueIndex As Integer) As T" />
      <MemberSignature Language="F#" Value="abstract member ReadOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IProperty * int -&gt; 'T&#xA;override this.ReadOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IProperty * int -&gt; 'T" Usage="internalEntryBase.ReadOriginalValue (property, originalValueIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ReadOriginalValue``1(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
        <Parameter Name="originalValueIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="property">To be added.</param>
        <param name="originalValueIndex">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPropertyValue">
      <MemberSignature Language="C#" Value="public virtual object? ReadPropertyValue (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadPropertyValue(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.ReadPropertyValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadPropertyValue (propertyBase As IPropertyBase) As Object" />
      <MemberSignature Language="F#" Value="abstract member ReadPropertyValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; obj&#xA;override this.ReadPropertyValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; obj" Usage="internalEntryBase.ReadPropertyValue propertyBase" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ReadPropertyValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadShadowValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T ReadShadowValue&lt;T&gt; (int shadowIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T ReadShadowValue&lt;T&gt;(int32 shadowIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.ReadShadowValue``1(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadShadowValue(Of T) (shadowIndex As Integer) As T" />
      <MemberSignature Language="F#" Value="abstract member ReadShadowValue : int -&gt; 'T&#xA;override this.ReadShadowValue : int -&gt; 'T" Usage="internalEntryBase.ReadShadowValue shadowIndex" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ReadShadowValue``1(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="shadowIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="shadowIndex">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadStoreGeneratedValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T ReadStoreGeneratedValue&lt;T&gt; (int storeGeneratedIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T ReadStoreGeneratedValue&lt;T&gt;(int32 storeGeneratedIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.ReadStoreGeneratedValue``1(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadStoreGeneratedValue(Of T) (storeGeneratedIndex As Integer) As T" />
      <MemberSignature Language="F#" Value="abstract member ReadStoreGeneratedValue : int -&gt; 'T&#xA;override this.ReadStoreGeneratedValue : int -&gt; 'T" Usage="internalEntryBase.ReadStoreGeneratedValue storeGeneratedIndex" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ReadStoreGeneratedValue``1(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="storeGeneratedIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="storeGeneratedIndex">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadTemporaryValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T ReadTemporaryValue&lt;T&gt; (int storeGeneratedIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T ReadTemporaryValue&lt;T&gt;(int32 storeGeneratedIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.ReadTemporaryValue``1(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadTemporaryValue(Of T) (storeGeneratedIndex As Integer) As T" />
      <MemberSignature Language="F#" Value="abstract member ReadTemporaryValue : int -&gt; 'T&#xA;override this.ReadTemporaryValue : int -&gt; 'T" Usage="internalEntryBase.ReadTemporaryValue storeGeneratedIndex" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.ReadTemporaryValue``1(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="storeGeneratedIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="storeGeneratedIndex">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEntityState">
      <MemberSignature Language="C#" Value="protected virtual void SetEntityState (Microsoft.EntityFrameworkCore.EntityState oldState, Microsoft.EntityFrameworkCore.EntityState newState, bool acceptChanges, bool modifyProperties);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetEntityState(valuetype Microsoft.EntityFrameworkCore.EntityState oldState, valuetype Microsoft.EntityFrameworkCore.EntityState newState, bool acceptChanges, bool modifyProperties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetEntityState(Microsoft.EntityFrameworkCore.EntityState,Microsoft.EntityFrameworkCore.EntityState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetEntityState (oldState As EntityState, newState As EntityState, acceptChanges As Boolean, modifyProperties As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetEntityState : Microsoft.EntityFrameworkCore.EntityState * Microsoft.EntityFrameworkCore.EntityState * bool * bool -&gt; unit&#xA;override this.SetEntityState : Microsoft.EntityFrameworkCore.EntityState * Microsoft.EntityFrameworkCore.EntityState * bool * bool -&gt; unit" Usage="internalEntryBase.SetEntityState (oldState, newState, acceptChanges, modifyProperties)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldState" Type="Microsoft.EntityFrameworkCore.EntityState" />
        <Parameter Name="newState" Type="Microsoft.EntityFrameworkCore.EntityState" />
        <Parameter Name="acceptChanges" Type="System.Boolean" />
        <Parameter Name="modifyProperties" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="oldState">To be added.</param>
        <param name="newState">To be added.</param>
        <param name="acceptChanges">To be added.</param>
        <param name="modifyProperties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEntityState">
      <MemberSignature Language="C#" Value="public virtual void SetEntityState (Microsoft.EntityFrameworkCore.EntityState entityState, bool acceptChanges = false, bool modifyProperties = true, Microsoft.EntityFrameworkCore.EntityState? forceStateWhenUnknownKey = default, Microsoft.EntityFrameworkCore.EntityState? fallbackState = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEntityState(valuetype Microsoft.EntityFrameworkCore.EntityState entityState, bool acceptChanges, bool modifyProperties, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.EntityState&gt; forceStateWhenUnknownKey, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.EntityState&gt; fallbackState) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetEntityState(Microsoft.EntityFrameworkCore.EntityState,System.Boolean,System.Boolean,System.Nullable{Microsoft.EntityFrameworkCore.EntityState},System.Nullable{Microsoft.EntityFrameworkCore.EntityState})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetEntityState (entityState As EntityState, Optional acceptChanges As Boolean = false, Optional modifyProperties As Boolean = true, Optional forceStateWhenUnknownKey As Nullable(Of EntityState) = Nothing, Optional fallbackState As Nullable(Of EntityState) = Nothing)" />
      <MemberSignature Language="F#" Value="abstract member SetEntityState : Microsoft.EntityFrameworkCore.EntityState * bool * bool * Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt; -&gt; unit&#xA;override this.SetEntityState : Microsoft.EntityFrameworkCore.EntityState * bool * bool * Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt; -&gt; unit" Usage="internalEntryBase.SetEntityState (entityState, acceptChanges, modifyProperties, forceStateWhenUnknownKey, fallbackState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.SetEntityState(Microsoft.EntityFrameworkCore.EntityState,System.Boolean,System.Boolean,System.Nullable{Microsoft.EntityFrameworkCore.EntityState},System.Nullable{Microsoft.EntityFrameworkCore.EntityState})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityState" Type="Microsoft.EntityFrameworkCore.EntityState" />
        <Parameter Name="acceptChanges" Type="System.Boolean" />
        <Parameter Name="modifyProperties" Type="System.Boolean" />
        <Parameter Name="forceStateWhenUnknownKey" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt;" />
        <Parameter Name="fallbackState" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt;" />
      </Parameters>
      <Docs>
        <param name="entityState">To be added.</param>
        <param name="acceptChanges">To be added.</param>
        <param name="modifyProperties">To be added.</param>
        <param name="forceStateWhenUnknownKey">To be added.</param>
        <param name="fallbackState">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEntityStateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SetEntityStateAsync (Microsoft.EntityFrameworkCore.EntityState entityState, bool acceptChanges = false, bool modifyProperties = true, Microsoft.EntityFrameworkCore.EntityState? forceStateWhenUnknownKey = default, Microsoft.EntityFrameworkCore.EntityState? fallbackState = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SetEntityStateAsync(valuetype Microsoft.EntityFrameworkCore.EntityState entityState, bool acceptChanges, bool modifyProperties, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.EntityState&gt; forceStateWhenUnknownKey, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.EntityState&gt; fallbackState, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetEntityStateAsync(Microsoft.EntityFrameworkCore.EntityState,System.Boolean,System.Boolean,System.Nullable{Microsoft.EntityFrameworkCore.EntityState},System.Nullable{Microsoft.EntityFrameworkCore.EntityState},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetEntityStateAsync (entityState As EntityState, Optional acceptChanges As Boolean = false, Optional modifyProperties As Boolean = true, Optional forceStateWhenUnknownKey As Nullable(Of EntityState) = Nothing, Optional fallbackState As Nullable(Of EntityState) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task" />
      <MemberSignature Language="F#" Value="abstract member SetEntityStateAsync : Microsoft.EntityFrameworkCore.EntityState * bool * bool * Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.SetEntityStateAsync : Microsoft.EntityFrameworkCore.EntityState * bool * bool * Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="internalEntryBase.SetEntityStateAsync (entityState, acceptChanges, modifyProperties, forceStateWhenUnknownKey, fallbackState, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityState" Type="Microsoft.EntityFrameworkCore.EntityState" />
        <Parameter Name="acceptChanges" Type="System.Boolean" />
        <Parameter Name="modifyProperties" Type="System.Boolean" />
        <Parameter Name="forceStateWhenUnknownKey" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt;" />
        <Parameter Name="fallbackState" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.EntityState&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="entityState">To be added.</param>
        <param name="acceptChanges">To be added.</param>
        <param name="modifyProperties">To be added.</param>
        <param name="forceStateWhenUnknownKey">To be added.</param>
        <param name="fallbackState">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetOriginalValue">
      <MemberSignature Language="C#" Value="public void SetOriginalValue (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase, object? value, int index = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetOriginalValue(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase, object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetOriginalValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetOriginalValue (propertyBase As IPropertyBase, value As Object, Optional index As Integer = -1)" />
      <MemberSignature Language="F#" Value="abstract member SetOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * obj * int -&gt; unit&#xA;override this.SetOriginalValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * obj * int -&gt; unit" Usage="internalEntryBase.SetOriginalValue (propertyBase, value, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.SetOriginalValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,System.Object,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
        <Parameter Name="value" Type="System.Object">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <param name="value">To be added.</param>
        <param name="index">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProperty">
      <MemberSignature Language="C#" Value="public void SetProperty (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase, object? value, bool isMaterialization, bool setModified = true, bool isCascadeDelete = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetProperty(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase, object value, bool isMaterialization, bool setModified, bool isCascadeDelete) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetProperty(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,System.Object,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetProperty (propertyBase As IPropertyBase, value As Object, isMaterialization As Boolean, Optional setModified As Boolean = true, Optional isCascadeDelete As Boolean = false)" />
      <MemberSignature Language="F#" Value="abstract member SetProperty : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * obj * bool * bool * bool -&gt; unit&#xA;override this.SetProperty : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * obj * bool * bool * bool -&gt; unit" Usage="internalEntryBase.SetProperty (propertyBase, value, isMaterialization, setModified, isCascadeDelete)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.SetProperty(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,System.Object,System.Boolean,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
        <Parameter Name="value" Type="System.Object">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="isMaterialization" Type="System.Boolean" />
        <Parameter Name="setModified" Type="System.Boolean" />
        <Parameter Name="isCascadeDelete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <param name="value">To be added.</param>
        <param name="isMaterialization">To be added.</param>
        <param name="setModified">To be added.</param>
        <param name="isCascadeDelete">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPropertyModified">
      <MemberSignature Language="C#" Value="public void SetPropertyModified (Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, bool isModified = true, bool recurse = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetPropertyModified(class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty property, bool isModified, bool recurse) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetPropertyModified(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPropertyModified (property As IComplexProperty, Optional isModified As Boolean = true, Optional recurse As Boolean = false)" />
      <MemberSignature Language="F#" Value="abstract member SetPropertyModified : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * bool * bool -&gt; unit&#xA;override this.SetPropertyModified : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty * bool * bool -&gt; unit" Usage="internalEntryBase.SetPropertyModified (property, isModified, recurse)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.SetPropertyModified(Microsoft.EntityFrameworkCore.Metadata.IComplexProperty,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />
        <Parameter Name="isModified" Type="System.Boolean" />
        <Parameter Name="recurse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="isModified">To be added.</param>
        <param name="recurse">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPropertyModified">
      <MemberSignature Language="C#" Value="public void SetPropertyModified (Microsoft.EntityFrameworkCore.Metadata.IProperty property, bool changeState = true, bool isModified = true, bool isConceptualNull = false, bool acceptChanges = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetPropertyModified(class Microsoft.EntityFrameworkCore.Metadata.IProperty property, bool changeState, bool isModified, bool isConceptualNull, bool acceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetPropertyModified(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPropertyModified (property As IProperty, Optional changeState As Boolean = true, Optional isModified As Boolean = true, Optional isConceptualNull As Boolean = false, Optional acceptChanges As Boolean = false)" />
      <MemberSignature Language="F#" Value="abstract member SetPropertyModified : Microsoft.EntityFrameworkCore.Metadata.IProperty * bool * bool * bool * bool -&gt; unit&#xA;override this.SetPropertyModified : Microsoft.EntityFrameworkCore.Metadata.IProperty * bool * bool * bool * bool -&gt; unit" Usage="internalEntryBase.SetPropertyModified (property, changeState, isModified, isConceptualNull, acceptChanges)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.SetPropertyModified(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Boolean,System.Boolean,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
        <Parameter Name="changeState" Type="System.Boolean" />
        <Parameter Name="isModified" Type="System.Boolean" />
        <Parameter Name="isConceptualNull" Type="System.Boolean" />
        <Parameter Name="acceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="changeState">To be added.</param>
        <param name="isModified">To be added.</param>
        <param name="isConceptualNull">To be added.</param>
        <param name="acceptChanges">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetServiceProperties">
      <MemberSignature Language="C#" Value="protected virtual void SetServiceProperties (Microsoft.EntityFrameworkCore.EntityState oldState, Microsoft.EntityFrameworkCore.EntityState newState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetServiceProperties(valuetype Microsoft.EntityFrameworkCore.EntityState oldState, valuetype Microsoft.EntityFrameworkCore.EntityState newState) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetServiceProperties(Microsoft.EntityFrameworkCore.EntityState,Microsoft.EntityFrameworkCore.EntityState)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetServiceProperties (oldState As EntityState, newState As EntityState)" />
      <MemberSignature Language="F#" Value="abstract member SetServiceProperties : Microsoft.EntityFrameworkCore.EntityState * Microsoft.EntityFrameworkCore.EntityState -&gt; unit&#xA;override this.SetServiceProperties : Microsoft.EntityFrameworkCore.EntityState * Microsoft.EntityFrameworkCore.EntityState -&gt; unit" Usage="internalEntryBase.SetServiceProperties (oldState, newState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldState" Type="Microsoft.EntityFrameworkCore.EntityState" />
        <Parameter Name="newState" Type="Microsoft.EntityFrameworkCore.EntityState" />
      </Parameters>
      <Docs>
        <param name="oldState">To be added.</param>
        <param name="newState">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStoreGeneratedValue">
      <MemberSignature Language="C#" Value="public void SetStoreGeneratedValue (Microsoft.EntityFrameworkCore.Metadata.IProperty property, object? value, bool setModified = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStoreGeneratedValue(class Microsoft.EntityFrameworkCore.Metadata.IProperty property, object value, bool setModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetStoreGeneratedValue(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetStoreGeneratedValue (property As IProperty, value As Object, Optional setModified As Boolean = true)" />
      <MemberSignature Language="F#" Value="abstract member SetStoreGeneratedValue : Microsoft.EntityFrameworkCore.Metadata.IProperty * obj * bool -&gt; unit&#xA;override this.SetStoreGeneratedValue : Microsoft.EntityFrameworkCore.Metadata.IProperty * obj * bool -&gt; unit" Usage="internalEntryBase.SetStoreGeneratedValue (property, value, setModified)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.SetStoreGeneratedValue(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
        <Parameter Name="value" Type="System.Object">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="setModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="value">To be added.</param>
        <param name="setModified">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTemporaryValue">
      <MemberSignature Language="C#" Value="public void SetTemporaryValue (Microsoft.EntityFrameworkCore.Metadata.IProperty property, object? value, bool setModified = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetTemporaryValue(class Microsoft.EntityFrameworkCore.Metadata.IProperty property, object value, bool setModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.SetTemporaryValue(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTemporaryValue (property As IProperty, value As Object, Optional setModified As Boolean = true)" />
      <MemberSignature Language="F#" Value="abstract member SetTemporaryValue : Microsoft.EntityFrameworkCore.Metadata.IProperty * obj * bool -&gt; unit&#xA;override this.SetTemporaryValue : Microsoft.EntityFrameworkCore.Metadata.IProperty * obj * bool -&gt; unit" Usage="internalEntryBase.SetTemporaryValue (property, value, setModified)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.SetTemporaryValue(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" />
        <Parameter Name="value" Type="System.Object">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="setModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="value">To be added.</param>
        <param name="setModified">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateManager">
      <MemberSignature Language="C#" Value="public abstract Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager StateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager StateManager" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.StateManager" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property StateManager As IStateManager" />
      <MemberSignature Language="F#" Value="member this.StateManager : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.StateManager" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.StateManager</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StructuralType">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase StructuralType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase StructuralType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.StructuralType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StructuralType As IRuntimeTypeBase" />
      <MemberSignature Language="F#" Value="member this.StructuralType : Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.StructuralType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IInternalEntry.StructuralType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateOrdinal">
      <MemberSignature Language="C#" Value="public virtual int ValidateOrdinal (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry entry, bool original);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ValidateOrdinal(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry entry, bool original) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntryBase.ValidateOrdinal(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateOrdinal (entry As InternalComplexEntry, original As Boolean) As Integer" />
      <MemberSignature Language="F#" Value="abstract member ValidateOrdinal : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry * bool -&gt; int&#xA;override this.ValidateOrdinal : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry * bool -&gt; int" Usage="internalEntryBase.ValidateOrdinal (entry, original)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalComplexEntry" />
        <Parameter Name="original" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="original">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
