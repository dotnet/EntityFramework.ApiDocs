<Type Name="DependentKeyValueFactory&lt;TKey&gt;" FullName="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory&lt;TKey&gt;">
  <TypeSignature Language="C#" Value="public abstract class DependentKeyValueFactory&lt;TKey&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DependentKeyValueFactory`1&lt;TKey&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory`1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DependentKeyValueFactory(Of TKey)" />
  <TypeSignature Language="F#" Value="type DependentKeyValueFactory&lt;'Key&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TKey">To be added.</typeparam>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependentKeyValueFactory (Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey, Microsoft.EntityFrameworkCore.ChangeTracking.IPrincipalKeyValueFactory&lt;TKey&gt; principalKeyValueFactory);" FrameworkAlternate="efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey, class Microsoft.EntityFrameworkCore.ChangeTracking.IPrincipalKeyValueFactory`1&lt;!TKey&gt; principalKeyValueFactory) cil managed" FrameworkAlternate="efcore-7.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory`1.#ctor(Microsoft.EntityFrameworkCore.Metadata.IForeignKey,Microsoft.EntityFrameworkCore.ChangeTracking.IPrincipalKeyValueFactory{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (foreignKey As IForeignKey, principalKeyValueFactory As IPrincipalKeyValueFactory(Of TKey))" FrameworkAlternate="efcore-7.0" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory&lt;'Key&gt; : Microsoft.EntityFrameworkCore.Metadata.IForeignKey * Microsoft.EntityFrameworkCore.ChangeTracking.IPrincipalKeyValueFactory&lt;'Key&gt; -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory&lt;'Key&gt;" Usage="new Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory&lt;'Key&gt; (foreignKey, principalKeyValueFactory)" />
      <MemberSignature Language="C#" Value="protected DependentKeyValueFactory (Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey, Microsoft.EntityFrameworkCore.ChangeTracking.IPrincipalKeyValueFactory&lt;TKey&gt; principalKeyValueFactory);" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.IForeignKey foreignKey, class Microsoft.EntityFrameworkCore.ChangeTracking.IPrincipalKeyValueFactory`1&lt;!TKey&gt; principalKeyValueFactory) cil managed" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (foreignKey As IForeignKey, principalKeyValueFactory As IPrincipalKeyValueFactory(Of TKey))" FrameworkAlternate="efcore-8.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IForeignKey" />
        <Parameter Name="principalKeyValueFactory" Type="Microsoft.EntityFrameworkCore.ChangeTracking.IPrincipalKeyValueFactory&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <param name="principalKeyValueFactory">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDependentEquatableKey">
      <MemberSignature Language="C#" Value="public virtual object? CreateDependentEquatableKey (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, bool fromOriginalValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateDependentEquatableKey(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, bool fromOriginalValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory`1.CreateDependentEquatableKey(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDependentEquatableKey (entry As IUpdateEntry, fromOriginalValues As Boolean) As Object" />
      <MemberSignature Language="F#" Value="abstract member CreateDependentEquatableKey : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * bool -&gt; obj&#xA;override this.CreateDependentEquatableKey : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * bool -&gt; obj" Usage="dependentKeyValueFactory.CreateDependentEquatableKey (entry, fromOriginalValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" />
        <Parameter Name="fromOriginalValues" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="entry">The entry tracking an entity instance.</param>
        <param name="fromOriginalValues">Whether the original or current values should be used.</param>
        <summary>
                Creates an equatable key object from the foreign key values in the given entry.
            </summary>
        <returns>The key object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePrincipalEquatableKey">
      <MemberSignature Language="C#" Value="public virtual object CreatePrincipalEquatableKey (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, bool fromOriginalValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreatePrincipalEquatableKey(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, bool fromOriginalValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory`1.CreatePrincipalEquatableKey(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreatePrincipalEquatableKey (entry As IUpdateEntry, fromOriginalValues As Boolean) As Object" />
      <MemberSignature Language="F#" Value="abstract member CreatePrincipalEquatableKey : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * bool -&gt; obj&#xA;override this.CreatePrincipalEquatableKey : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * bool -&gt; obj" Usage="dependentKeyValueFactory.CreatePrincipalEquatableKey (entry, fromOriginalValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" />
        <Parameter Name="fromOriginalValues" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="fromOriginalValues">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEqualityComparer&lt;TKey&gt; EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory`1.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EqualityComparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="F#" Value="member this.EqualityComparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory&lt;'Key&gt;.EqualityComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateFromCurrentValues">
      <MemberSignature Language="C#" Value="public abstract bool TryCreateFromCurrentValues (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, out TKey? key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateFromCurrentValues(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, [out] !TKey&amp; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory`1.TryCreateFromCurrentValues(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function TryCreateFromCurrentValues (entry As IUpdateEntry, ByRef key As TKey) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryCreateFromCurrentValues : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * 'Key -&gt; bool" Usage="dependentKeyValueFactory.TryCreateFromCurrentValues (entry, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" />
        <Parameter Name="key" Type="TKey" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="key">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateFromOriginalValues">
      <MemberSignature Language="C#" Value="public abstract bool TryCreateFromOriginalValues (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, out TKey? key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateFromOriginalValues(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, [out] !TKey&amp; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactory`1.TryCreateFromOriginalValues(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function TryCreateFromOriginalValues (entry As IUpdateEntry, ByRef key As TKey) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryCreateFromOriginalValues : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * 'Key -&gt; bool" Usage="dependentKeyValueFactory.TryCreateFromOriginalValues (entry, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" />
        <Parameter Name="key" Type="TKey" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="key">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
