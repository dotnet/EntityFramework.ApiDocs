<Type Name="ParametersCacheDecorator" FullName="Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator">
  <TypeSignature Language="C#" Value="public sealed class ParametersCacheDecorator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ParametersCacheDecorator extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ParametersCacheDecorator" />
  <TypeSignature Language="F#" Value="type ParametersCacheDecorator = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
                A decorator over <see cref="P:Microsoft.EntityFrameworkCore.Query.QueryContext.Parameters" /> which provides a cache-safe way to access parameters after the SQL cache.
            </summary>
    <remarks>
                The SQL cache only includes then nullability of parameters in its cache key. Accordingly, this type exposes an API for checking
                the nullability of a parameter. It also allows retrieving the full parameter dictionary for arbitrary checks, but when this
                API is called, the decorator records this fact, and the resulting SQL will not get cached.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ParametersCacheDecorator (System.Collections.Generic.Dictionary&lt;string,object?&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.Dictionary`2&lt;string, object&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator.#ctor(System.Collections.Generic.Dictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parameters As Dictionary(Of String, Object))" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator : System.Collections.Generic.Dictionary&lt;string, obj&gt; -&gt; Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator" Usage="new Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator parameters" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parameters" Type="System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameters">To be added.</param>
        <summary>
                A decorator over <see cref="P:Microsoft.EntityFrameworkCore.Query.QueryContext.Parameters" /> which provides a cache-safe way to access parameters after the SQL cache.
            </summary>
        <remarks>
                The SQL cache only includes then nullability of parameters in its cache key. Accordingly, this type exposes an API for checking
                the nullability of a parameter. It also allows retrieving the full parameter dictionary for arbitrary checks, but when this
                API is called, the decorator records this fact, and the resulting SQL will not get cached.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanCache">
      <MemberSignature Language="C#" Value="public bool CanCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanCache" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator.CanCache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanCache As Boolean" />
      <MemberSignature Language="F#" Value="member this.CanCache : bool" Usage="Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator.CanCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Whether the SQL generated using this decorator can be cached, i.e. whether the full dictionary of parameters
                has been accessed.
            </summary>
        <value>To be added.</value>
        <remarks>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAndDisableCaching">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;string,object?&gt; GetAndDisableCaching ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.Dictionary`2&lt;string, object&gt; GetAndDisableCaching() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator.GetAndDisableCaching" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAndDisableCaching () As Dictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="member this.GetAndDisableCaching : unit -&gt; System.Collections.Generic.Dictionary&lt;string, obj&gt;" Usage="parametersCacheDecorator.GetAndDisableCaching " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 2 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 2 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns the full dictionary of parameters, and disables caching for the generated SQL.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull (string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNull(string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Query.ParametersCacheDecorator.IsNull(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNull (parameterName As String) As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsNull : string -&gt; bool" Usage="parametersCacheDecorator.IsNull parameterName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parameterName">To be added.</param>
        <summary>
                Returns whether the parameter with the given name is <see langword="null" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>
                The method assumes that the parameter with the given name exists in the dictionary,
                and otherwise throws <see cref="T:System.Diagnostics.UnreachableException" />.
            </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
