<Type Name="Property" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.Property">
  <TypeSignature Language="C#" Value="public class Property : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase, Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Property extends Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty, class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" FrameworkAlternate="efcore-1.0" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.Property" />
  <TypeSignature Language="VB.NET" Value="Public Class Property&#xA;Inherits PropertyBase&#xA;Implements IMutableProperty" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="F#" Value="type Property = class&#xA;    inherit PropertyBase&#xA;    interface IMutableProperty&#xA;    interface IProperty&#xA;    interface IPropertyBase&#xA;    interface IAnnotatable&#xA;    interface IMutableAnnotatable" FrameworkAlternate="efcore-1.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Property extends Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty, class Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="F#" Value="type Property = class&#xA;    inherit PropertyBase&#xA;    interface IMutableProperty&#xA;    interface IProperty&#xA;    interface IPropertyBase&#xA;    interface IAnnotatable&#xA;    interface IMutablePropertyBase&#xA;    interface IMutableAnnotatable" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="C#" Value="public class Property : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase, Microsoft.EntityFrameworkCore.Metadata.IConventionProperty, Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Property extends Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty, class Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty, class Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="VB.NET" Value="Public Class Property&#xA;Inherits PropertyBase&#xA;Implements IConventionProperty, IMutableProperty" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="F#" Value="type Property = class&#xA;    inherit PropertyBase&#xA;    interface IMutableProperty&#xA;    interface IProperty&#xA;    interface IPropertyBase&#xA;    interface IAnnotatable&#xA;    interface IMutablePropertyBase&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionProperty&#xA;    interface IConventionPropertyBase&#xA;    interface IConventionAnnotatable" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="C#" Value="public class Property : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase, Microsoft.EntityFrameworkCore.Metadata.IConventionProperty, Microsoft.EntityFrameworkCore.Metadata.IMutableProperty, Microsoft.EntityFrameworkCore.Metadata.IProperty" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Property extends Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty, class Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty, class Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="VB.NET" Value="Public Class Property&#xA;Inherits PropertyBase&#xA;Implements IConventionProperty, IMutableProperty, IProperty" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="F#" Value="type Property = class&#xA;    inherit PropertyBase&#xA;    interface IMutableProperty&#xA;    interface IReadOnlyProperty&#xA;    interface IReadOnlyPropertyBase&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IMutablePropertyBase&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionProperty&#xA;    interface IConventionPropertyBase&#xA;    interface IConventionAnnotatable&#xA;    interface IProperty&#xA;    interface IPropertyBase&#xA;    interface IAnnotatable" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <AssemblyVersion>1.0.6.0</AssemblyVersion>
    <AssemblyVersion>1.1.0.0</AssemblyVersion>
    <AssemblyVersion>1.1.6.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.3.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.11.0</AssemblyVersion>
    <AssemblyVersion>2.2.6.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IProperty</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IPropertyBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="efcore-1.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{DeclaringEntityType.Name,nq}.{Name,nq} ({ClrType?.Name,nq})")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{DeclaringEntityType.Name,nq}.{Name,nq} ({ClrType?.Name,nq})")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Property (System.Reflection.PropertyInfo propertyInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.#ctor(System.Reflection.PropertyInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyInfo As PropertyInfo, declaringEntityType As EntityType, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property : System.Reflection.PropertyInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property (propertyInfo, declaringEntityType, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="0" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="declaringEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="1" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="2" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">To be added.</param>
        <param name="declaringEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Property (string name, Type clrType, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type clrType, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, clrType As Type, declaringEntityType As EntityType, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property : string * Type * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property (name, clrType, declaringEntityType, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="clrType" Type="System.Type" Index="1" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="declaringEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="2" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="3" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="clrType">To be added.</param>
        <param name="declaringEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Property (string name, Type clrType, System.Reflection.PropertyInfo propertyInfo, System.Reflection.FieldInfo fieldInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type clrType, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.#ctor(System.String,System.Type,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, clrType As Type, propertyInfo As PropertyInfo, fieldInfo As FieldInfo, declaringEntityType As EntityType, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property : string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property (name, clrType, propertyInfo, fieldInfo, declaringEntityType, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="clrType" Type="System.Type" Index="1" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="2" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" Index="3" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="declaringEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="4" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="5" FrameworkAlternate="efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="clrType">To be added.</param>
        <param name="propertyInfo">To be added.</param>
        <param name="fieldInfo">To be added.</param>
        <param name="declaringEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Property (string name, Type clrType, System.Reflection.PropertyInfo propertyInfo, System.Reflection.FieldInfo fieldInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type clrType, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.#ctor(System.String,System.Type,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, clrType As Type, propertyInfo As PropertyInfo, fieldInfo As FieldInfo, declaringEntityType As EntityType, configurationSource As ConfigurationSource, typeConfigurationSource As Nullable(Of ConfigurationSource))" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property : string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property (name, clrType, propertyInfo, fieldInfo, declaringEntityType, configurationSource, typeConfigurationSource)" />
      <MemberSignature Language="C#" Value="public Property (string name, Type clrType, System.Reflection.PropertyInfo? propertyInfo, System.Reflection.FieldInfo? fieldInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="clrType" Type="System.Type" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="declaringEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="4" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="5" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Index="6" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="clrType">To be added.</param>
        <param name="propertyInfo">To be added.</param>
        <param name="fieldInfo">To be added.</param>
        <param name="declaringEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Property (string name, Type clrType, System.Reflection.PropertyInfo propertyInfo, System.Reflection.FieldInfo fieldInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? typeConfigurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type clrType, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; typeConfigurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.#ctor(System.String,System.Type,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, clrType As Type, propertyInfo As PropertyInfo, fieldInfo As FieldInfo, declaringEntityType As EntityType, configurationSource As ConfigurationSource, typeConfigurationSource As Nullable(Of ConfigurationSource))" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property : string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property (name, clrType, propertyInfo, fieldInfo, declaringEntityType, configurationSource, typeConfigurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="clrType" Type="System.Type" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="2" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" Index="3" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="declaringEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="4" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="5" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Index="6" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="clrType">To be added.</param>
        <param name="propertyInfo">To be added.</param>
        <param name="fieldInfo">To be added.</param>
        <param name="declaringEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Property (string name, Type clrType, System.Reflection.PropertyInfo? propertyInfo, System.Reflection.FieldInfo? fieldInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase declaringType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type clrType, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase declaringType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.#ctor(System.String,System.Type,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, clrType As Type, propertyInfo As PropertyInfo, fieldInfo As FieldInfo, declaringType As TypeBase, configurationSource As ConfigurationSource, typeConfigurationSource As Nullable(Of ConfigurationSource))" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property : string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Property (name, clrType, propertyInfo, fieldInfo, declaringType, configurationSource, typeConfigurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="clrType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="declaringType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Index="4" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="5" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Index="6" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="clrType">To be added.</param>
        <param name="propertyInfo">To be added.</param>
        <param name="fieldInfo">To be added.</param>
        <param name="declaringType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AfterSaveBehavior">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior AfterSaveBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior AfterSaveBehavior" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.AfterSaveBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AfterSaveBehavior As PropertySaveBehavior" />
      <MemberSignature Language="F#" Value="member this.AfterSaveBehavior : Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.AfterSaveBehavior" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.AfterSaveBehavior</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreCompatible">
      <MemberSignature Language="C#" Value="public static bool AreCompatible (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreCompatible(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.AreCompatible(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AreCompatible (properties As IReadOnlyList(Of Property), entityType As EntityType) As Boolean" />
      <MemberSignature Language="F#" Value="static member AreCompatible : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType -&gt; bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.AreCompatible (properties, entityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" />
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="entityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeforeSaveBehavior">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior BeforeSaveBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior BeforeSaveBehavior" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.BeforeSaveBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BeforeSaveBehavior As PropertySaveBehavior" />
      <MemberSignature Language="F#" Value="member this.BeforeSaveBehavior : Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.BeforeSaveBehavior" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.BeforeSaveBehavior</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Builder">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder Builder { get; set; }" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Builder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Builder As InternalPropertyBuilder" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Builder" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder Builder { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Builder As InternalPropertyBuilder" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Builder" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckAfterSaveBehavior">
      <MemberSignature Language="C#" Value="public virtual string CheckAfterSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior behavior);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CheckAfterSaveBehavior(valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.CheckAfterSaveBehavior(Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CheckAfterSaveBehavior (behavior As PropertySaveBehavior) As String" />
      <MemberSignature Language="F#" Value="abstract member CheckAfterSaveBehavior : Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior -&gt; string&#xA;override this.CheckAfterSaveBehavior : Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior -&gt; string" Usage="property.CheckAfterSaveBehavior behavior" />
      <MemberSignature Language="C#" Value="public virtual string? CheckAfterSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior behavior);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="behavior" Type="Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="behavior">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckValueComparer">
      <MemberSignature Language="C#" Value="public virtual string CheckValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CheckValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.CheckValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CheckValueComparer (comparer As ValueComparer) As String" />
      <MemberSignature Language="F#" Value="abstract member CheckValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; string&#xA;override this.CheckValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; string" Usage="property.CheckValueComparer comparer" />
      <MemberSignature Language="C#" Value="public virtual string? CheckValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckValueConverter">
      <MemberSignature Language="C#" Value="public virtual string CheckValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CheckValueConverter(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.CheckValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CheckValueConverter (converter As ValueConverter) As String" />
      <MemberSignature Language="F#" Value="abstract member CheckValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter -&gt; string&#xA;override this.CheckValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter -&gt; string" Usage="property.CheckValueConverter converter" />
      <MemberSignature Language="C#" Value="public virtual string? CheckValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClrType">
      <MemberSignature Language="C#" Value="public virtual Type ClrType { get; }" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.ClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClrType As Type" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="F#" Value="member this.ClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.ClrType" />
      <MemberSignature Language="C#" Value="public override Type ClrType { get; }" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ClrType As Type" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">P:Microsoft.EntityFrameworkCore.Metadata.IProperty.ClrType</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0">P:Microsoft.EntityFrameworkCore.Metadata.IPropertyBase.ClrType</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase.ClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DebugView">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.DebugView&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; DebugView { get; }" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.DebugView`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; DebugView" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.DebugView" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DebugView As DebugView(Of Property)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="member this.DebugView : Microsoft.EntityFrameworkCore.Metadata.Internal.DebugView&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.DebugView" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView { get; }" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DebugView As DebugView" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.DebugView : Microsoft.EntityFrameworkCore.Infrastructure.DebugView" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.DebugView" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">Microsoft.EntityFrameworkCore.Metadata.Internal.DebugView&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Infrastructure.DebugView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringEntityType">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType DeclaringEntityType { get; }" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType DeclaringEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.DeclaringEntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringEntityType As EntityType" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="F#" Value="member this.DeclaringEntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.DeclaringEntityType" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType DeclaringEntityType { get; }" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringEntityType As EntityType" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType DeclaringType { get; }" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType DeclaringType" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringType As EntityType" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.DeclaringType" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase DeclaringType { get; }" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase DeclaringType" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As TypeBase" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.DeclaringType" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0">Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
        <ReturnType FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; ForeignKeys { get; set; }" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; ForeignKeys" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.ForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeignKeys As IReadOnlyList(Of IForeignKey)" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="F#" Value="member this.ForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.ForeignKeys" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; ForeignKeys { get; set; }" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.List`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; ForeignKeys" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeignKeys As List(Of IForeignKey)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="F#" Value="member this.ForeignKeys : System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.ForeignKeys" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; ForeignKeys { get; set; }" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.List`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; ForeignKeys" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeignKeys As List(Of ForeignKey)" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.ForeignKeys : System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.ForeignKeys" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;? ForeignKeys { get; set; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0">System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (System.Collections.Generic.IEnumerable&lt;string&gt; properties);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.Collections.Generic.IEnumerable`1&lt;string&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Format(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (properties As IEnumerable(Of String)) As String" />
      <MemberSignature Language="F#" Value="static member Format : seq&lt;string&gt; -&gt; string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Format properties" />
      <MemberSignature Language="C#" Value="public static string Format (System.Collections.Generic.IEnumerable&lt;string?&gt; properties);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, bool includeTypes = false);" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, bool includeTypes) cil managed" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Format(System.Collections.Generic.IEnumerable{Microsoft.EntityFrameworkCore.Metadata.IProperty},System.Boolean)" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (properties As IEnumerable(Of IProperty), Optional includeTypes As Boolean = false) As String" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      <MemberSignature Language="F#" Value="static member Format : seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * bool -&gt; string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Format (properties, includeTypes)" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0">System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0" />
        <Parameter Name="includeTypes" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="includeTypes">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; properties, bool includeTypes = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; properties, bool includeTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Format(System.Collections.Generic.IEnumerable{Microsoft.EntityFrameworkCore.Metadata.IPropertyBase},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (properties As IEnumerable(Of IPropertyBase), Optional includeTypes As Boolean = false) As String" />
      <MemberSignature Language="F#" Value="static member Format : seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; * bool -&gt; string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Format (properties, includeTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2" />
        <Parameter Name="includeTypes" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="includeTypes">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAfterSaveBehavior">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior GetAfterSaveBehavior ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior GetAfterSaveBehavior() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetAfterSaveBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAfterSaveBehavior () As PropertySaveBehavior" />
      <MemberSignature Language="F#" Value="abstract member GetAfterSaveBehavior : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&#xA;override this.GetAfterSaveBehavior : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior" Usage="property.GetAfterSaveBehavior " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetAfterSaveBehavior</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAfterSaveBehaviorConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetAfterSaveBehaviorConfigurationSource ();" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetAfterSaveBehaviorConfigurationSource() cil managed" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetAfterSaveBehaviorConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAfterSaveBehaviorConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetAfterSaveBehaviorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetAfterSaveBehaviorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetAfterSaveBehaviorConfigurationSource " FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetAfterSaveBehaviorConfigurationSource ();" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetAfterSaveBehaviorConfigurationSource() cil managed" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetAfterSaveBehaviorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetAfterSaveBehaviorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetAfterSaveBehaviorConfigurationSource " FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetAfterSaveBehaviorConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBeforeSaveBehavior">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior GetBeforeSaveBehavior ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior GetBeforeSaveBehavior() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetBeforeSaveBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBeforeSaveBehavior () As PropertySaveBehavior" />
      <MemberSignature Language="F#" Value="abstract member GetBeforeSaveBehavior : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&#xA;override this.GetBeforeSaveBehavior : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior" Usage="property.GetBeforeSaveBehavior " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetBeforeSaveBehavior</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBeforeSaveBehaviorConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetBeforeSaveBehaviorConfigurationSource ();" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetBeforeSaveBehaviorConfigurationSource() cil managed" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetBeforeSaveBehaviorConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBeforeSaveBehaviorConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetBeforeSaveBehaviorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetBeforeSaveBehaviorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetBeforeSaveBehaviorConfigurationSource " FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetBeforeSaveBehaviorConfigurationSource ();" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetBeforeSaveBehaviorConfigurationSource() cil managed" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetBeforeSaveBehaviorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetBeforeSaveBehaviorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetBeforeSaveBehaviorConfigurationSource " FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetBeforeSaveBehaviorConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource GetConfigurationSource ();" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource GetConfigurationSource() cil managed" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigurationSource () As ConfigurationSource" />
      <MemberSignature Language="F#" Value="abstract member GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&#xA;override this.GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Usage="property.GetConfigurationSource " FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource ();" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&#xA;override this.GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Usage="property.GetConfigurationSource " FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1">M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainingForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetContainingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetContainingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetContainingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetContainingForeignKeys () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="property.GetContainingForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainingIndexes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetContainingIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetContainingIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetContainingIndexes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetContainingIndexes () As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="property.GetContainingIndexes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainingKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt; GetContainingKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt; GetContainingKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetContainingKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetContainingKeys () As IEnumerable(Of Key)" />
      <MemberSignature Language="F#" Value="abstract member GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;&#xA;override this.GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;" Usage="property.GetContainingKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType? GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementType () As ElementType" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType&#xA;override this.GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType" Usage="property.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetElementTypeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetElementTypeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetElementTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetElementTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetElementTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetElementTypeConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetElementTypeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsConcurrencyTokenConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetIsConcurrencyTokenConfigurationSource ();" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetIsConcurrencyTokenConfigurationSource() cil managed" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetIsConcurrencyTokenConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsConcurrencyTokenConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsConcurrencyTokenConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetIsConcurrencyTokenConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetIsConcurrencyTokenConfigurationSource " FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetIsConcurrencyTokenConfigurationSource ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetIsConcurrencyTokenConfigurationSource() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetIsConcurrencyTokenConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetIsConcurrencyTokenConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetIsConcurrencyTokenConfigurationSource " FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetIsConcurrencyTokenConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsNullableConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetIsNullableConfigurationSource ();" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetIsNullableConfigurationSource() cil managed" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetIsNullableConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsNullableConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsNullableConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetIsNullableConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetIsNullableConfigurationSource " FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetIsNullableConfigurationSource ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetIsNullableConfigurationSource() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetIsNullableConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetIsNullableConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetIsNullableConfigurationSource " FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetIsNullableConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsReadOnlyAfterSaveConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetIsReadOnlyAfterSaveConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetIsReadOnlyAfterSaveConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetIsReadOnlyAfterSaveConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsReadOnlyAfterSaveConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsReadOnlyAfterSaveConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetIsReadOnlyAfterSaveConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetIsReadOnlyAfterSaveConfigurationSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsReadOnlyBeforeSaveConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetIsReadOnlyBeforeSaveConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetIsReadOnlyBeforeSaveConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetIsReadOnlyBeforeSaveConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsReadOnlyBeforeSaveConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsReadOnlyBeforeSaveConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetIsReadOnlyBeforeSaveConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetIsReadOnlyBeforeSaveConfigurationSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsStoreGeneratedAlwaysConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetIsStoreGeneratedAlwaysConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetIsStoreGeneratedAlwaysConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetIsStoreGeneratedAlwaysConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsStoreGeneratedAlwaysConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsStoreGeneratedAlwaysConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetIsStoreGeneratedAlwaysConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetIsStoreGeneratedAlwaysConfigurationSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsUnicodeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetIsUnicodeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetIsUnicodeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetIsUnicodeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsUnicodeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsUnicodeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetIsUnicodeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetIsUnicodeConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetIsUnicodeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetJsonValueReaderWriter">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter? GetJsonValueReaderWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter GetJsonValueReaderWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetJsonValueReaderWriter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJsonValueReaderWriter () As JsonValueReaderWriter" />
      <MemberSignature Language="F#" Value="abstract member GetJsonValueReaderWriter : unit -&gt; Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter&#xA;override this.GetJsonValueReaderWriter : unit -&gt; Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter" Usage="property.GetJsonValueReaderWriter " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetJsonValueReaderWriter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetJsonValueReaderWriterTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetJsonValueReaderWriterTypeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetJsonValueReaderWriterTypeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetJsonValueReaderWriterTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJsonValueReaderWriterTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetJsonValueReaderWriterTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetJsonValueReaderWriterTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetJsonValueReaderWriterTypeConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetJsonValueReaderWriterTypeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKeyValueComparer">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? GetKeyValueComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer GetKeyValueComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetKeyValueComparer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKeyValueComparer () As ValueComparer" />
      <MemberSignature Language="F#" Value="abstract member GetKeyValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.GetKeyValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.GetKeyValueComparer " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetKeyValueComparer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxLength">
      <MemberSignature Language="C#" Value="public virtual int? GetMaxLength ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; GetMaxLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetMaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMaxLength () As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member GetMaxLength : unit -&gt; Nullable&lt;int&gt;&#xA;override this.GetMaxLength : unit -&gt; Nullable&lt;int&gt;" Usage="property.GetMaxLength " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetMaxLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxLengthConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetMaxLengthConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetMaxLengthConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetMaxLengthConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMaxLengthConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetMaxLengthConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetMaxLengthConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetMaxLengthConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetMaxLengthConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrecision">
      <MemberSignature Language="C#" Value="public virtual int? GetPrecision ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; GetPrecision() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetPrecision" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrecision () As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member GetPrecision : unit -&gt; Nullable&lt;int&gt;&#xA;override this.GetPrecision : unit -&gt; Nullable&lt;int&gt;" Usage="property.GetPrecision " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetPrecision</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrecisionConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetPrecisionConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetPrecisionConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetPrecisionConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrecisionConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetPrecisionConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetPrecisionConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetPrecisionConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetPrecisionConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProviderClrType">
      <MemberSignature Language="C#" Value="public virtual Type? GetProviderClrType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetProviderClrType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetProviderClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProviderClrType () As Type" />
      <MemberSignature Language="F#" Value="abstract member GetProviderClrType : unit -&gt; Type&#xA;override this.GetProviderClrType : unit -&gt; Type" Usage="property.GetProviderClrType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetProviderClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProviderClrTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetProviderClrTypeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetProviderClrTypeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetProviderClrTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProviderClrTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetProviderClrTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetProviderClrTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetProviderClrTypeConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetProviderClrTypeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProviderValueComparer">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? GetProviderValueComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer GetProviderValueComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetProviderValueComparer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProviderValueComparer () As ValueComparer" />
      <MemberSignature Language="F#" Value="abstract member GetProviderValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.GetProviderValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.GetProviderValueComparer " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetProviderValueComparer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProviderValueComparerConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetProviderValueComparerConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetProviderValueComparerConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetProviderValueComparerConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProviderValueComparerConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetProviderValueComparerConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetProviderValueComparerConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetProviderValueComparerConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetProviderValueComparerConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRequiresValueGeneratorConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetRequiresValueGeneratorConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetRequiresValueGeneratorConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetRequiresValueGeneratorConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRequiresValueGeneratorConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetRequiresValueGeneratorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetRequiresValueGeneratorConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetRequiresValueGeneratorConfigurationSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScale">
      <MemberSignature Language="C#" Value="public virtual int? GetScale ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; GetScale() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetScale" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetScale () As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member GetScale : unit -&gt; Nullable&lt;int&gt;&#xA;override this.GetScale : unit -&gt; Nullable&lt;int&gt;" Usage="property.GetScale " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetScale</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaleConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetScaleConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetScaleConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetScaleConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetScaleConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetScaleConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetScaleConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetScaleConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetScaleConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSentinelConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetSentinelConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetSentinelConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetSentinelConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSentinelConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetSentinelConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetSentinelConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetSentinelConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetSentinelConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetTypeConfigurationSource ();" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetTypeConfigurationSource() cil managed" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetTypeConfigurationSource " FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetTypeConfigurationSource ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetTypeConfigurationSource() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetTypeConfigurationSource " FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetTypeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeMappingConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetTypeMappingConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetTypeMappingConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetTypeMappingConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeMappingConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetTypeMappingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetTypeMappingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetTypeMappingConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetTypeMappingConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueComparer">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? GetValueComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer GetValueComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetValueComparer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueComparer () As ValueComparer" />
      <MemberSignature Language="F#" Value="abstract member GetValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.GetValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.GetValueComparer " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetValueComparer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueComparerConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetValueComparerConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetValueComparerConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetValueComparerConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueComparerConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetValueComparerConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetValueComparerConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetValueComparerConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetValueComparerConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueConverter">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? GetValueConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter GetValueConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetValueConverter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueConverter () As ValueConverter" />
      <MemberSignature Language="F#" Value="abstract member GetValueConverter : unit -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter&#xA;override this.GetValueConverter : unit -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Usage="property.GetValueConverter " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetValueConverter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueConverterConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetValueConverterConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetValueConverterConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetValueConverterConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueConverterConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetValueConverterConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetValueConverterConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetValueConverterConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetValueConverterConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueGeneratedConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetValueGeneratedConfigurationSource ();" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetValueGeneratedConfigurationSource() cil managed" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetValueGeneratedConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueGeneratedConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetValueGeneratedConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetValueGeneratedConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="property.GetValueGeneratedConfigurationSource " FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetValueGeneratedConfigurationSource ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetValueGeneratedConfigurationSource() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetValueGeneratedConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetValueGeneratedConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetValueGeneratedConfigurationSource " FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetValueGeneratedConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? GetValueGeneratorFactory ();" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; GetValueGeneratorFactory() cil managed" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetValueGeneratorFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueGeneratorFactory () As Func(Of IProperty, IEntityType, ValueGenerator)" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="abstract member GetValueGeneratorFactory : unit -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;&#xA;override this.GetValueGeneratorFactory : unit -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Usage="property.GetValueGeneratorFactory " FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? GetValueGeneratorFactory ();" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; GetValueGeneratorFactory() cil managed" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueGeneratorFactory () As Func(Of IProperty, ITypeBase, ValueGenerator)" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetValueGeneratorFactory : unit -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;&#xA;override this.GetValueGeneratorFactory : unit -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Usage="property.GetValueGeneratorFactory " FrameworkAlternate="efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetValueGeneratorFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-6.0;efcore-7.0">System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-8.0">System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueGeneratorFactoryConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetValueGeneratorFactoryConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetValueGeneratorFactoryConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.GetValueGeneratorFactoryConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueGeneratorFactoryConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetValueGeneratorFactoryConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetValueGeneratorFactoryConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="property.GetValueGeneratorFactoryConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetValueGeneratorFactoryConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Indexes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; Indexes { get; set; }" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; Indexes" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Indexes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Indexes As IReadOnlyList(Of IIndex)" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="F#" Value="member this.Indexes : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Indexes" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; Indexes { get; set; }" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.List`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; Indexes" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Indexes As List(Of IIndex)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="F#" Value="member this.Indexes : System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Indexes" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; Indexes { get; set; }" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.List`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; Indexes" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Indexes As List(Of Index)" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.Indexes : System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Indexes" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;? Indexes { get; set; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0">System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConcurrencyToken">
      <MemberSignature Language="C#" Value="public virtual bool IsConcurrencyToken { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConcurrencyToken" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsConcurrencyToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsConcurrencyToken As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsConcurrencyToken : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsConcurrencyToken" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.IsConcurrencyToken</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsForeignKey">
      <MemberSignature Language="C#" Value="public virtual bool IsForeignKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsForeignKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsForeignKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsForeignKey () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsForeignKey : unit -&gt; bool&#xA;override this.IsForeignKey : unit -&gt; bool" Usage="property.IsForeignKey " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.IsForeignKey</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIndex">
      <MemberSignature Language="C#" Value="public virtual bool IsIndex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsIndex() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsIndex" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsIndex () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsIndex : unit -&gt; bool&#xA;override this.IsIndex : unit -&gt; bool" Usage="property.IsIndex " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.IsIndex</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInModel">
      <MemberSignature Language="C#" Value="public virtual bool IsInModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsInModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInModel As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsInModel : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsInModel" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.IsInModel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKey">
      <MemberSignature Language="C#" Value="public virtual bool IsKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsKey () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsKey : unit -&gt; bool&#xA;override this.IsKey : unit -&gt; bool" Usage="property.IsKey " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.IsKey</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public virtual bool IsNullable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsNullable As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsNullable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.IsNullable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveCollection">
      <MemberSignature Language="C#" Value="public virtual bool IsPrimitiveCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitiveCollection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsPrimitiveCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsPrimitiveCollection As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsPrimitiveCollection : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsPrimitiveCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.IsPrimitiveCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnlyAfterSave">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnlyAfterSave { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnlyAfterSave" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsReadOnlyAfterSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsReadOnlyAfterSave As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsReadOnlyAfterSave : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsReadOnlyAfterSave" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.IsReadOnlyAfterSave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2">
          <AttributeName Language="C#">[System.Obsolete("Use AfterSaveBehavior instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AfterSaveBehavior instead.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnlyBeforeSave">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnlyBeforeSave { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnlyBeforeSave" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsReadOnlyBeforeSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsReadOnlyBeforeSave As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsReadOnlyBeforeSave : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsReadOnlyBeforeSave" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.IsReadOnlyBeforeSave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2">
          <AttributeName Language="C#">[System.Obsolete("Use BeforeSaveBehavior instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use BeforeSaveBehavior instead.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsShadowProperty">
      <MemberSignature Language="C#" Value="public virtual bool IsShadowProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsShadowProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsShadowProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsShadowProperty As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsShadowProperty : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsShadowProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IProperty.IsShadowProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStoreGeneratedAlways">
      <MemberSignature Language="C#" Value="public virtual bool IsStoreGeneratedAlways { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStoreGeneratedAlways" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsStoreGeneratedAlways" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsStoreGeneratedAlways As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsStoreGeneratedAlways : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsStoreGeneratedAlways" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.IsStoreGeneratedAlways</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2">
          <AttributeName Language="C#">[System.Obsolete("Use BeforeSaveBehavior or AfterSaveBehavior instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use BeforeSaveBehavior or AfterSaveBehavior instead.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicode">
      <MemberSignature Language="C#" Value="public virtual bool? IsUnicode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; IsUnicode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.IsUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsUnicode () As Nullable(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member IsUnicode : unit -&gt; Nullable&lt;bool&gt;&#xA;override this.IsUnicode : unit -&gt; Nullable&lt;bool&gt;" Usage="property.IsUnicode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.IsUnicode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt; Keys { get; set; }" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IKey&gt; Keys" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Keys As IReadOnlyList(Of IKey)" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Keys" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt; Keys { get; set; }" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.List`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IKey&gt; Keys" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Keys As List(Of IKey)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Keys" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt; Keys { get; set; }" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.List`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt; Keys" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Keys As List(Of Key)" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Keys" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;? Keys { get; set; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0">System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionAnnotatable#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionAnnotatableBuilder Implements IConventionAnnotatable.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionPropertyBuilder Implements IConventionProperty.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.DeclaringEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.DeclaringEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.DeclaringEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#DeclaringEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DeclaringEntityType As IConventionEntityType Implements IConventionProperty.DeclaringEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.DeclaringEntityType : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.DeclaringEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.DeclaringEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt; IConventionProperty.GetContainingForeignKeys ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#GetContainingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingForeignKeys () As IEnumerable(Of IConventionForeignKey) Implements IConventionProperty.GetContainingForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingForeignKeys " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey?&gt;? IConventionProperty.GetContainingForeignKeys ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt; IConventionProperty.GetContainingIndexes ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#GetContainingIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingIndexes () As IEnumerable(Of IConventionIndex) Implements IConventionProperty.GetContainingIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingIndexes " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionIndex?&gt;? IConventionProperty.GetContainingIndexes ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt; IConventionProperty.GetContainingKeys ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#GetContainingKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingKeys () As IEnumerable(Of IConventionKey) Implements IConventionProperty.GetContainingKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingKeys " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionKey?&gt;? IConventionProperty.GetContainingKeys ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetContainingKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetElementType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType? IConventionProperty.GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionElementType Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#GetElementType" />
      <MemberSignature Language="VB.NET" Value="Function GetElementType () As IConventionElementType Implements IConventionProperty.GetElementType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionElementType&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionElementType" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionElementType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetAfterSaveBehavior">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? IConventionProperty.SetAfterSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? afterSaveBehavior, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetAfterSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; afterSaveBehavior, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetAfterSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetAfterSaveBehavior (afterSaveBehavior As Nullable(Of PropertySaveBehavior), fromDataAnnotation As Boolean) As Nullable(Of PropertySaveBehavior) Implements IConventionProperty.SetAfterSaveBehavior" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetAfterSaveBehavior (afterSaveBehavior, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetAfterSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="afterSaveBehavior" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="afterSaveBehavior">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetBeforeSaveBehavior">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? IConventionProperty.SetBeforeSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? beforeSaveBehavior, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetBeforeSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; beforeSaveBehavior, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetBeforeSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetBeforeSaveBehavior (beforeSaveBehavior As Nullable(Of PropertySaveBehavior), fromDataAnnotation As Boolean) As Nullable(Of PropertySaveBehavior) Implements IConventionProperty.SetBeforeSaveBehavior" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetBeforeSaveBehavior (beforeSaveBehavior, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetBeforeSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beforeSaveBehavior" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="beforeSaveBehavior">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetElementType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType? IConventionProperty.SetElementType (Type? elementType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionElementType Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetElementType(class System.Type elementType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetElementType(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetElementType (elementType As Type, fromDataAnnotation As Boolean) As IConventionElementType Implements IConventionProperty.SetElementType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetElementType : Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionElementType&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetElementType : Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionElementType" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetElementType (elementType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetElementType(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionElementType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="elementType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken">
      <MemberSignature Language="C#" Value="void IConventionProperty.SetIsConcurrencyToken (bool? concurrencyToken, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken(valuetype System.Nullable`1&lt;bool&gt; concurrencyToken, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetIsConcurrencyToken(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub SetIsConcurrencyToken (concurrencyToken As Nullable(Of Boolean), fromDataAnnotation As Boolean) Implements IConventionProperty.SetIsConcurrencyToken" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken : Nullable&lt;bool&gt; * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken : Nullable&lt;bool&gt; * bool -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken (concurrencyToken, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="bool? IConventionProperty.SetIsConcurrencyToken (bool? concurrencyToken, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken(valuetype System.Nullable`1&lt;bool&gt; concurrencyToken, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function SetIsConcurrencyToken (concurrencyToken As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Nullable(Of Boolean) Implements IConventionProperty.SetIsConcurrencyToken" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken (concurrencyToken, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsConcurrencyToken(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="concurrencyToken" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="concurrencyToken">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable">
      <MemberSignature Language="C#" Value="void IConventionProperty.SetIsNullable (bool? nullable, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable(valuetype System.Nullable`1&lt;bool&gt; nullable, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetIsNullable(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub SetIsNullable (nullable As Nullable(Of Boolean), fromDataAnnotation As Boolean) Implements IConventionProperty.SetIsNullable" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable : Nullable&lt;bool&gt; * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable : Nullable&lt;bool&gt; * bool -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable (nullable, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="bool? IConventionProperty.SetIsNullable (bool? nullable, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable(valuetype System.Nullable`1&lt;bool&gt; nullable, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function SetIsNullable (nullable As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Nullable(Of Boolean) Implements IConventionProperty.SetIsNullable" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable (nullable, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsNullable(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullable" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="nullable">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsUnicode">
      <MemberSignature Language="C#" Value="bool? IConventionProperty.SetIsUnicode (bool? unicode, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetIsUnicode(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetIsUnicode (unicode As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Nullable(Of Boolean) Implements IConventionProperty.SetIsUnicode" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsUnicode : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsUnicode : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsUnicode (unicode, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetIsUnicode(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetJsonValueReaderWriterType">
      <MemberSignature Language="C#" Value="Type? IConventionProperty.SetJsonValueReaderWriterType (Type? readerWriterType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetJsonValueReaderWriterType(class System.Type readerWriterType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetJsonValueReaderWriterType(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetJsonValueReaderWriterType (readerWriterType As Type, fromDataAnnotation As Boolean) As Type Implements IConventionProperty.SetJsonValueReaderWriterType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetJsonValueReaderWriterType : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetJsonValueReaderWriterType : Type * bool -&gt; Type" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetJsonValueReaderWriterType (readerWriterType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetJsonValueReaderWriterType(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerWriterType" Type="System.Type" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="readerWriterType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetMaxLength">
      <MemberSignature Language="C#" Value="int? IConventionProperty.SetMaxLength (int? maxLength, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetMaxLength(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetMaxLength (maxLength As Nullable(Of Integer), fromDataAnnotation As Boolean) As Nullable(Of Integer) Implements IConventionProperty.SetMaxLength" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetMaxLength : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetMaxLength : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetMaxLength (maxLength, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetMaxLength(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetPrecision">
      <MemberSignature Language="C#" Value="int? IConventionProperty.SetPrecision (int? precision, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetPrecision(valuetype System.Nullable`1&lt;int32&gt; precision, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetPrecision(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetPrecision (precision As Nullable(Of Integer), fromDataAnnotation As Boolean) As Nullable(Of Integer) Implements IConventionProperty.SetPrecision" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetPrecision : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetPrecision : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetPrecision (precision, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetPrecision(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderClrType">
      <MemberSignature Language="C#" Value="Type? IConventionProperty.SetProviderClrType (Type? providerClrType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderClrType(class System.Type providerClrType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetProviderClrType(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetProviderClrType (providerClrType As Type, fromDataAnnotation As Boolean) As Type Implements IConventionProperty.SetProviderClrType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderClrType : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderClrType : Type * bool -&gt; Type" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderClrType (providerClrType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderClrType(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? IConventionProperty.SetProviderValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetProviderValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetProviderValueComparer (comparer As ValueComparer, fromDataAnnotation As Boolean) As ValueComparer Implements IConventionProperty.SetProviderValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer (comparer, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer">
      <MemberSignature Language="C#" Value="Type? IConventionProperty.SetProviderValueComparer (Type? comparerType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer(class System.Type comparerType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetProviderValueComparer(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetProviderValueComparer (comparerType As Type, fromDataAnnotation As Boolean) As Type Implements IConventionProperty.SetProviderValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer : Type * bool -&gt; Type" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer (comparerType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetProviderValueComparer(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-7.0">
            <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetScale">
      <MemberSignature Language="C#" Value="int? IConventionProperty.SetScale (int? scale, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetScale(valuetype System.Nullable`1&lt;int32&gt; scale, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetScale(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetScale (scale As Nullable(Of Integer), fromDataAnnotation As Boolean) As Nullable(Of Integer) Implements IConventionProperty.SetScale" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetScale : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetScale : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetScale (scale, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetScale(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetSentinel">
      <MemberSignature Language="C#" Value="object? IConventionProperty.SetSentinel (object? sentinel, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetSentinel(object sentinel, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetSentinel(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetSentinel (sentinel As Object, fromDataAnnotation As Boolean) As Object Implements IConventionProperty.SetSentinel" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetSentinel : obj * bool -&gt; obj&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetSentinel : obj * bool -&gt; obj" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetSentinel (sentinel, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetSentinel(System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sentinel" Type="System.Object" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="sentinel">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetTypeMapping">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? IConventionProperty.SetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetTypeMapping (typeMapping As CoreTypeMapping, fromDataAnnotation As Boolean) As CoreTypeMapping Implements IConventionProperty.SetTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * bool -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * bool -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetTypeMapping (typeMapping, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? IConventionProperty.SetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping, bool fromDataAnnotation);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? IConventionProperty.SetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueComparer (comparer As ValueComparer, fromDataAnnotation As Boolean) As ValueComparer Implements IConventionProperty.SetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer (comparer, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer">
      <MemberSignature Language="C#" Value="Type? IConventionProperty.SetValueComparer (Type? comparerType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer(class System.Type comparerType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetValueComparer(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueComparer (comparerType As Type, fromDataAnnotation As Boolean) As Type Implements IConventionProperty.SetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer : Type * bool -&gt; Type" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer (comparerType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueComparer(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? IConventionProperty.SetValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueConverter (converter As ValueConverter, fromDataAnnotation As Boolean) As ValueConverter Implements IConventionProperty.SetValueConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * bool -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * bool -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter (converter, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter">
      <MemberSignature Language="C#" Value="Type? IConventionProperty.SetValueConverter (Type? converterType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter(class System.Type converterType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetValueConverter(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueConverter (converterType As Type, fromDataAnnotation As Boolean) As Type Implements IConventionProperty.SetValueConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter : Type * bool -&gt; Type" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter (converterType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueConverter(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated">
      <MemberSignature Language="C#" Value="void IConventionProperty.SetValueGenerated (Microsoft.EntityFrameworkCore.Metadata.ValueGenerated? valueGenerated, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; valueGenerated, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetValueGenerated(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ValueGenerated},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueGenerated (valueGenerated As Nullable(Of ValueGenerated), fromDataAnnotation As Boolean) Implements IConventionProperty.SetValueGenerated" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * bool -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated (valueGenerated, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ValueGenerated? IConventionProperty.SetValueGenerated (Microsoft.EntityFrameworkCore.Metadata.ValueGenerated? valueGenerated, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; valueGenerated, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function SetValueGenerated (valueGenerated As Nullable(Of ValueGenerated), fromDataAnnotation As Boolean) As Nullable(Of ValueGenerated) Implements IConventionProperty.SetValueGenerated" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated (valueGenerated, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGenerated(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ValueGenerated},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGenerated" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="valueGenerated">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? IConventionProperty.SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? valueGeneratorFactory, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory(class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; valueGeneratorFactory, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueGeneratorFactory (valueGeneratorFactory As Func(Of IProperty, IEntityType, ValueGenerator), fromDataAnnotation As Boolean) As Func(Of IProperty, IEntityType, ValueGenerator) Implements IConventionProperty.SetValueGeneratorFactory" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * bool -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * bool -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory (valueGeneratorFactory, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty?,Microsoft.EntityFrameworkCore.Metadata.IEntityType?,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator?&gt;? IConventionProperty.SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty?,Microsoft.EntityFrameworkCore.Metadata.IEntityType?,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator?&gt;? valueGeneratorFactory, bool fromDataAnnotation);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGeneratorFactory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="valueGeneratorFactory">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty?,Microsoft.EntityFrameworkCore.Metadata.ITypeBase?,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator?&gt;? IConventionProperty.SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty?,Microsoft.EntityFrameworkCore.Metadata.ITypeBase?,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator?&gt;? valueGeneratorFactory, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory(class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; valueGeneratorFactory, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueGeneratorFactory (valueGeneratorFactory As Func(Of IProperty, ITypeBase, ValueGenerator), fromDataAnnotation As Boolean) As Func(Of IProperty, ITypeBase, ValueGenerator) Implements IConventionProperty.SetValueGeneratorFactory" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * bool -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * bool -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory (valueGeneratorFactory, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGeneratorFactory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="valueGeneratorFactory">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="Type? IConventionProperty.SetValueGeneratorFactory (Type? valueGeneratorFactory, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory(class System.Type valueGeneratorFactory, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IConventionProperty#SetValueGeneratorFactory(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueGeneratorFactory (valueGeneratorFactory As Type, fromDataAnnotation As Boolean) As Type Implements IConventionProperty.SetValueGeneratorFactory" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory : Type * bool -&gt; Type" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory (valueGeneratorFactory, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.SetValueGeneratorFactory(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGeneratorFactory" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="valueGeneratorFactory">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.DeclaringEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.DeclaringEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.DeclaringEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#DeclaringEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DeclaringEntityType As IMutableEntityType Implements IMutableProperty.DeclaringEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.DeclaringEntityType : Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.DeclaringEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.DeclaringEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt; IMutableProperty.GetContainingForeignKeys ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#GetContainingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingForeignKeys () As IEnumerable(Of IMutableForeignKey) Implements IMutableProperty.GetContainingForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingForeignKeys " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey?&gt;? IMutableProperty.GetContainingForeignKeys ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt; IMutableProperty.GetContainingIndexes ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#GetContainingIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingIndexes () As IEnumerable(Of IMutableIndex) Implements IMutableProperty.GetContainingIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingIndexes " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableIndex?&gt;? IMutableProperty.GetContainingIndexes ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt; IMutableProperty.GetContainingKeys ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#GetContainingKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingKeys () As IEnumerable(Of IMutableKey) Implements IMutableProperty.GetContainingKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingKeys " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableKey?&gt;? IMutableProperty.GetContainingKeys ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetContainingKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetElementType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType? IMutableProperty.GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableElementType Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#GetElementType" />
      <MemberSignature Language="VB.NET" Value="Function GetElementType () As IMutableElementType Implements IMutableProperty.GetElementType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableElementType&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableElementType" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableElementType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetAfterSaveBehavior">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetAfterSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? afterSaveBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetAfterSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; afterSaveBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetAfterSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior})" />
      <MemberSignature Language="VB.NET" Value="Sub SetAfterSaveBehavior (afterSaveBehavior As Nullable(Of PropertySaveBehavior)) Implements IMutableProperty.SetAfterSaveBehavior" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetAfterSaveBehavior afterSaveBehavior" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetAfterSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="afterSaveBehavior" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="afterSaveBehavior">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetBeforeSaveBehavior">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetBeforeSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? beforeSaveBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetBeforeSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; beforeSaveBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetBeforeSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior})" />
      <MemberSignature Language="VB.NET" Value="Sub SetBeforeSaveBehavior (beforeSaveBehavior As Nullable(Of PropertySaveBehavior)) Implements IMutableProperty.SetBeforeSaveBehavior" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetBeforeSaveBehavior beforeSaveBehavior" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetBeforeSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beforeSaveBehavior" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="beforeSaveBehavior">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetElementType">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetElementType (Type? elementType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetElementType(class System.Type elementType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetElementType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetElementType (elementType As Type) Implements IMutableProperty.SetElementType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetElementType : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetElementType : Type -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetElementType elementType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetElementType(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="elementType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetIsUnicode">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetIsUnicode (bool? unicode);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetIsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetIsUnicode(System.Nullable{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Sub SetIsUnicode (unicode As Nullable(Of Boolean)) Implements IMutableProperty.SetIsUnicode" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetIsUnicode : Nullable&lt;bool&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetIsUnicode : Nullable&lt;bool&gt; -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetIsUnicode unicode" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetIsUnicode(System.Nullable{System.Boolean})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetJsonValueReaderWriterType">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetJsonValueReaderWriterType (Type? readerWriterType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetJsonValueReaderWriterType(class System.Type readerWriterType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetJsonValueReaderWriterType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetJsonValueReaderWriterType (readerWriterType As Type) Implements IMutableProperty.SetJsonValueReaderWriterType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetJsonValueReaderWriterType : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetJsonValueReaderWriterType : Type -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetJsonValueReaderWriterType readerWriterType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetJsonValueReaderWriterType(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerWriterType" Type="System.Type" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="readerWriterType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetMaxLength">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetMaxLength (int? maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetMaxLength(System.Nullable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Sub SetMaxLength (maxLength As Nullable(Of Integer)) Implements IMutableProperty.SetMaxLength" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetMaxLength : Nullable&lt;int&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetMaxLength : Nullable&lt;int&gt; -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetMaxLength maxLength" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetMaxLength(System.Nullable{System.Int32})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetPrecision">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetPrecision (int? precision);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetPrecision(valuetype System.Nullable`1&lt;int32&gt; precision) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetPrecision(System.Nullable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Sub SetPrecision (precision As Nullable(Of Integer)) Implements IMutableProperty.SetPrecision" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetPrecision : Nullable&lt;int&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetPrecision : Nullable&lt;int&gt; -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetPrecision precision" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetPrecision(System.Nullable{System.Int32})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderClrType">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetProviderClrType (Type? providerClrType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderClrType(class System.Type providerClrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetProviderClrType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetProviderClrType (providerClrType As Type) Implements IMutableProperty.SetProviderClrType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderClrType : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderClrType : Type -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderClrType providerClrType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderClrType(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetProviderValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetProviderValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer)" />
      <MemberSignature Language="VB.NET" Value="Sub SetProviderValueComparer (comparer As ValueComparer) Implements IMutableProperty.SetProviderValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer comparer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetProviderValueComparer (Type? comparerType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer(class System.Type comparerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetProviderValueComparer(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetProviderValueComparer (comparerType As Type) Implements IMutableProperty.SetProviderValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer : Type -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer comparerType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetProviderValueComparer(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetScale">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetScale (int? scale);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetScale(valuetype System.Nullable`1&lt;int32&gt; scale) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetScale(System.Nullable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Sub SetScale (scale As Nullable(Of Integer)) Implements IMutableProperty.SetScale" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetScale : Nullable&lt;int&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetScale : Nullable&lt;int&gt; -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetScale scale" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetScale(System.Nullable{System.Int32})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetTypeMapping">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping)" />
      <MemberSignature Language="VB.NET" Value="Sub SetTypeMapping (typeMapping As CoreTypeMapping) Implements IMutableProperty.SetTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetTypeMapping typeMapping" />
      <MemberSignature Language="C#" Value="void IMutableProperty.SetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueComparer (comparer As ValueComparer) Implements IMutableProperty.SetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer comparer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetValueComparer (Type? comparerType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer(class System.Type comparerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetValueComparer(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueComparer (comparerType As Type) Implements IMutableProperty.SetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer : Type -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer comparerType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueComparer(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueConverter (converter As ValueConverter) Implements IMutableProperty.SetValueConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter converter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetValueConverter (Type? converterType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter(class System.Type converterType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetValueConverter(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueConverter (converterType As Type) Implements IMutableProperty.SetValueConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter : Type -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter converterType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueConverter(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? valueGeneratorFactory);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory(class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; valueGeneratorFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator})" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueGeneratorFactory (valueGeneratorFactory As Func(Of IProperty, IEntityType, ValueGenerator)) Implements IMutableProperty.SetValueGeneratorFactory" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory valueGeneratorFactory" />
      <MemberSignature Language="C#" Value="void IMutableProperty.SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty?,Microsoft.EntityFrameworkCore.Metadata.IEntityType?,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator?&gt;? valueGeneratorFactory);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGeneratorFactory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="valueGeneratorFactory">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty?,Microsoft.EntityFrameworkCore.Metadata.ITypeBase?,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator?&gt;? valueGeneratorFactory);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory(class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; valueGeneratorFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator})" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueGeneratorFactory (valueGeneratorFactory As Func(Of IProperty, ITypeBase, ValueGenerator)) Implements IMutableProperty.SetValueGeneratorFactory" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory valueGeneratorFactory" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGeneratorFactory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="valueGeneratorFactory">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="void IMutableProperty.SetValueGeneratorFactory (Type? valueGeneratorFactory);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory(class System.Type valueGeneratorFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutableProperty#SetValueGeneratorFactory(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueGeneratorFactory (valueGeneratorFactory As Type) Implements IMutableProperty.SetValueGeneratorFactory" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory : Type -&gt; unit" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory valueGeneratorFactory" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.SetValueGeneratorFactory(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGeneratorFactory" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="valueGeneratorFactory">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase.DeclaringType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase.DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase.DeclaringType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IMutablePropertyBase#DeclaringType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DeclaringType As IMutableTypeBase Implements IMutablePropertyBase.DeclaringType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase.DeclaringType : Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IProperty.DeclaringEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.IProperty.DeclaringEntityType { get; }" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.IProperty.DeclaringEntityType" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IProperty#DeclaringEntityType" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DeclaringEntityType As IEntityType Implements IProperty.DeclaringEntityType" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IProperty.DeclaringEntityType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IProperty.DeclaringEntityType" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">P:Microsoft.EntityFrameworkCore.Metadata.IProperty.DeclaringEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; IProperty.GetContainingForeignKeys ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IProperty#GetContainingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingForeignKeys () As IEnumerable(Of IForeignKey) Implements IProperty.GetContainingForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingForeignKeys " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey?&gt;? IProperty.GetContainingForeignKeys ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; IProperty.GetContainingIndexes ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IProperty#GetContainingIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingIndexes () As IEnumerable(Of IIndex) Implements IProperty.GetContainingIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingIndexes " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex?&gt;? IProperty.GetContainingIndexes ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt; IProperty.GetContainingKeys ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IKey&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IProperty#GetContainingKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingKeys () As IEnumerable(Of IKey) Implements IProperty.GetContainingKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingKeys " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IKey?&gt;? IProperty.GetContainingKeys ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IProperty.GetContainingKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IProperty.GetElementType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IElementType? IProperty.GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IElementType Microsoft.EntityFrameworkCore.Metadata.IProperty.GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IProperty#GetElementType" />
      <MemberSignature Language="VB.NET" Value="Function GetElementType () As IElementType Implements IProperty.GetElementType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IProperty.GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IElementType&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IElementType" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IProperty.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IElementType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IProperty.GetKeyValueComparer">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer IProperty.GetKeyValueComparer ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer Microsoft.EntityFrameworkCore.Metadata.IProperty.GetKeyValueComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IProperty#GetKeyValueComparer" />
      <MemberSignature Language="VB.NET" Value="Function GetKeyValueComparer () As ValueComparer Implements IProperty.GetKeyValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IProperty.GetKeyValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetKeyValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetKeyValueComparer " />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? IProperty.GetKeyValueComparer ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IProperty.GetKeyValueComparer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IProperty.GetProviderValueComparer">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? IProperty.GetProviderValueComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer Microsoft.EntityFrameworkCore.Metadata.IProperty.GetProviderValueComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IProperty#GetProviderValueComparer" />
      <MemberSignature Language="VB.NET" Value="Function GetProviderValueComparer () As ValueComparer Implements IProperty.GetProviderValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IProperty.GetProviderValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetProviderValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetProviderValueComparer " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IProperty.GetProviderValueComparer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IProperty.GetValueComparer">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer IProperty.GetValueComparer ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer Microsoft.EntityFrameworkCore.Metadata.IProperty.GetValueComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IProperty#GetValueComparer" />
      <MemberSignature Language="VB.NET" Value="Function GetValueComparer () As ValueComparer Implements IProperty.GetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IProperty.GetValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IProperty.GetValueComparer " />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? IProperty.GetValueComparer ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IProperty.GetValueComparer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase.DeclaringType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ITypeBase Microsoft.EntityFrameworkCore.Metadata.IPropertyBase.DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.ITypeBase Microsoft.EntityFrameworkCore.Metadata.IPropertyBase.DeclaringType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IPropertyBase#DeclaringType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DeclaringType As ITypeBase Implements IPropertyBase.DeclaringType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IPropertyBase.DeclaringType : Microsoft.EntityFrameworkCore.Metadata.ITypeBase" Usage="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IPropertyBase.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ITypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.DeclaringEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.DeclaringEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.DeclaringEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyProperty#DeclaringEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DeclaringEntityType As IReadOnlyEntityType Implements IReadOnlyProperty.DeclaringEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.DeclaringEntityType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.DeclaringEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.DeclaringEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindContainingPrimaryKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey? IReadOnlyProperty.FindContainingPrimaryKey ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindContainingPrimaryKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyProperty#FindContainingPrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Function FindContainingPrimaryKey () As IReadOnlyKey Implements IReadOnlyProperty.FindContainingPrimaryKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindContainingPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindContainingPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindContainingPrimaryKey " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindContainingPrimaryKey</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindTypeMapping">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? IReadOnlyProperty.FindTypeMapping ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindTypeMapping() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyProperty#FindTypeMapping" />
      <MemberSignature Language="VB.NET" Value="Function FindTypeMapping () As CoreTypeMapping Implements IReadOnlyProperty.FindTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindTypeMapping : unit -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindTypeMapping : unit -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindTypeMapping " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.FindTypeMapping</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; IReadOnlyProperty.GetContainingForeignKeys ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyProperty#GetContainingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingForeignKeys () As IEnumerable(Of IReadOnlyForeignKey) Implements IReadOnlyProperty.GetContainingForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingForeignKeys " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey?&gt;? IReadOnlyProperty.GetContainingForeignKeys ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; IReadOnlyProperty.GetContainingIndexes ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyProperty#GetContainingIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingIndexes () As IEnumerable(Of IReadOnlyIndex) Implements IReadOnlyProperty.GetContainingIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingIndexes " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex?&gt;? IReadOnlyProperty.GetContainingIndexes ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; IReadOnlyProperty.GetContainingKeys ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyProperty#GetContainingKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetContainingKeys () As IEnumerable(Of IReadOnlyKey) Implements IReadOnlyProperty.GetContainingKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingKeys " />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey?&gt;? IReadOnlyProperty.GetContainingKeys ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetContainingKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetElementType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType? IReadOnlyProperty.GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyProperty#GetElementType" />
      <MemberSignature Language="VB.NET" Value="Function GetElementType () As IReadOnlyElementType Implements IReadOnlyProperty.GetElementType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetElementType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType" Usage="property.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyProperty#GetElementType</InterfaceMember>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionProperty.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyProperty#GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAnnotationSet">
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Infrastructure.Annotation OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Infrastructure.Annotation annotation, Microsoft.EntityFrameworkCore.Infrastructure.Annotation oldAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.EntityFrameworkCore.Infrastructure.Annotation OnAnnotationSet(string name, class Microsoft.EntityFrameworkCore.Infrastructure.Annotation annotation, class Microsoft.EntityFrameworkCore.Infrastructure.Annotation oldAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.OnAnnotationSet(System.String,Microsoft.EntityFrameworkCore.Infrastructure.Annotation,Microsoft.EntityFrameworkCore.Infrastructure.Annotation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnAnnotationSet (name As String, annotation As Annotation, oldAnnotation As Annotation) As Annotation" />
      <MemberSignature Language="F#" Value="override this.OnAnnotationSet : string * Microsoft.EntityFrameworkCore.Infrastructure.Annotation * Microsoft.EntityFrameworkCore.Infrastructure.Annotation -&gt; Microsoft.EntityFrameworkCore.Infrastructure.Annotation" Usage="property.OnAnnotationSet (name, annotation, oldAnnotation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Infrastructure.Annotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="annotation" Type="Microsoft.EntityFrameworkCore.Infrastructure.Annotation" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="oldAnnotation" Type="Microsoft.EntityFrameworkCore.Infrastructure.Annotation" Index="2" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name"> The key of the set annotation. </param>
        <param name="annotation"> The annotation set. </param>
        <param name="oldAnnotation"> The old annotation. </param>
        <summary>
                Runs the conventions when an annotation was set or removed.
            </summary>
        <returns> The annotation that was set. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAnnotationSet">
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation annotation, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation oldAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation OnAnnotationSet(string name, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation annotation, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation oldAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.OnAnnotationSet(System.String,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnAnnotationSet (name As String, annotation As IConventionAnnotation, oldAnnotation As IConventionAnnotation) As IConventionAnnotation" />
      <MemberSignature Language="F#" Value="override this.OnAnnotationSet : string * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" Usage="property.OnAnnotationSet (name, annotation, oldAnnotation)" />
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? annotation, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? oldAnnotation);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="annotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="oldAnnotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">The key of the set annotation.</param>
        <param name="annotation">The annotation set.</param>
        <param name="oldAnnotation">The old annotation.</param>
        <summary>
                Runs the conventions when an annotation was set or removed.
            </summary>
        <returns>The annotation that was set.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnElementTypeSet">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.EntityFrameworkCore.Metadata.IElementType? OnElementTypeSet (Microsoft.EntityFrameworkCore.Metadata.IElementType? newElementType, Microsoft.EntityFrameworkCore.Metadata.IElementType? oldElementType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IElementType OnElementTypeSet(class Microsoft.EntityFrameworkCore.Metadata.IElementType newElementType, class Microsoft.EntityFrameworkCore.Metadata.IElementType oldElementType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.OnElementTypeSet(Microsoft.EntityFrameworkCore.Metadata.IElementType,Microsoft.EntityFrameworkCore.Metadata.IElementType)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnElementTypeSet (newElementType As IElementType, oldElementType As IElementType) As IElementType" />
      <MemberSignature Language="F#" Value="abstract member OnElementTypeSet : Microsoft.EntityFrameworkCore.Metadata.IElementType * Microsoft.EntityFrameworkCore.Metadata.IElementType -&gt; Microsoft.EntityFrameworkCore.Metadata.IElementType&#xA;override this.OnElementTypeSet : Microsoft.EntityFrameworkCore.Metadata.IElementType * Microsoft.EntityFrameworkCore.Metadata.IElementType -&gt; Microsoft.EntityFrameworkCore.Metadata.IElementType" Usage="property.OnElementTypeSet (newElementType, oldElementType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IElementType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newElementType" Type="Microsoft.EntityFrameworkCore.Metadata.IElementType" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="oldElementType" Type="Microsoft.EntityFrameworkCore.Metadata.IElementType" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="newElementType">To be added.</param>
        <param name="oldElementType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFieldInfoSet">
      <MemberSignature Language="C#" Value="protected override void OnFieldInfoSet (System.Reflection.FieldInfo oldFieldInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFieldInfoSet(class System.Reflection.FieldInfo oldFieldInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.OnFieldInfoSet(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFieldInfoSet (oldFieldInfo As FieldInfo)" />
      <MemberSignature Language="F#" Value="override this.OnFieldInfoSet : System.Reflection.FieldInfo -&gt; unit" Usage="property.OnFieldInfoSet oldFieldInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldFieldInfo" Type="System.Reflection.FieldInfo" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="oldFieldInfo">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFieldInfoSet">
      <MemberSignature Language="C#" Value="protected override void OnFieldInfoSet (System.Reflection.FieldInfo newFieldInfo, System.Reflection.FieldInfo oldFieldInfo);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFieldInfoSet(class System.Reflection.FieldInfo newFieldInfo, class System.Reflection.FieldInfo oldFieldInfo) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.OnFieldInfoSet(System.Reflection.FieldInfo,System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFieldInfoSet (newFieldInfo As FieldInfo, oldFieldInfo As FieldInfo)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="override this.OnFieldInfoSet : System.Reflection.FieldInfo * System.Reflection.FieldInfo -&gt; unit" Usage="property.OnFieldInfoSet (newFieldInfo, oldFieldInfo)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="protected override System.Reflection.FieldInfo OnFieldInfoSet (System.Reflection.FieldInfo newFieldInfo, System.Reflection.FieldInfo oldFieldInfo);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.FieldInfo OnFieldInfoSet(class System.Reflection.FieldInfo newFieldInfo, class System.Reflection.FieldInfo oldFieldInfo) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnFieldInfoSet (newFieldInfo As FieldInfo, oldFieldInfo As FieldInfo) As FieldInfo" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="override this.OnFieldInfoSet : System.Reflection.FieldInfo * System.Reflection.FieldInfo -&gt; System.Reflection.FieldInfo" Usage="property.OnFieldInfoSet (newFieldInfo, oldFieldInfo)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="protected override System.Reflection.FieldInfo? OnFieldInfoSet (System.Reflection.FieldInfo? newFieldInfo, System.Reflection.FieldInfo? oldFieldInfo);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newFieldInfo" Type="System.Reflection.FieldInfo" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="oldFieldInfo" Type="System.Reflection.FieldInfo" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="newFieldInfo">To be added.</param>
        <param name="oldFieldInfo">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyNullableChanged">
      <MemberSignature Language="C#" Value="protected virtual bool? OnPropertyNullableChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; OnPropertyNullableChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.OnPropertyNullableChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPropertyNullableChanged () As Nullable(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyNullableChanged : unit -&gt; Nullable&lt;bool&gt;&#xA;override this.OnPropertyNullableChanged : unit -&gt; Nullable&lt;bool&gt;" Usage="property.OnPropertyNullableChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IKey PrimaryKey { get; set; }" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IKey PrimaryKey" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property PrimaryKey As IKey" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : Microsoft.EntityFrameworkCore.Metadata.IKey with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.PrimaryKey" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey? PrimaryKey { get; set; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey PrimaryKey" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property PrimaryKey As IReadOnlyKey" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.PrimaryKey" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IKey</ReturnType>
        <ReturnType FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyIndexes">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyIndexes PropertyIndexes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyIndexes PropertyIndexes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.PropertyIndexes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property PropertyIndexes As PropertyIndexes" />
      <MemberSignature Language="F#" Value="member this.PropertyIndexes : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyIndexes with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.PropertyIndexes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyIndexes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyMetadataChanged">
      <MemberSignature Language="C#" Value="protected override void PropertyMetadataChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PropertyMetadataChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.PropertyMetadataChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PropertyMetadataChanged ()" />
      <MemberSignature Language="F#" Value="override this.PropertyMetadataChanged : unit -&gt; unit" Usage="property.PropertyMetadataChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiresValueGenerator">
      <MemberSignature Language="C#" Value="public virtual bool RequiresValueGenerator { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RequiresValueGenerator" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.RequiresValueGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RequiresValueGenerator As Boolean" />
      <MemberSignature Language="F#" Value="member this.RequiresValueGenerator : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.RequiresValueGenerator" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.RequiresValueGenerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sentinel">
      <MemberSignature Language="C#" Value="public virtual object? Sentinel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Sentinel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Sentinel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Sentinel As Object" />
      <MemberSignature Language="F#" Value="member this.Sentinel : obj with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.Sentinel" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.Sentinel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAfterSaveBehavior">
      <MemberSignature Language="C#" Value="public virtual void SetAfterSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? afterSaveBehavior, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetAfterSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; afterSaveBehavior, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetAfterSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetAfterSaveBehavior (afterSaveBehavior As Nullable(Of PropertySaveBehavior), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetAfterSaveBehavior (afterSaveBehavior, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? SetAfterSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? afterSaveBehavior, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; SetAfterSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; afterSaveBehavior, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetAfterSaveBehavior (afterSaveBehavior As Nullable(Of PropertySaveBehavior), configurationSource As ConfigurationSource) As Nullable(Of PropertySaveBehavior)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;&#xA;override this.SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Usage="property.SetAfterSaveBehavior (afterSaveBehavior, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="afterSaveBehavior" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="afterSaveBehavior">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAfterSaveBehavior">
      <MemberSignature Language="C#" Value="public virtual void SetAfterSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? afterSaveBehavior, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetAfterSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; afterSaveBehavior, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetAfterSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior},Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetAfterSaveBehavior (afterSaveBehavior As Nullable(Of PropertySaveBehavior), configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetAfterSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetAfterSaveBehavior (afterSaveBehavior, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="afterSaveBehavior" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="afterSaveBehavior">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBeforeSaveBehavior">
      <MemberSignature Language="C#" Value="public virtual void SetBeforeSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? beforeSaveBehavior, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetBeforeSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; beforeSaveBehavior, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetBeforeSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetBeforeSaveBehavior (beforeSaveBehavior As Nullable(Of PropertySaveBehavior), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetBeforeSaveBehavior (beforeSaveBehavior, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? SetBeforeSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? beforeSaveBehavior, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; SetBeforeSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; beforeSaveBehavior, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetBeforeSaveBehavior (beforeSaveBehavior As Nullable(Of PropertySaveBehavior), configurationSource As ConfigurationSource) As Nullable(Of PropertySaveBehavior)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;&#xA;override this.SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Usage="property.SetBeforeSaveBehavior (beforeSaveBehavior, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beforeSaveBehavior" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="beforeSaveBehavior">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBeforeSaveBehavior">
      <MemberSignature Language="C#" Value="public virtual void SetBeforeSaveBehavior (Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior? beforeSaveBehavior, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetBeforeSaveBehavior(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; beforeSaveBehavior, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetBeforeSaveBehavior(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior},Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetBeforeSaveBehavior (beforeSaveBehavior As Nullable(Of PropertySaveBehavior), configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetBeforeSaveBehavior : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetBeforeSaveBehavior (beforeSaveBehavior, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beforeSaveBehavior" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.PropertySaveBehavior&gt;" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="beforeSaveBehavior">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void SetConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void SetConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetElementType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType? SetElementType (Type? elementType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType SetElementType(class System.Type elementType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetElementType(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetElementType (elementType As Type, configurationSource As ConfigurationSource) As ElementType" />
      <MemberSignature Language="F#" Value="abstract member SetElementType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType&#xA;override this.SetElementType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType" Usage="property.SetElementType (elementType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="elementType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsConcurrencyToken">
      <MemberSignature Language="C#" Value="public virtual void SetIsConcurrencyToken (bool concurrencyToken, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsConcurrencyToken(bool concurrencyToken, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetIsConcurrencyToken(System.Boolean,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsConcurrencyToken (concurrencyToken As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetIsConcurrencyToken : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetIsConcurrencyToken : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetIsConcurrencyToken (concurrencyToken, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="concurrencyToken" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="concurrencyToken">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsConcurrencyToken">
      <MemberSignature Language="C#" Value="public virtual void SetIsConcurrencyToken (bool? concurrencyToken, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsConcurrencyToken(valuetype System.Nullable`1&lt;bool&gt; concurrencyToken, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetIsConcurrencyToken(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsConcurrencyToken (concurrencyToken As Nullable(Of Boolean), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetIsConcurrencyToken : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetIsConcurrencyToken : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetIsConcurrencyToken (concurrencyToken, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual bool? SetIsConcurrencyToken (bool? concurrencyToken, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; SetIsConcurrencyToken(valuetype System.Nullable`1&lt;bool&gt; concurrencyToken, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetIsConcurrencyToken (concurrencyToken As Nullable(Of Boolean), configurationSource As ConfigurationSource) As Nullable(Of Boolean)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetIsConcurrencyToken : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;&#xA;override this.SetIsConcurrencyToken : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;" Usage="property.SetIsConcurrencyToken (concurrencyToken, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="concurrencyToken" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="concurrencyToken">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsNullable">
      <MemberSignature Language="C#" Value="public virtual void SetIsNullable (bool nullable, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsNullable(bool nullable, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetIsNullable(System.Boolean,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsNullable (nullable As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetIsNullable : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetIsNullable : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetIsNullable (nullable, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullable" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="nullable">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsNullable">
      <MemberSignature Language="C#" Value="public virtual void SetIsNullable (bool? nullable, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsNullable(valuetype System.Nullable`1&lt;bool&gt; nullable, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetIsNullable(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsNullable (nullable As Nullable(Of Boolean), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetIsNullable : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetIsNullable : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetIsNullable (nullable, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual bool? SetIsNullable (bool? nullable, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; SetIsNullable(valuetype System.Nullable`1&lt;bool&gt; nullable, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetIsNullable (nullable As Nullable(Of Boolean), configurationSource As ConfigurationSource) As Nullable(Of Boolean)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetIsNullable : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;&#xA;override this.SetIsNullable : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;" Usage="property.SetIsNullable (nullable, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullable" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="nullable">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsNullable">
      <MemberSignature Language="C#" Value="public virtual void SetIsNullable (bool? nullable, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsNullable(valuetype System.Nullable`1&lt;bool&gt; nullable, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetIsNullable(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsNullable (nullable As Nullable(Of Boolean), configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetIsNullable : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetIsNullable : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetIsNullable (nullable, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullable" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="nullable">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsReadOnlyAfterSave">
      <MemberSignature Language="C#" Value="public virtual void SetIsReadOnlyAfterSave (bool readOnlyAfterSave, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsReadOnlyAfterSave(bool readOnlyAfterSave, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetIsReadOnlyAfterSave(System.Boolean,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsReadOnlyAfterSave (readOnlyAfterSave As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetIsReadOnlyAfterSave : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetIsReadOnlyAfterSave : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetIsReadOnlyAfterSave (readOnlyAfterSave, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readOnlyAfterSave" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="readOnlyAfterSave">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsReadOnlyBeforeSave">
      <MemberSignature Language="C#" Value="public virtual void SetIsReadOnlyBeforeSave (bool readOnlyBeforeSave, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsReadOnlyBeforeSave(bool readOnlyBeforeSave, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetIsReadOnlyBeforeSave(System.Boolean,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsReadOnlyBeforeSave (readOnlyBeforeSave As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetIsReadOnlyBeforeSave : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetIsReadOnlyBeforeSave : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetIsReadOnlyBeforeSave (readOnlyBeforeSave, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readOnlyBeforeSave" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="readOnlyBeforeSave">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsStoreGeneratedAlways">
      <MemberSignature Language="C#" Value="public virtual void SetIsStoreGeneratedAlways (bool storeGeneratedAlways, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsStoreGeneratedAlways(bool storeGeneratedAlways, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetIsStoreGeneratedAlways(System.Boolean,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsStoreGeneratedAlways (storeGeneratedAlways As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetIsStoreGeneratedAlways : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetIsStoreGeneratedAlways : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetIsStoreGeneratedAlways (storeGeneratedAlways, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storeGeneratedAlways" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="storeGeneratedAlways">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsUnicode">
      <MemberSignature Language="C#" Value="public virtual void SetIsUnicode (bool? unicode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetIsUnicode(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsUnicode (unicode As Nullable(Of Boolean), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetIsUnicode : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetIsUnicode : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetIsUnicode (unicode, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual bool? SetIsUnicode (bool? unicode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; SetIsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetIsUnicode (unicode As Nullable(Of Boolean), configurationSource As ConfigurationSource) As Nullable(Of Boolean)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetIsUnicode : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;&#xA;override this.SetIsUnicode : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;" Usage="property.SetIsUnicode (unicode, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetJsonValueReaderWriterType">
      <MemberSignature Language="C#" Value="public virtual Type? SetJsonValueReaderWriterType (Type? readerWriterType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetJsonValueReaderWriterType(class System.Type readerWriterType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetJsonValueReaderWriterType(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetJsonValueReaderWriterType (readerWriterType As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetJsonValueReaderWriterType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetJsonValueReaderWriterType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="property.SetJsonValueReaderWriterType (readerWriterType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerWriterType" Type="System.Type" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="readerWriterType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetKeyValueComparer">
      <MemberSignature Language="C#" Value="public virtual void SetKeyValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetKeyValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetKeyValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetKeyValueComparer (comparer As ValueComparer, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetKeyValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetKeyValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetKeyValueComparer (comparer, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMaxLength">
      <MemberSignature Language="C#" Value="public virtual void SetMaxLength (int? maxLength, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetMaxLength(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMaxLength (maxLength As Nullable(Of Integer), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetMaxLength : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetMaxLength : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetMaxLength (maxLength, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual int? SetMaxLength (int? maxLength, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; SetMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetMaxLength (maxLength As Nullable(Of Integer), configurationSource As ConfigurationSource) As Nullable(Of Integer)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetMaxLength : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;&#xA;override this.SetMaxLength : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;" Usage="property.SetMaxLength (maxLength, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrecision">
      <MemberSignature Language="C#" Value="public virtual int? SetPrecision (int? precision, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; SetPrecision(valuetype System.Nullable`1&lt;int32&gt; precision, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetPrecision(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetPrecision (precision As Nullable(Of Integer), configurationSource As ConfigurationSource) As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SetPrecision : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;&#xA;override this.SetPrecision : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;" Usage="property.SetPrecision (precision, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProviderClrType">
      <MemberSignature Language="C#" Value="public virtual void SetProviderClrType (Type providerClrType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetProviderClrType(class System.Type providerClrType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetProviderClrType(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetProviderClrType (providerClrType As Type, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetProviderClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetProviderClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetProviderClrType (providerClrType, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Type SetProviderClrType (Type providerClrType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetProviderClrType(class System.Type providerClrType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetProviderClrType (providerClrType As Type, configurationSource As ConfigurationSource) As Type" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetProviderClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetProviderClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="property.SetProviderClrType (providerClrType, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public virtual Type? SetProviderClrType (Type? providerClrType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProviderValueComparer">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? SetProviderValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer SetProviderValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetProviderValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetProviderValueComparer (comparer As ValueComparer, configurationSource As ConfigurationSource) As ValueComparer" />
      <MemberSignature Language="F#" Value="abstract member SetProviderValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.SetProviderValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.SetProviderValueComparer (comparer, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProviderValueComparer">
      <MemberSignature Language="C#" Value="public virtual Type? SetProviderValueComparer (Type? comparerType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetProviderValueComparer(class System.Type comparerType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetProviderValueComparer(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetProviderValueComparer (comparerType As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetProviderValueComparer : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetProviderValueComparer : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="property.SetProviderValueComparer (comparerType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="efcore-7.0">
            <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRemovedFromModel">
      <MemberSignature Language="C#" Value="public virtual void SetRemovedFromModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRemovedFromModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetRemovedFromModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRemovedFromModel ()" />
      <MemberSignature Language="F#" Value="abstract member SetRemovedFromModel : unit -&gt; unit&#xA;override this.SetRemovedFromModel : unit -&gt; unit" Usage="property.SetRemovedFromModel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRequiresValueGenerator">
      <MemberSignature Language="C#" Value="public virtual void SetRequiresValueGenerator (bool requiresValueGenerator, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRequiresValueGenerator(bool requiresValueGenerator, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetRequiresValueGenerator(System.Boolean,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRequiresValueGenerator (requiresValueGenerator As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetRequiresValueGenerator : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetRequiresValueGenerator : bool * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetRequiresValueGenerator (requiresValueGenerator, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requiresValueGenerator" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="requiresValueGenerator">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetScale">
      <MemberSignature Language="C#" Value="public virtual int? SetScale (int? scale, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; SetScale(valuetype System.Nullable`1&lt;int32&gt; scale, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetScale(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetScale (scale As Nullable(Of Integer), configurationSource As ConfigurationSource) As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SetScale : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;&#xA;override this.SetScale : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;" Usage="property.SetScale (scale, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSentinel">
      <MemberSignature Language="C#" Value="public virtual object? SetSentinel (object? sentinel, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object SetSentinel(object sentinel, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetSentinel(System.Object,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetSentinel (sentinel As Object, configurationSource As ConfigurationSource) As Object" />
      <MemberSignature Language="F#" Value="abstract member SetSentinel : obj * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; obj&#xA;override this.SetSentinel : obj * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; obj" Usage="property.SetSentinel (sentinel, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sentinel" Type="System.Object" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="sentinel">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStructuralValueComparer">
      <MemberSignature Language="C#" Value="public virtual void SetStructuralValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStructuralValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetStructuralValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetStructuralValueComparer (comparer As ValueComparer, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetStructuralValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetStructuralValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetStructuralValueComparer (comparer, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTypeMapping">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping SetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping SetTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetTypeMapping (typeMapping As CoreTypeMapping, configurationSource As ConfigurationSource) As CoreTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping&#xA;override this.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" Usage="property.SetTypeMapping (typeMapping, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? SetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueComparer">
      <MemberSignature Language="C#" Value="public virtual void SetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValueComparer (comparer As ValueComparer, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetValueComparer (comparer, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer SetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer SetValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueComparer (comparer As ValueComparer, configurationSource As ConfigurationSource) As ValueComparer" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="property.SetValueComparer (comparer, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? SetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueComparer">
      <MemberSignature Language="C#" Value="public virtual Type? SetValueComparer (Type? comparerType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetValueComparer(class System.Type comparerType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetValueComparer(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueComparer (comparerType As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetValueComparer : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetValueComparer : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="property.SetValueComparer (comparerType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueConverter">
      <MemberSignature Language="C#" Value="public virtual void SetValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValueConverter(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValueConverter (converter As ValueConverter, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetValueConverter (converter, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter SetValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter SetValueConverter(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueConverter (converter As ValueConverter, configurationSource As ConfigurationSource) As ValueConverter" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter&#xA;override this.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Usage="property.SetValueConverter (converter, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? SetValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueConverter">
      <MemberSignature Language="C#" Value="public virtual Type? SetValueConverter (Type? converterType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetValueConverter(class System.Type converterType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetValueConverter(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueConverter (converterType As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetValueConverter : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetValueConverter : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="property.SetValueConverter (converterType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueGenerated">
      <MemberSignature Language="C#" Value="public virtual void SetValueGenerated (Microsoft.EntityFrameworkCore.Metadata.ValueGenerated? valueGenerated, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValueGenerated(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; valueGenerated, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetValueGenerated(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ValueGenerated},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValueGenerated (valueGenerated As Nullable(Of ValueGenerated), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetValueGenerated (valueGenerated, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ValueGenerated? SetValueGenerated (Microsoft.EntityFrameworkCore.Metadata.ValueGenerated? valueGenerated, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; SetValueGenerated(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; valueGenerated, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueGenerated (valueGenerated As Nullable(Of ValueGenerated), configurationSource As ConfigurationSource) As Nullable(Of ValueGenerated)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt;&#xA;override this.SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt;" Usage="property.SetValueGenerated (valueGenerated, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGenerated" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="valueGenerated">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueGenerated">
      <MemberSignature Language="C#" Value="public virtual void SetValueGenerated (Microsoft.EntityFrameworkCore.Metadata.ValueGenerated? valueGenerated, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValueGenerated(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; valueGenerated, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetValueGenerated(System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ValueGenerated},Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValueGenerated (valueGenerated As Nullable(Of ValueGenerated), configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.SetValueGenerated : Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.SetValueGenerated (valueGenerated, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGenerated" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ValueGenerated&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="valueGenerated">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="public virtual void SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; factory, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValueGeneratorFactory(class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; factory, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValueGeneratorFactory (factory As Func(Of IProperty, IEntityType, ValueGenerator), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.SetValueGeneratorFactory (factory, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; factory, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; SetValueGeneratorFactory(class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; factory, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueGeneratorFactory (factory As Func(Of IProperty, IEntityType, ValueGenerator), configurationSource As ConfigurationSource) As Func(Of IProperty, IEntityType, ValueGenerator)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="abstract member SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;&#xA;override this.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Usage="property.SetValueGeneratorFactory (factory, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? factory, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="factory">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? SetValueGeneratorFactory (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;? factory, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; SetValueGeneratorFactory(class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; factory, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetValueGeneratorFactory(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueGeneratorFactory (factory As Func(Of IProperty, ITypeBase, ValueGenerator), configurationSource As ConfigurationSource) As Func(Of IProperty, ITypeBase, ValueGenerator)" />
      <MemberSignature Language="F#" Value="abstract member SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;&#xA;override this.SetValueGeneratorFactory : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.ITypeBase, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Usage="property.SetValueGeneratorFactory (factory, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ITypeBase,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="factory">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueGeneratorFactory">
      <MemberSignature Language="C#" Value="public virtual Type? SetValueGeneratorFactory (Type? factoryType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetValueGeneratorFactory(class System.Type factoryType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.SetValueGeneratorFactory(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueGeneratorFactory (factoryType As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetValueGeneratorFactory : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetValueGeneratorFactory : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="property.SetValueGeneratorFactory (factoryType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factoryType" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="factoryType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="property.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeMapping">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping TypeMapping { get; set; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping TypeMapping" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.TypeMapping" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property TypeMapping As CoreTypeMapping" />
      <MemberSignature Language="F#" Value="member this.TypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.TypeMapping" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? TypeMapping { get; set; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual bool UpdateConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool UpdateConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.UpdateConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateConfigurationSource (configurationSource As ConfigurationSource) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool&#xA;override this.UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool" Usage="property.UpdateConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.UpdateConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.UpdateConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateTypeConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateTypeConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.UpdateTypeConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateTypeConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateTypeConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.UpdateTypeConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="property.UpdateTypeConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateTypeConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateTypeConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.UpdateTypeConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateTypeConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateTypeConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.UpdateTypeConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="property.UpdateTypeConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueGenerated">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ValueGenerated ValueGenerated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.Metadata.ValueGenerated ValueGenerated" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Property.ValueGenerated" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValueGenerated As ValueGenerated" />
      <MemberSignature Language="F#" Value="member this.ValueGenerated : Microsoft.EntityFrameworkCore.Metadata.ValueGenerated with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Property.ValueGenerated" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableProperty.ValueGenerated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ValueGenerated</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
