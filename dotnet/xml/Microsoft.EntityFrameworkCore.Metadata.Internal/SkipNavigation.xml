<Type Name="SkipNavigation" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation">
  <TypeSignature Language="C#" Value="public class SkipNavigation : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase, Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation, Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SkipNavigation extends Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionNavigationBase, class Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableNavigationBase, class Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation, class Microsoft.EntityFrameworkCore.Metadata.INavigationBase, class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" />
  <TypeSignature Language="VB.NET" Value="Public Class SkipNavigation&#xA;Inherits PropertyBase&#xA;Implements IConventionSkipNavigation, IMutableSkipNavigation" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="F#" Value="type SkipNavigation = class&#xA;    inherit PropertyBase&#xA;    interface IMutableSkipNavigation&#xA;    interface ISkipNavigation&#xA;    interface INavigationBase&#xA;    interface IPropertyBase&#xA;    interface IAnnotatable&#xA;    interface IMutableNavigationBase&#xA;    interface IMutablePropertyBase&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionSkipNavigation&#xA;    interface IConventionNavigationBase&#xA;    interface IConventionPropertyBase&#xA;    interface IConventionAnnotatable" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="C#" Value="public class SkipNavigation : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase, Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation, Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation, Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeSkipNavigation" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SkipNavigation extends Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionNavigationBase, class Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableNavigationBase, class Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation, class Microsoft.EntityFrameworkCore.Metadata.INavigationBase, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeSkipNavigation, class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation, class Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="VB.NET" Value="Public Class SkipNavigation&#xA;Inherits PropertyBase&#xA;Implements IConventionSkipNavigation, IMutableSkipNavigation, IRuntimeSkipNavigation" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="F#" Value="type SkipNavigation = class&#xA;    inherit PropertyBase&#xA;    interface IMutableSkipNavigation&#xA;    interface IReadOnlySkipNavigation&#xA;    interface IReadOnlyNavigationBase&#xA;    interface IReadOnlyPropertyBase&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IMutableNavigationBase&#xA;    interface IMutablePropertyBase&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionSkipNavigation&#xA;    interface IConventionNavigationBase&#xA;    interface IConventionPropertyBase&#xA;    interface IConventionAnnotatable&#xA;    interface IRuntimeSkipNavigation&#xA;    interface ISkipNavigation&#xA;    interface INavigationBase&#xA;    interface IPropertyBase&#xA;    interface IAnnotatable" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionNavigationBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableNavigationBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.INavigationBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IPropertyBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeSkipNavigation</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SkipNavigation (string name, System.Reflection.PropertyInfo propertyInfo, System.Reflection.FieldInfo fieldInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.#ctor(System.String,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,System.Boolean,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, propertyInfo As PropertyInfo, fieldInfo As FieldInfo, declaringEntityType As EntityType, targetEntityType As EntityType, collection As Boolean, onDependent As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation : string * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * bool * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation (name, propertyInfo, fieldInfo, declaringEntityType, targetEntityType, collection, onDependent, configurationSource)" />
      <MemberSignature Language="C#" Value="public SkipNavigation (string name, System.Reflection.PropertyInfo? propertyInfo, System.Reflection.FieldInfo? fieldInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="declaringEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="3" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="targetEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="4" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="onDependent" Type="System.Boolean" Index="6" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="7" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyInfo">To be added.</param>
        <param name="fieldInfo">To be added.</param>
        <param name="declaringEntityType">To be added.</param>
        <param name="targetEntityType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="onDependent">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SkipNavigation (string name, Type? navigationType, System.Reflection.PropertyInfo? propertyInfo, System.Reflection.FieldInfo? fieldInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type navigationType, class System.Reflection.PropertyInfo propertyInfo, class System.Reflection.FieldInfo fieldInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.#ctor(System.String,System.Type,System.Reflection.PropertyInfo,System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,System.Boolean,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, navigationType As Type, propertyInfo As PropertyInfo, fieldInfo As FieldInfo, declaringEntityType As EntityType, targetEntityType As EntityType, collection As Boolean, onDependent As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation : string * Type * System.Reflection.PropertyInfo * System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * bool * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation (name, navigationType, propertyInfo, fieldInfo, declaringEntityType, targetEntityType, collection, onDependent, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="navigationType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="declaringEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="4" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="5" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="6" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="onDependent" Type="System.Boolean" Index="7" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="8" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="navigationType">To be added.</param>
        <param name="propertyInfo">To be added.</param>
        <param name="fieldInfo">To be added.</param>
        <param name="declaringEntityType">To be added.</param>
        <param name="targetEntityType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="onDependent">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Builder">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSkipNavigationBuilder Builder { get; set; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSkipNavigationBuilder Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Builder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Builder As InternalSkipNavigationBuilder" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSkipNavigationBuilder with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Builder" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSkipNavigationBuilder Builder { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Builder As InternalSkipNavigationBuilder" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSkipNavigationBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Builder" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSkipNavigationBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClrType">
      <MemberSignature Language="C#" Value="public override Type ClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.ClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ClrType As Type" />
      <MemberSignature Language="F#" Value="member this.ClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.ClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-5.0">P:Microsoft.EntityFrameworkCore.Metadata.IPropertyBase.ClrType</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase.ClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionAccessor">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor CollectionAccessor { get; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor CollectionAccessor" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.CollectionAccessor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CollectionAccessor As IClrCollectionAccessor" />
      <MemberSignature Language="F#" Value="member this.CollectionAccessor : Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.CollectionAccessor" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor? CollectionAccessor { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DebugView">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.DebugView" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DebugView As DebugView" />
      <MemberSignature Language="F#" Value="member this.DebugView : Microsoft.EntityFrameworkCore.Infrastructure.DebugView" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.DebugView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Infrastructure.DebugView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringEntityType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType DeclaringEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType DeclaringEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.DeclaringEntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringEntityType As EntityType" />
      <MemberSignature Language="F#" Value="member this.DeclaringEntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.DeclaringEntityType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase DeclaringType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As TypeBase" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeignKey">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey ForeignKey { get; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey ForeignKey" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.ForeignKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ForeignKey As ForeignKey" />
      <MemberSignature Language="F#" Value="member this.ForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.ForeignKey" />
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? ForeignKey { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetForeignKeyConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetForeignKeyConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetForeignKeyConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.GetForeignKeyConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForeignKeyConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetForeignKeyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetForeignKeyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="skipNavigation.GetForeignKeyConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.GetForeignKeyConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInverseConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetInverseConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetInverseConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.GetInverseConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInverseConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetInverseConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetInverseConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="skipNavigation.GetInverseConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.GetInverseConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyAccessMode">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.PropertyAccessMode GetPropertyAccessMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode GetPropertyAccessMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.GetPropertyAccessMode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPropertyAccessMode () As PropertyAccessMode" />
      <MemberSignature Language="F#" Value="override this.GetPropertyAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode" Usage="skipNavigation.GetPropertyAccessMode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase.GetPropertyAccessMode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.PropertyAccessMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Inverse">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation Inverse { get; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation Inverse" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Inverse" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Inverse As SkipNavigation" />
      <MemberSignature Language="F#" Value="member this.Inverse : Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Inverse" />
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? Inverse { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public virtual bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.IsCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-5.0">P:Microsoft.EntityFrameworkCore.Metadata.INavigationBase.IsCollection</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.IsCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInModel">
      <MemberSignature Language="C#" Value="public virtual bool IsInModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.IsInModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInModel As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsInModel : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.IsInModel" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.IsInModel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOnDependent">
      <MemberSignature Language="C#" Value="public virtual bool IsOnDependent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOnDependent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.IsOnDependent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsOnDependent As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsOnDependent : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.IsOnDependent" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-5.0">P:Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.IsOnDependent</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.IsOnDependent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="JoinEntityType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType JoinEntityType { get; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType JoinEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.JoinEntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property JoinEntityType As EntityType" />
      <MemberSignature Language="F#" Value="member this.JoinEntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.JoinEntityType" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType? JoinEntityType { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManyToManyLoader">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Internal.ICollectionLoader ManyToManyLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Internal.ICollectionLoader ManyToManyLoader" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.ManyToManyLoader" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManyToManyLoader As ICollectionLoader" />
      <MemberSignature Language="F#" Value="member this.ManyToManyLoader : Microsoft.EntityFrameworkCore.Internal.ICollectionLoader" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.ManyToManyLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Internal.ICollectionLoader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IConventionAnnotatable#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionAnnotatableBuilder Implements IConventionAnnotatable.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionSkipNavigationBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionSkipNavigationBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IConventionSkipNavigation#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionSkipNavigationBuilder Implements IConventionSkipNavigation.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionSkipNavigationBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionSkipNavigationBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey IConventionSkipNavigation.SetForeignKey (Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey foreignKey, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey foreignKey, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IConventionSkipNavigation#SetForeignKey(Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetForeignKey (foreignKey As IConventionForeignKey, fromDataAnnotation As Boolean) As IConventionForeignKey Implements IConventionSkipNavigation.SetForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetForeignKey : Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetForeignKey : Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey" Usage="skipNavigation.Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetForeignKey (foreignKey, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey? IConventionSkipNavigation.SetForeignKey (Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey? foreignKey, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetForeignKey(Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetInverse">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation IConventionSkipNavigation.SetInverse (Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation inverse, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetInverse(class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation inverse, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IConventionSkipNavigation#SetInverse(Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetInverse (inverse As IConventionSkipNavigation, fromDataAnnotation As Boolean) As IConventionSkipNavigation Implements IConventionSkipNavigation.SetInverse" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetInverse : Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetInverse : Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation" Usage="skipNavigation.Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetInverse (inverse, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation? IConventionSkipNavigation.SetInverse (Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation? inverse, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation.SetInverse(Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inverse" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inverse">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetForeignKey">
      <MemberSignature Language="C#" Value="void IMutableSkipNavigation.SetForeignKey (Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey foreignKey);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IMutableSkipNavigation#SetForeignKey(Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Sub SetForeignKey (foreignKey As IMutableForeignKey) Implements IMutableSkipNavigation.SetForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetForeignKey : Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetForeignKey : Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey -&gt; unit" Usage="skipNavigation.Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetForeignKey foreignKey" />
      <MemberSignature Language="C#" Value="void IMutableSkipNavigation.SetForeignKey (Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey? foreignKey);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetForeignKey(Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetInverse">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation IMutableSkipNavigation.SetInverse (Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation inverse);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetInverse(class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation inverse) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IMutableSkipNavigation#SetInverse(Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation)" />
      <MemberSignature Language="VB.NET" Value="Function SetInverse (inverse As IMutableSkipNavigation) As IMutableSkipNavigation Implements IMutableSkipNavigation.SetInverse" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetInverse : Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetInverse : Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation" Usage="skipNavigation.Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetInverse inverse" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation? IMutableSkipNavigation.SetInverse (Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation? inverse);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation.SetInverse(Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inverse" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation" />
      </Parameters>
      <Docs>
        <param name="inverse">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.INavigationBase.DeclaringEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.INavigationBase.DeclaringEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.INavigationBase.DeclaringEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#INavigationBase#DeclaringEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DeclaringEntityType As IEntityType Implements INavigationBase.DeclaringEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.INavigationBase.DeclaringEntityType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.INavigationBase.DeclaringEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.INavigationBase.DeclaringEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.INavigationBase.GetCollectionAccessor">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor? INavigationBase.GetCollectionAccessor ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor Microsoft.EntityFrameworkCore.Metadata.INavigationBase.GetCollectionAccessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#INavigationBase#GetCollectionAccessor" />
      <MemberSignature Language="VB.NET" Value="Function GetCollectionAccessor () As IClrCollectionAccessor Implements INavigationBase.GetCollectionAccessor" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.INavigationBase.GetCollectionAccessor : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.INavigationBase.GetCollectionAccessor : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor" Usage="skipNavigation.Microsoft.EntityFrameworkCore.Metadata.INavigationBase.GetCollectionAccessor " />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor INavigationBase.GetCollectionAccessor ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.INavigationBase.GetCollectionAccessor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IClrCollectionAccessor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.INavigationBase.TargetEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.INavigationBase.TargetEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.INavigationBase.TargetEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#INavigationBase#TargetEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property TargetEntityType As IEntityType Implements INavigationBase.TargetEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.INavigationBase.TargetEntityType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.INavigationBase.TargetEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.INavigationBase.TargetEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeSkipNavigation.GetManyToManyLoader">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Internal.ICollectionLoader IRuntimeSkipNavigation.GetManyToManyLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Internal.ICollectionLoader Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeSkipNavigation.GetManyToManyLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#Internal#IRuntimeSkipNavigation#GetManyToManyLoader" />
      <MemberSignature Language="VB.NET" Value="Function GetManyToManyLoader () As ICollectionLoader Implements IRuntimeSkipNavigation.GetManyToManyLoader" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeSkipNavigation.GetManyToManyLoader : unit -&gt; Microsoft.EntityFrameworkCore.Internal.ICollectionLoader&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeSkipNavigation.GetManyToManyLoader : unit -&gt; Microsoft.EntityFrameworkCore.Internal.ICollectionLoader" Usage="skipNavigation.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeSkipNavigation.GetManyToManyLoader " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeSkipNavigation.GetManyToManyLoader</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Internal.ICollectionLoader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.DeclaringEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.DeclaringEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.DeclaringEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyNavigationBase#DeclaringEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DeclaringEntityType As IReadOnlyEntityType Implements IReadOnlyNavigationBase.DeclaringEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.DeclaringEntityType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.DeclaringEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.DeclaringEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.TargetEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.TargetEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.TargetEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyNavigationBase#TargetEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property TargetEntityType As IReadOnlyEntityType Implements IReadOnlyNavigationBase.TargetEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.TargetEntityType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.TargetEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigationBase.TargetEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.ForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.ForeignKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.ForeignKey" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IReadOnlySkipNavigation#ForeignKey" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ForeignKey As IReadOnlyForeignKey Implements IReadOnlySkipNavigation.ForeignKey" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.ForeignKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.ForeignKey" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.ForeignKey</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.Inverse">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.Inverse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.Inverse" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#IReadOnlySkipNavigation#Inverse" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Inverse As IReadOnlySkipNavigation Implements IReadOnlySkipNavigation.Inverse" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.Inverse : Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.Inverse" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation.Inverse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.ForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IForeignKey Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.ForeignKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IForeignKey Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.ForeignKey" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#ISkipNavigation#ForeignKey" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ForeignKey As IForeignKey Implements ISkipNavigation.ForeignKey" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.ForeignKey : Microsoft.EntityFrameworkCore.Metadata.IForeignKey" Usage="Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.ForeignKey" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.ForeignKey</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IForeignKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.Inverse">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.Inverse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.Inverse" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Microsoft#EntityFrameworkCore#Metadata#ISkipNavigation#Inverse" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Inverse As ISkipNavigation Implements ISkipNavigation.Inverse" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.Inverse : Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation" Usage="Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.Inverse" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation.Inverse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="OnAnnotationSet">
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation annotation, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation oldAnnotation);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation OnAnnotationSet(string name, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation annotation, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation oldAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.OnAnnotationSet(System.String,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnAnnotationSet (name As String, annotation As IConventionAnnotation, oldAnnotation As IConventionAnnotation) As IConventionAnnotation" />
      <MemberSignature Language="F#" Value="override this.OnAnnotationSet : string * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" Usage="skipNavigation.OnAnnotationSet (name, annotation, oldAnnotation)" />
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? annotation, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? oldAnnotation);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="annotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" />
        <Parameter Name="oldAnnotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" />
      </Parameters>
      <Docs>
        <param name="name">The key of the set annotation.</param>
        <param name="annotation">The annotation set.</param>
        <param name="oldAnnotation">The old annotation.</param>
        <summary>
                Runs the conventions when an annotation was set or removed.
            </summary>
        <returns>The annotation that was set.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sentinel">
      <MemberSignature Language="C#" Value="public virtual object? Sentinel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Sentinel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Sentinel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Sentinel As Object" />
      <MemberSignature Language="F#" Value="member this.Sentinel : obj" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.Sentinel" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase.Sentinel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the sentinel value that indicates that this property is not set.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey SetForeignKey (Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey SetForeignKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.SetForeignKey(Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetForeignKey (foreignKey As ForeignKey, configurationSource As ConfigurationSource) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member SetForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.SetForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="skipNavigation.SetForeignKey (foreignKey, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? SetForeignKey (Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? foreignKey, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetInverse">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation SetInverse (Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation inverse, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation SetInverse(class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation inverse, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.SetInverse(Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetInverse (inverse As SkipNavigation, configurationSource As ConfigurationSource) As SkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member SetInverse : Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&#xA;override this.SetInverse : Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="skipNavigation.SetInverse (inverse, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? SetInverse (Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? inverse, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inverse" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="inverse">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsEagerLoaded">
      <MemberSignature Language="C#" Value="public virtual void SetIsEagerLoaded (bool? eagerLoaded, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsEagerLoaded(valuetype System.Nullable`1&lt;bool&gt; eagerLoaded, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.SetIsEagerLoaded(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsEagerLoaded (eagerLoaded As Nullable(Of Boolean), configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetIsEagerLoaded : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetIsEagerLoaded : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="skipNavigation.SetIsEagerLoaded (eagerLoaded, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eagerLoaded" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="eagerLoaded">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRemovedFromModel">
      <MemberSignature Language="C#" Value="public virtual void SetRemovedFromModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRemovedFromModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.SetRemovedFromModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRemovedFromModel ()" />
      <MemberSignature Language="F#" Value="abstract member SetRemovedFromModel : unit -&gt; unit&#xA;override this.SetRemovedFromModel : unit -&gt; unit" Usage="skipNavigation.SetRemovedFromModel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetEntityType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType TargetEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType TargetEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.TargetEntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TargetEntityType As EntityType" />
      <MemberSignature Language="F#" Value="member this.TargetEntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.TargetEntityType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="skipNavigation.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateForeignKeyConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateForeignKeyConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateForeignKeyConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.UpdateForeignKeyConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateForeignKeyConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateForeignKeyConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.UpdateForeignKeyConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="skipNavigation.UpdateForeignKeyConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateInverseConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateInverseConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateInverseConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation.UpdateInverseConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateInverseConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateInverseConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.UpdateInverseConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="skipNavigation.UpdateInverseConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
