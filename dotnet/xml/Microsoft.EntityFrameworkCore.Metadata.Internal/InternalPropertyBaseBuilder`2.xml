<Type Name="InternalPropertyBaseBuilder&lt;TBuilder,TPropertyBase&gt;" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TBuilder,TPropertyBase&gt;">
  <TypeSignature Language="C#" Value="public abstract class InternalPropertyBaseBuilder&lt;TBuilder,TPropertyBase&gt; : Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder&lt;TPropertyBase,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt; where TBuilder : class, IConventionPropertyBaseBuilder&lt;TBuilder&gt; where TPropertyBase : PropertyBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit InternalPropertyBaseBuilder`2&lt;class (class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBaseBuilder`1&lt;!TBuilder&gt;) TBuilder, (class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase) TPropertyBase&gt; extends Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder`2&lt;!TPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class InternalPropertyBaseBuilder(Of TBuilder, TPropertyBase)&#xA;Inherits AnnotatableBuilder(Of TPropertyBase, InternalModelBuilder)" />
  <TypeSignature Language="F#" Value="type InternalPropertyBaseBuilder&lt;'Builder, 'PropertyBase (requires 'Builder : null and 'Builder :&gt; IConventionPropertyBaseBuilder&lt;'Builder&gt; and 'PropertyBase :&gt; PropertyBase)&gt; = class&#xA;    inherit AnnotatableBuilder&lt;'PropertyBase, InternalModelBuilder (requires 'PropertyBase :&gt; PropertyBase)&gt;" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TBuilder">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
        <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBaseBuilder&lt;TBuilder&gt;</InterfaceName>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TPropertyBase">
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Constraints>
        <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase</BaseTypeName>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder&lt;TPropertyBase,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="TMetadata">TPropertyBase</BaseTypeArgument>
      <BaseTypeArgument TypeParamName="TModelBuilder">Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TBuilder">To be added.</typeparam>
    <typeparam name="TPropertyBase">To be added.</typeparam>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalPropertyBaseBuilder (TPropertyBase metadata, Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder modelBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!TPropertyBase metadata, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder modelBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.#ctor(`1,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (metadata As TPropertyBase, modelBuilder As InternalModelBuilder)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'Builder, 'PropertyBase (requires 'Builder : null and 'Builder :&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBaseBuilder&lt;'Builder&gt; and 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt; : 'PropertyBase * Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'Builder, 'PropertyBase (requires 'Builder : null and 'Builder :&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBaseBuilder&lt;'Builder&gt; and 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt;" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'Builder, 'PropertyBase (requires 'Builder : null and 'Builder :&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBaseBuilder&lt;'Builder&gt; and 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt; (metadata, modelBuilder)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="metadata" Type="TPropertyBase" />
        <Parameter Name="modelBuilder" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder" />
      </Parameters>
      <Docs>
        <param name="metadata">To be added.</param>
        <param name="modelBuilder">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetField">
      <MemberSignature Language="C#" Value="public virtual bool CanSetField (System.Reflection.FieldInfo? fieldInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetField(class System.Reflection.FieldInfo fieldInfo, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.CanSetField(System.Reflection.FieldInfo,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetField (fieldInfo As FieldInfo, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetField : System.Reflection.FieldInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetField : System.Reflection.FieldInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalPropertyBaseBuilder.CanSetField (fieldInfo, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="fieldInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetField">
      <MemberSignature Language="C#" Value="public virtual bool CanSetField (string? fieldName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetField(string fieldName, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.CanSetField(System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetField (fieldName As String, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetField : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetField : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalPropertyBaseBuilder.CanSetField (fieldName, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="fieldName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetPropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual bool CanSetPropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetPropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.CanSetPropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetPropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalPropertyBaseBuilder.CanSetPropertyAccessMode (propertyAccessMode, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasField">
      <MemberSignature Language="C#" Value="public virtual TBuilder? HasField (System.Reflection.FieldInfo? fieldInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !TBuilder HasField(class System.Reflection.FieldInfo fieldInfo, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.HasField(System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasField (fieldInfo As FieldInfo, configurationSource As ConfigurationSource) As TBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasField : System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; 'Builder&#xA;override this.HasField : System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; 'Builder" Usage="internalPropertyBaseBuilder.HasField (fieldInfo, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="fieldInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasField">
      <MemberSignature Language="C#" Value="public virtual TBuilder? HasField (string? fieldName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !TBuilder HasField(string fieldName, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.HasField(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasField (fieldName As String, configurationSource As ConfigurationSource) As TBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasField : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; 'Builder&#xA;override this.HasField : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; 'Builder" Usage="internalPropertyBaseBuilder.HasField (fieldName, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="fieldName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="This">
      <MemberSignature Language="C#" Value="protected abstract TBuilder This { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TBuilder This" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.This" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property This As TBuilder" />
      <MemberSignature Language="F#" Value="member this.This : 'Builder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'Builder, 'PropertyBase (requires 'Builder : null and 'Builder :&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBaseBuilder&lt;'Builder&gt; and 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt;.This" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UsePropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual TBuilder? UsePropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !TBuilder UsePropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`2.UsePropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UsePropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As ConfigurationSource) As TBuilder" />
      <MemberSignature Language="F#" Value="abstract member UsePropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; 'Builder&#xA;override this.UsePropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; 'Builder" Usage="internalPropertyBaseBuilder.UsePropertyAccessMode (propertyAccessMode, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
