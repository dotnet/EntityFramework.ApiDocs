<Type Name="ElementType" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType">
  <TypeSignature Language="C#" Value="public class ElementType : Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable, Microsoft.EntityFrameworkCore.Metadata.IConventionElementType, Microsoft.EntityFrameworkCore.Metadata.IElementType, Microsoft.EntityFrameworkCore.Metadata.IMutableElementType" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ElementType extends Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionElementType, class Microsoft.EntityFrameworkCore.Metadata.IElementType, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableElementType, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType" />
  <TypeSignature Language="VB.NET" Value="Public Class ElementType&#xA;Inherits ConventionAnnotatable&#xA;Implements IConventionElementType, IElementType, IMutableElementType" />
  <TypeSignature Language="F#" Value="type ElementType = class&#xA;    inherit ConventionAnnotatable&#xA;    interface IMutableElementType&#xA;    interface IReadOnlyElementType&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionElementType&#xA;    interface IConventionAnnotatable&#xA;    interface IElementType&#xA;    interface IAnnotatable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionElementType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IElementType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableElementType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ElementType (Type clrType, Microsoft.EntityFrameworkCore.Metadata.Internal.Property collectionProperty, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type clrType, class Microsoft.EntityFrameworkCore.Metadata.Internal.Property collectionProperty, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.#ctor(System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (clrType As Type, collectionProperty As Property, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType (clrType, collectionProperty, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clrType" Type="System.Type" />
        <Parameter Name="collectionProperty" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="clrType">To be added.</param>
        <param name="collectionProperty">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Builder">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Builder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Builder As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Builder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckValueComparer">
      <MemberSignature Language="C#" Value="public virtual string? CheckValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CheckValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.CheckValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CheckValueComparer (comparer As ValueComparer) As String" />
      <MemberSignature Language="F#" Value="abstract member CheckValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; string&#xA;override this.CheckValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; string" Usage="elementType.CheckValueComparer comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckValueConverter">
      <MemberSignature Language="C#" Value="public virtual string? CheckValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CheckValueConverter(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.CheckValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CheckValueConverter (converter As ValueConverter) As String" />
      <MemberSignature Language="F#" Value="abstract member CheckValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter -&gt; string&#xA;override this.CheckValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter -&gt; string" Usage="elementType.CheckValueConverter converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClrType">
      <MemberSignature Language="C#" Value="public virtual Type ClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.ClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClrType As Type" />
      <MemberSignature Language="F#" Value="member this.ClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.ClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.ClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property CollectionProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property CollectionProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.CollectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CollectionProperty As Property" />
      <MemberSignature Language="F#" Value="member this.CollectionProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.CollectionProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DebugView">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.DebugView" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DebugView As DebugView" />
      <MemberSignature Language="F#" Value="member this.DebugView : Microsoft.EntityFrameworkCore.Infrastructure.DebugView" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.DebugView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Infrastructure.DebugView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigurationSource () As ConfigurationSource" />
      <MemberSignature Language="F#" Value="abstract member GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&#xA;override this.GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Usage="elementType.GetConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsNullableConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetIsNullableConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetIsNullableConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetIsNullableConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsNullableConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsNullableConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetIsNullableConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetIsNullableConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetIsNullableConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsUnicodeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetIsUnicodeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetIsUnicodeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetIsUnicodeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsUnicodeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsUnicodeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetIsUnicodeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetIsUnicodeConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetIsUnicodeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetJsonValueReaderWriter">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter? GetJsonValueReaderWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter GetJsonValueReaderWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetJsonValueReaderWriter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJsonValueReaderWriter () As JsonValueReaderWriter" />
      <MemberSignature Language="F#" Value="abstract member GetJsonValueReaderWriter : unit -&gt; Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter&#xA;override this.GetJsonValueReaderWriter : unit -&gt; Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter" Usage="elementType.GetJsonValueReaderWriter " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.GetJsonValueReaderWriter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.Json.JsonValueReaderWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetJsonValueReaderWriterTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetJsonValueReaderWriterTypeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetJsonValueReaderWriterTypeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetJsonValueReaderWriterTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJsonValueReaderWriterTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetJsonValueReaderWriterTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetJsonValueReaderWriterTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetJsonValueReaderWriterTypeConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetJsonValueReaderWriterTypeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxLength">
      <MemberSignature Language="C#" Value="public virtual int? GetMaxLength ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; GetMaxLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetMaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMaxLength () As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member GetMaxLength : unit -&gt; Nullable&lt;int&gt;&#xA;override this.GetMaxLength : unit -&gt; Nullable&lt;int&gt;" Usage="elementType.GetMaxLength " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.GetMaxLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxLengthConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetMaxLengthConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetMaxLengthConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetMaxLengthConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMaxLengthConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetMaxLengthConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetMaxLengthConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetMaxLengthConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetMaxLengthConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrecision">
      <MemberSignature Language="C#" Value="public virtual int? GetPrecision ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; GetPrecision() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetPrecision" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrecision () As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member GetPrecision : unit -&gt; Nullable&lt;int&gt;&#xA;override this.GetPrecision : unit -&gt; Nullable&lt;int&gt;" Usage="elementType.GetPrecision " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.GetPrecision</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrecisionConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetPrecisionConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetPrecisionConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetPrecisionConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrecisionConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetPrecisionConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetPrecisionConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetPrecisionConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetPrecisionConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProviderClrType">
      <MemberSignature Language="C#" Value="public virtual Type? GetProviderClrType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetProviderClrType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetProviderClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProviderClrType () As Type" />
      <MemberSignature Language="F#" Value="abstract member GetProviderClrType : unit -&gt; Type&#xA;override this.GetProviderClrType : unit -&gt; Type" Usage="elementType.GetProviderClrType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.GetProviderClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProviderClrTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetProviderClrTypeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetProviderClrTypeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetProviderClrTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProviderClrTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetProviderClrTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetProviderClrTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetProviderClrTypeConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetProviderClrTypeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScale">
      <MemberSignature Language="C#" Value="public virtual int? GetScale ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; GetScale() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetScale" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetScale () As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member GetScale : unit -&gt; Nullable&lt;int&gt;&#xA;override this.GetScale : unit -&gt; Nullable&lt;int&gt;" Usage="elementType.GetScale " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.GetScale</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaleConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetScaleConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetScaleConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetScaleConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetScaleConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetScaleConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetScaleConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetScaleConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetScaleConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeMappingConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetTypeMappingConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetTypeMappingConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetTypeMappingConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeMappingConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetTypeMappingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetTypeMappingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetTypeMappingConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetTypeMappingConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueComparer">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? GetValueComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer GetValueComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetValueComparer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueComparer () As ValueComparer" />
      <MemberSignature Language="F#" Value="abstract member GetValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.GetValueComparer : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="elementType.GetValueComparer " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.GetValueComparer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueComparerConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetValueComparerConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetValueComparerConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetValueComparerConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueComparerConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetValueComparerConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetValueComparerConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetValueComparerConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetValueComparerConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueConverter">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? GetValueConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter GetValueConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetValueConverter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueConverter () As ValueConverter" />
      <MemberSignature Language="F#" Value="abstract member GetValueConverter : unit -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter&#xA;override this.GetValueConverter : unit -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Usage="elementType.GetValueConverter " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.GetValueConverter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValueConverterConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetValueConverterConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetValueConverterConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.GetValueConverterConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueConverterConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetValueConverterConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetValueConverterConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="elementType.GetValueConverterConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.GetValueConverterConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInModel">
      <MemberSignature Language="C#" Value="public virtual bool IsInModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.IsInModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInModel As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsInModel : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.IsInModel" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.IsInModel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public virtual bool IsNullable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsNullable As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.IsNullable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.IsNullable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicode">
      <MemberSignature Language="C#" Value="public virtual bool? IsUnicode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; IsUnicode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.IsUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsUnicode () As Nullable(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member IsUnicode : unit -&gt; Nullable&lt;bool&gt;&#xA;override this.IsUnicode : unit -&gt; Nullable&lt;bool&gt;" Usage="elementType.IsUnicode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.IsUnicode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionElementTypeBuilder Implements IConventionElementType.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.CollectionProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.CollectionProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.CollectionProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#CollectionProperty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CollectionProperty As IConventionProperty Implements IConventionElementType.CollectionProperty" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.CollectionProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.CollectionProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.CollectionProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsNullable">
      <MemberSignature Language="C#" Value="bool? IConventionElementType.SetIsNullable (bool? nullable, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsNullable(valuetype System.Nullable`1&lt;bool&gt; nullable, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetIsNullable(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetIsNullable (nullable As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Nullable(Of Boolean) Implements IConventionElementType.SetIsNullable" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsNullable : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsNullable : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsNullable (nullable, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsNullable(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullable" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nullable">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsUnicode">
      <MemberSignature Language="C#" Value="bool? IConventionElementType.SetIsUnicode (bool? unicode, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetIsUnicode(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetIsUnicode (unicode As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Nullable(Of Boolean) Implements IConventionElementType.SetIsUnicode" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsUnicode : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsUnicode : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsUnicode (unicode, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetIsUnicode(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetJsonValueReaderWriterType">
      <MemberSignature Language="C#" Value="Type? IConventionElementType.SetJsonValueReaderWriterType (Type? readerWriterType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetJsonValueReaderWriterType(class System.Type readerWriterType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetJsonValueReaderWriterType(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetJsonValueReaderWriterType (readerWriterType As Type, fromDataAnnotation As Boolean) As Type Implements IConventionElementType.SetJsonValueReaderWriterType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetJsonValueReaderWriterType : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetJsonValueReaderWriterType : Type * bool -&gt; Type" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetJsonValueReaderWriterType (readerWriterType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetJsonValueReaderWriterType(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerWriterType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="readerWriterType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetMaxLength">
      <MemberSignature Language="C#" Value="int? IConventionElementType.SetMaxLength (int? maxLength, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetMaxLength(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetMaxLength (maxLength As Nullable(Of Integer), fromDataAnnotation As Boolean) As Nullable(Of Integer) Implements IConventionElementType.SetMaxLength" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetMaxLength : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetMaxLength : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetMaxLength (maxLength, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetMaxLength(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetPrecision">
      <MemberSignature Language="C#" Value="int? IConventionElementType.SetPrecision (int? precision, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetPrecision(valuetype System.Nullable`1&lt;int32&gt; precision, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetPrecision(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetPrecision (precision As Nullable(Of Integer), fromDataAnnotation As Boolean) As Nullable(Of Integer) Implements IConventionElementType.SetPrecision" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetPrecision : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetPrecision : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetPrecision (precision, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetPrecision(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetProviderClrType">
      <MemberSignature Language="C#" Value="Type? IConventionElementType.SetProviderClrType (Type? providerClrType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetProviderClrType(class System.Type providerClrType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetProviderClrType(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetProviderClrType (providerClrType As Type, fromDataAnnotation As Boolean) As Type Implements IConventionElementType.SetProviderClrType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetProviderClrType : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetProviderClrType : Type * bool -&gt; Type" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetProviderClrType (providerClrType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetProviderClrType(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetScale">
      <MemberSignature Language="C#" Value="int? IConventionElementType.SetScale (int? scale, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetScale(valuetype System.Nullable`1&lt;int32&gt; scale, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetScale(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetScale (scale As Nullable(Of Integer), fromDataAnnotation As Boolean) As Nullable(Of Integer) Implements IConventionElementType.SetScale" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetScale : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetScale : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetScale (scale, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetScale(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetTypeMapping">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? IConventionElementType.SetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetTypeMapping (typeMapping As CoreTypeMapping, fromDataAnnotation As Boolean) As CoreTypeMapping Implements IConventionElementType.SetTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * bool -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * bool -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetTypeMapping (typeMapping, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? IConventionElementType.SetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueComparer (comparer As ValueComparer, fromDataAnnotation As Boolean) As ValueComparer Implements IConventionElementType.SetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer (comparer, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer">
      <MemberSignature Language="C#" Value="Type? IConventionElementType.SetValueComparer (Type? comparerType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer(class System.Type comparerType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetValueComparer(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueComparer (comparerType As Type, fromDataAnnotation As Boolean) As Type Implements IConventionElementType.SetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer : Type * bool -&gt; Type" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer (comparerType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueComparer(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? IConventionElementType.SetValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueConverter (converter As ValueConverter, fromDataAnnotation As Boolean) As ValueConverter Implements IConventionElementType.SetValueConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * bool -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * bool -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter (converter, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter">
      <MemberSignature Language="C#" Value="Type? IConventionElementType.SetValueConverter (Type? converterType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter(class System.Type converterType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IConventionElementType#SetValueConverter(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetValueConverter (converterType As Type, fromDataAnnotation As Boolean) As Type Implements IConventionElementType.SetValueConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter : Type * bool -&gt; Type" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter (converterType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionElementType.SetValueConverter(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.CollectionProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.CollectionProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.CollectionProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#CollectionProperty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CollectionProperty As IMutableProperty Implements IMutableElementType.CollectionProperty" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.CollectionProperty : Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.CollectionProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.CollectionProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetIsUnicode">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetIsUnicode (bool? unicode);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetIsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetIsUnicode(System.Nullable{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Sub SetIsUnicode (unicode As Nullable(Of Boolean)) Implements IMutableElementType.SetIsUnicode" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetIsUnicode : Nullable&lt;bool&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetIsUnicode : Nullable&lt;bool&gt; -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetIsUnicode unicode" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetIsUnicode(System.Nullable{System.Boolean})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetJsonValueReaderWriterType">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetJsonValueReaderWriterType (Type? readerWriterType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetJsonValueReaderWriterType(class System.Type readerWriterType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetJsonValueReaderWriterType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetJsonValueReaderWriterType (readerWriterType As Type) Implements IMutableElementType.SetJsonValueReaderWriterType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetJsonValueReaderWriterType : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetJsonValueReaderWriterType : Type -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetJsonValueReaderWriterType readerWriterType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetJsonValueReaderWriterType(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerWriterType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="readerWriterType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetMaxLength">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetMaxLength (int? maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetMaxLength(System.Nullable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Sub SetMaxLength (maxLength As Nullable(Of Integer)) Implements IMutableElementType.SetMaxLength" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetMaxLength : Nullable&lt;int&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetMaxLength : Nullable&lt;int&gt; -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetMaxLength maxLength" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetMaxLength(System.Nullable{System.Int32})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetPrecision">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetPrecision (int? precision);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetPrecision(valuetype System.Nullable`1&lt;int32&gt; precision) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetPrecision(System.Nullable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Sub SetPrecision (precision As Nullable(Of Integer)) Implements IMutableElementType.SetPrecision" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetPrecision : Nullable&lt;int&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetPrecision : Nullable&lt;int&gt; -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetPrecision precision" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetPrecision(System.Nullable{System.Int32})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetProviderClrType">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetProviderClrType (Type? providerClrType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetProviderClrType(class System.Type providerClrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetProviderClrType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetProviderClrType (providerClrType As Type) Implements IMutableElementType.SetProviderClrType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetProviderClrType : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetProviderClrType : Type -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetProviderClrType providerClrType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetProviderClrType(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetScale">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetScale (int? scale);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetScale(valuetype System.Nullable`1&lt;int32&gt; scale) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetScale(System.Nullable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Sub SetScale (scale As Nullable(Of Integer)) Implements IMutableElementType.SetScale" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetScale : Nullable&lt;int&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetScale : Nullable&lt;int&gt; -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetScale scale" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetScale(System.Nullable{System.Int32})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetTypeMapping">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping)" />
      <MemberSignature Language="VB.NET" Value="Sub SetTypeMapping (typeMapping As CoreTypeMapping) Implements IMutableElementType.SetTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetTypeMapping typeMapping" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueComparer (comparer As ValueComparer) Implements IMutableElementType.SetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer comparer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetValueComparer (Type? comparerType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer(class System.Type comparerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetValueComparer(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueComparer (comparerType As Type) Implements IMutableElementType.SetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer : Type -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer comparerType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueComparer(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueConverter (converter As ValueConverter) Implements IMutableElementType.SetValueConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter converter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter">
      <MemberSignature Language="C#" Value="void IMutableElementType.SetValueConverter (Type? converterType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter(class System.Type converterType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IMutableElementType#SetValueConverter(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Sub SetValueConverter (converterType As Type) Implements IMutableElementType.SetValueConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter : Type -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter : Type -&gt; unit" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter converterType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableElementType.SetValueConverter(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.CollectionProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.CollectionProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.CollectionProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyElementType#CollectionProperty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CollectionProperty As IReadOnlyProperty Implements IReadOnlyElementType.CollectionProperty" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.CollectionProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.CollectionProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.CollectionProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.FindTypeMapping">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? IReadOnlyElementType.FindTypeMapping ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.FindTypeMapping() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyElementType#FindTypeMapping" />
      <MemberSignature Language="VB.NET" Value="Function FindTypeMapping () As CoreTypeMapping Implements IReadOnlyElementType.FindTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.FindTypeMapping : unit -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.FindTypeMapping : unit -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" Usage="elementType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.FindTypeMapping " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyElementType.FindTypeMapping</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAnnotationSet">
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? annotation, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? oldAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation OnAnnotationSet(string name, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation annotation, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation oldAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.OnAnnotationSet(System.String,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnAnnotationSet (name As String, annotation As IConventionAnnotation, oldAnnotation As IConventionAnnotation) As IConventionAnnotation" />
      <MemberSignature Language="F#" Value="override this.OnAnnotationSet : string * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" Usage="elementType.OnAnnotationSet (name, annotation, oldAnnotation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="annotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" />
        <Parameter Name="oldAnnotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="annotation">To be added.</param>
        <param name="oldAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnElementTypeNullableChanged">
      <MemberSignature Language="C#" Value="protected virtual bool? OnElementTypeNullableChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; OnElementTypeNullableChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.OnElementTypeNullableChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnElementTypeNullableChanged () As Nullable(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member OnElementTypeNullableChanged : unit -&gt; Nullable&lt;bool&gt;&#xA;override this.OnElementTypeNullableChanged : unit -&gt; Nullable&lt;bool&gt;" Usage="elementType.OnElementTypeNullableChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void SetConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="elementType.SetConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsNullable">
      <MemberSignature Language="C#" Value="public virtual bool? SetIsNullable (bool? nullable, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; SetIsNullable(valuetype System.Nullable`1&lt;bool&gt; nullable, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetIsNullable(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetIsNullable (nullable As Nullable(Of Boolean), configurationSource As ConfigurationSource) As Nullable(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetIsNullable : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;&#xA;override this.SetIsNullable : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;" Usage="elementType.SetIsNullable (nullable, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullable" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="nullable">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsUnicode">
      <MemberSignature Language="C#" Value="public virtual bool? SetIsUnicode (bool? unicode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; SetIsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetIsUnicode(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetIsUnicode (unicode As Nullable(Of Boolean), configurationSource As ConfigurationSource) As Nullable(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetIsUnicode : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;&#xA;override this.SetIsUnicode : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;" Usage="elementType.SetIsUnicode (unicode, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetJsonValueReaderWriterType">
      <MemberSignature Language="C#" Value="public virtual Type? SetJsonValueReaderWriterType (Type? readerWriterType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetJsonValueReaderWriterType(class System.Type readerWriterType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetJsonValueReaderWriterType(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetJsonValueReaderWriterType (readerWriterType As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetJsonValueReaderWriterType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetJsonValueReaderWriterType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="elementType.SetJsonValueReaderWriterType (readerWriterType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerWriterType" Type="System.Type" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="readerWriterType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMaxLength">
      <MemberSignature Language="C#" Value="public virtual int? SetMaxLength (int? maxLength, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; SetMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetMaxLength(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetMaxLength (maxLength As Nullable(Of Integer), configurationSource As ConfigurationSource) As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SetMaxLength : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;&#xA;override this.SetMaxLength : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;" Usage="elementType.SetMaxLength (maxLength, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrecision">
      <MemberSignature Language="C#" Value="public virtual int? SetPrecision (int? precision, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; SetPrecision(valuetype System.Nullable`1&lt;int32&gt; precision, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetPrecision(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetPrecision (precision As Nullable(Of Integer), configurationSource As ConfigurationSource) As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SetPrecision : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;&#xA;override this.SetPrecision : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;" Usage="elementType.SetPrecision (precision, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProviderClrType">
      <MemberSignature Language="C#" Value="public virtual Type? SetProviderClrType (Type? providerClrType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetProviderClrType(class System.Type providerClrType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetProviderClrType(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetProviderClrType (providerClrType As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetProviderClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetProviderClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="elementType.SetProviderClrType (providerClrType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRemovedFromModel">
      <MemberSignature Language="C#" Value="public virtual void SetRemovedFromModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRemovedFromModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetRemovedFromModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRemovedFromModel ()" />
      <MemberSignature Language="F#" Value="abstract member SetRemovedFromModel : unit -&gt; unit&#xA;override this.SetRemovedFromModel : unit -&gt; unit" Usage="elementType.SetRemovedFromModel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetScale">
      <MemberSignature Language="C#" Value="public virtual int? SetScale (int? scale, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; SetScale(valuetype System.Nullable`1&lt;int32&gt; scale, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetScale(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetScale (scale As Nullable(Of Integer), configurationSource As ConfigurationSource) As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SetScale : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;&#xA;override this.SetScale : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;" Usage="elementType.SetScale (scale, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTypeMapping">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? SetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping SetTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetTypeMapping (typeMapping As CoreTypeMapping, configurationSource As ConfigurationSource) As CoreTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping&#xA;override this.SetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" Usage="elementType.SetTypeMapping (typeMapping, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueComparer">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? SetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer SetValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueComparer (comparer As ValueComparer, configurationSource As ConfigurationSource) As ValueComparer" />
      <MemberSignature Language="F#" Value="abstract member SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer&#xA;override this.SetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" Usage="elementType.SetValueComparer (comparer, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueComparer">
      <MemberSignature Language="C#" Value="public virtual Type? SetValueComparer (Type? comparerType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetValueComparer(class System.Type comparerType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetValueComparer(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueComparer (comparerType As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetValueComparer : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetValueComparer : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="elementType.SetValueComparer (comparerType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueConverter">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? SetValueConverter (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter SetValueConverter(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueConverter (converter As ValueConverter, configurationSource As ConfigurationSource) As ValueConverter" />
      <MemberSignature Language="F#" Value="abstract member SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter&#xA;override this.SetValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" Usage="elementType.SetValueConverter (converter, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValueConverter">
      <MemberSignature Language="C#" Value="public virtual Type? SetValueConverter (Type? converterType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetValueConverter(class System.Type converterType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.SetValueConverter(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetValueConverter (converterType As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetValueConverter : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetValueConverter : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="elementType.SetValueConverter (converterType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="elementType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeMapping">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? TypeMapping { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping TypeMapping" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.TypeMapping" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property TypeMapping As CoreTypeMapping" />
      <MemberSignature Language="F#" Value="member this.TypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.TypeMapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType.UpdateConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="elementType.UpdateConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
