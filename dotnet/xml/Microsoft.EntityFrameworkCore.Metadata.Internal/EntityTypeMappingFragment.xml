<Type Name="EntityTypeMappingFragment" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment">
  <TypeSignature Language="C#" Value="public class EntityTypeMappingFragment : Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment, Microsoft.EntityFrameworkCore.Metadata.IEntityTypeMappingFragment, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EntityTypeMappingFragment extends Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment, class Microsoft.EntityFrameworkCore.Metadata.IEntityTypeMappingFragment, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment" />
  <TypeSignature Language="VB.NET" Value="Public Class EntityTypeMappingFragment&#xA;Inherits ConventionAnnotatable&#xA;Implements IConventionEntityTypeMappingFragment, IEntityTypeMappingFragment, IMutableEntityTypeMappingFragment" />
  <TypeSignature Language="F#" Value="type EntityTypeMappingFragment = class&#xA;    inherit ConventionAnnotatable&#xA;    interface IEntityTypeMappingFragment&#xA;    interface IReadOnlyEntityTypeMappingFragment&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IAnnotatable&#xA;    interface IMutableEntityTypeMappingFragment&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionEntityTypeMappingFragment&#xA;    interface IConventionAnnotatable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IEntityTypeMappingFragment</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityTypeMappingFragment (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType, in Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier storeObject, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType, [in]valuetype Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier&amp; storeObject, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.#ctor(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType,Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier@,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (entityType As IReadOnlyEntityType, ByRef storeObject As StoreObjectIdentifier, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType * StoreObjectIdentifier * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment (entityType, storeObject, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
        <Parameter Name="storeObject" Type="Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="storeObject">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public static void Attach (Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType entityType, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment detachedFragment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Attach(class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType entityType, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment detachedFragment) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Attach(Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Attach (entityType As IConventionEntityType, detachedFragment As IConventionEntityTypeMappingFragment)" />
      <MemberSignature Language="F#" Value="static member Attach : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment -&gt; unit" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Attach (entityType, detachedFragment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" />
        <Parameter Name="detachedFragment" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="detachedFragment">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Builder">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeMappingFragmentBuilder Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeMappingFragmentBuilder Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Builder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Builder As InternalEntityTypeMappingFragmentBuilder" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeMappingFragmentBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Builder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeMappingFragmentBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DebugView">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.DebugView" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DebugView As DebugView" />
      <MemberSignature Language="F#" Value="member this.DebugView : Microsoft.EntityFrameworkCore.Infrastructure.DebugView" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.DebugView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Infrastructure.DebugView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType EntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType EntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.EntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntityType As IReadOnlyEntityType" />
      <MemberSignature Language="F#" Value="member this.EntityType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.EntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment.EntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment? Find (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType, in Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier storeObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment Find(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType, [in]valuetype Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier&amp; storeObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Find(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType,Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find (entityType As IReadOnlyEntityType, ByRef storeObject As StoreObjectIdentifier) As IReadOnlyEntityTypeMappingFragment" />
      <MemberSignature Language="F#" Value="static member Find : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType * StoreObjectIdentifier -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Find (entityType, storeObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
        <Parameter Name="storeObject" Type="Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="storeObject">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment&gt;? Get (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment&gt; Get(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Get(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Get (entityType As IReadOnlyEntityType) As IEnumerable(Of IReadOnlyEntityTypeMappingFragment)" />
      <MemberSignature Language="F#" Value="static member Get : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Get entityType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.GetConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigurationSource () As ConfigurationSource" />
      <MemberSignature Language="F#" Value="abstract member GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&#xA;override this.GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Usage="entityTypeMappingFragment.GetConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.GetConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsTableExcludedFromMigrationsConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetIsTableExcludedFromMigrationsConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetIsTableExcludedFromMigrationsConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.GetIsTableExcludedFromMigrationsConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsTableExcludedFromMigrationsConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsTableExcludedFromMigrationsConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetIsTableExcludedFromMigrationsConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityTypeMappingFragment.GetIsTableExcludedFromMigrationsConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.GetIsTableExcludedFromMigrationsConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreate">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment GetOrCreate (Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType entityType, in Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier storeObject, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment GetOrCreate(class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType entityType, [in]valuetype Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier&amp; storeObject, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.GetOrCreate(Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType,Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier@,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOrCreate (entityType As IMutableEntityType, ByRef storeObject As StoreObjectIdentifier, configurationSource As ConfigurationSource) As EntityTypeMappingFragment" />
      <MemberSignature Language="F#" Value="static member GetOrCreate : Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType * StoreObjectIdentifier * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.GetOrCreate (entityType, storeObject, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" />
        <Parameter Name="storeObject" Type="Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="storeObject">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInModel">
      <MemberSignature Language="C#" Value="public virtual bool IsInModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.IsInModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInModel As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsInModel : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.IsInModel" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.IsInModel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTableExcludedFromMigrations">
      <MemberSignature Language="C#" Value="public virtual bool? IsTableExcludedFromMigrations { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; IsTableExcludedFromMigrations" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.IsTableExcludedFromMigrations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsTableExcludedFromMigrations As Nullable(Of Boolean)" />
      <MemberSignature Language="F#" Value="member this.IsTableExcludedFromMigrations : Nullable&lt;bool&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.IsTableExcludedFromMigrations" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment.IsTableExcludedFromMigrations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="MergeInto">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment MergeInto (Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment detachedFragment, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment existingFragment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment MergeInto(class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment detachedFragment, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment existingFragment) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.MergeInto(Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MergeInto (detachedFragment As IConventionEntityTypeMappingFragment, existingFragment As IConventionEntityTypeMappingFragment) As EntityTypeMappingFragment" />
      <MemberSignature Language="F#" Value="static member MergeInto : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.MergeInto (detachedFragment, existingFragment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="detachedFragment" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment" />
        <Parameter Name="existingFragment" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment" />
      </Parameters>
      <Docs>
        <param name="detachedFragment">To be added.</param>
        <param name="existingFragment">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionEntityTypeMappingFragmentBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionEntityTypeMappingFragmentBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityTypeMappingFragment#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionEntityTypeMappingFragmentBuilder Implements IConventionEntityTypeMappingFragment.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionEntityTypeMappingFragmentBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionEntityTypeMappingFragmentBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.EntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.EntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.EntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityTypeMappingFragment#EntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property EntityType As IConventionEntityType Implements IConventionEntityTypeMappingFragment.EntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.EntityType : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.EntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.EntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.SetIsTableExcludedFromMigrations">
      <MemberSignature Language="C#" Value="bool? IConventionEntityTypeMappingFragment.SetIsTableExcludedFromMigrations (bool? excluded, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.SetIsTableExcludedFromMigrations(valuetype System.Nullable`1&lt;bool&gt; excluded, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityTypeMappingFragment#SetIsTableExcludedFromMigrations(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetIsTableExcludedFromMigrations (excluded As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Nullable(Of Boolean) Implements IConventionEntityTypeMappingFragment.SetIsTableExcludedFromMigrations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.SetIsTableExcludedFromMigrations : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.SetIsTableExcludedFromMigrations : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;" Usage="entityTypeMappingFragment.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.SetIsTableExcludedFromMigrations (excluded, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityTypeMappingFragment.SetIsTableExcludedFromMigrations(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="excluded" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="excluded">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityTypeMappingFragment.EntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.IEntityTypeMappingFragment.EntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.IEntityTypeMappingFragment.EntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Microsoft#EntityFrameworkCore#Metadata#IEntityTypeMappingFragment#EntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property EntityType As IEntityType Implements IEntityTypeMappingFragment.EntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IEntityTypeMappingFragment.EntityType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IEntityTypeMappingFragment.EntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IEntityTypeMappingFragment.EntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment.EntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment.EntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment.EntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityTypeMappingFragment#EntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property EntityType As IMutableEntityType Implements IMutableEntityTypeMappingFragment.EntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment.EntityType : Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment.EntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityTypeMappingFragment.EntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment.IsTableExcludedFromMigrations">
      <MemberSignature Language="C#" Value="bool? Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment.IsTableExcludedFromMigrations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment.IsTableExcludedFromMigrations" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityTypeMappingFragment#IsTableExcludedFromMigrations" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsTableExcludedFromMigrations As Nullable(Of Boolean) Implements IReadOnlyEntityTypeMappingFragment.IsTableExcludedFromMigrations" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment.IsTableExcludedFromMigrations : Nullable&lt;bool&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment.IsTableExcludedFromMigrations" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment.IsTableExcludedFromMigrations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment? Remove (Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType entityType, in Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier storeObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment Remove(class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType entityType, [in]valuetype Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier&amp; storeObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Remove(Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType,Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (entityType As IMutableEntityType, ByRef storeObject As StoreObjectIdentifier) As EntityTypeMappingFragment" />
      <MemberSignature Language="F#" Value="static member Remove : Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType * StoreObjectIdentifier -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.Remove (entityType, storeObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" />
        <Parameter Name="storeObject" Type="Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="storeObject">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsTableExcludedFromMigrations">
      <MemberSignature Language="C#" Value="public virtual bool? SetIsTableExcludedFromMigrations (bool? excluded, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; SetIsTableExcludedFromMigrations(valuetype System.Nullable`1&lt;bool&gt; excluded, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.SetIsTableExcludedFromMigrations(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetIsTableExcludedFromMigrations (excluded As Nullable(Of Boolean), configurationSource As ConfigurationSource) As Nullable(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetIsTableExcludedFromMigrations : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;&#xA;override this.SetIsTableExcludedFromMigrations : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;" Usage="entityTypeMappingFragment.SetIsTableExcludedFromMigrations (excluded, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="excluded" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="excluded">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRemovedFromModel">
      <MemberSignature Language="C#" Value="public virtual void SetRemovedFromModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRemovedFromModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.SetRemovedFromModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRemovedFromModel ()" />
      <MemberSignature Language="F#" Value="abstract member SetRemovedFromModel : unit -&gt; unit&#xA;override this.SetRemovedFromModel : unit -&gt; unit" Usage="entityTypeMappingFragment.SetRemovedFromModel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StoreObject">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier StoreObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier StoreObject" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.StoreObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StoreObject As StoreObjectIdentifier" />
      <MemberSignature Language="F#" Value="member this.StoreObject : Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.StoreObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityTypeMappingFragment.StoreObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="entityTypeMappingFragment.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityTypeMappingFragment.UpdateConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="entityTypeMappingFragment.UpdateConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
