<Type Name="PropertyAccessorsFactory" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory">
  <TypeSignature Language="C#" Value="public class PropertyAccessorsFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyAccessorsFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyAccessorsFactory" />
  <TypeSignature Language="F#" Value="type PropertyAccessorsFactory = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <AssemblyVersion>1.0.6.0</AssemblyVersion>
    <AssemblyVersion>1.1.0.0</AssemblyVersion>
    <AssemblyVersion>1.1.6.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.3.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.11.0</AssemblyVersion>
    <AssemblyVersion>2.2.6.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyAccessorsFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKeyMethod">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MethodInfo ContainsKeyMethod;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MethodInfo ContainsKeyMethod" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.ContainsKeyMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContainsKeyMethod As MethodInfo " />
      <MemberSignature Language="F#" Value=" staticval mutable ContainsKeyMethod : System.Reflection.MethodInfo" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.ContainsKeyMethod" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessors Create (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessors Create(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.Create(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Create (propertyBase As IPropertyBase) As PropertyAccessors" />
      <MemberSignature Language="F#" Value="abstract member Create : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessors&#xA;override this.Create : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessors" Usage="propertyAccessorsFactory.Create propertyBase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessors</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public virtual void Create (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase, out System.Linq.Expressions.Expression currentValueGetter, out System.Linq.Expressions.Expression preStoreGeneratedCurrentValueGetter, out System.Linq.Expressions.Expression? originalValueGetter, out System.Linq.Expressions.Expression relationshipSnapshotGetter, out System.Linq.Expressions.Expression? valueBufferGetter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Create(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase propertyBase, [out] class System.Linq.Expressions.Expression&amp; currentValueGetter, [out] class System.Linq.Expressions.Expression&amp; preStoreGeneratedCurrentValueGetter, [out] class System.Linq.Expressions.Expression&amp; originalValueGetter, [out] class System.Linq.Expressions.Expression&amp; relationshipSnapshotGetter, [out] class System.Linq.Expressions.Expression&amp; valueBufferGetter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.Create(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,System.Linq.Expressions.Expression@,System.Linq.Expressions.Expression@,System.Linq.Expressions.Expression@,System.Linq.Expressions.Expression@,System.Linq.Expressions.Expression@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Create (propertyBase As IPropertyBase, ByRef currentValueGetter As Expression, ByRef preStoreGeneratedCurrentValueGetter As Expression, ByRef originalValueGetter As Expression, ByRef relationshipSnapshotGetter As Expression, ByRef valueBufferGetter As Expression)" />
      <MemberSignature Language="F#" Value="abstract member Create : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * Expression * Expression * Expression * Expression * Expression -&gt; unit&#xA;override this.Create : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * Expression * Expression * Expression * Expression * Expression -&gt; unit" Usage="propertyAccessorsFactory.Create (propertyBase, currentValueGetter, preStoreGeneratedCurrentValueGetter, originalValueGetter, relationshipSnapshotGetter, valueBufferGetter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyBase" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" Index="0" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="currentValueGetter" Type="System.Linq.Expressions.Expression" RefType="out" Index="1" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="preStoreGeneratedCurrentValueGetter" Type="System.Linq.Expressions.Expression" RefType="out" Index="2" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="originalValueGetter" Type="System.Linq.Expressions.Expression" RefType="out" Index="3" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="relationshipSnapshotGetter" Type="System.Linq.Expressions.Expression" RefType="out" Index="4" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="valueBufferGetter" Type="System.Linq.Expressions.Expression" RefType="out" Index="5" FrameworkAlternate="efcore-9.0" />
      </Parameters>
      <Docs>
        <param name="propertyBase">To be added.</param>
        <param name="currentValueGetter">To be added.</param>
        <param name="preStoreGeneratedCurrentValueGetter">To be added.</param>
        <param name="originalValueGetter">To be added.</param>
        <param name="relationshipSnapshotGetter">To be added.</param>
        <param name="valueBufferGetter">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression CreateMemberAccess (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase? property, System.Linq.Expressions.Expression instanceExpression, System.Reflection.MemberInfo memberInfo, bool fromContainingType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression CreateMemberAccess(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase property, class System.Linq.Expressions.Expression instanceExpression, class System.Reflection.MemberInfo memberInfo, bool fromContainingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.CreateMemberAccess(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,System.Linq.Expressions.Expression,System.Reflection.MemberInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMemberAccess (property As IPropertyBase, instanceExpression As Expression, memberInfo As MemberInfo, fromContainingType As Boolean) As Expression" />
      <MemberSignature Language="F#" Value="static member CreateMemberAccess : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase * System.Linq.Expressions.Expression * System.Reflection.MemberInfo * bool -&gt; System.Linq.Expressions.Expression" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.CreateMemberAccess (property, instanceExpression, memberInfo, fromContainingType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" Index="0" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="instanceExpression" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-9.0" />
        <Parameter Name="fromContainingType" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-9.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="instanceExpression">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="fromContainingType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Instance">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory Instance;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory Instance" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.Instance" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Instance As PropertyAccessorsFactory " />
      <MemberSignature Language="F#" Value=" staticval mutable Instance : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.Instance" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
