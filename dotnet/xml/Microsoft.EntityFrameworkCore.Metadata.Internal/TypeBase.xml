<Type Name="TypeBase" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase">
  <TypeSignature Language="C#" Value="public abstract class TypeBase : Microsoft.EntityFrameworkCore.Metadata.Internal.ConventionalAnnotatable, Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TypeBase extends Microsoft.EntityFrameworkCore.Metadata.Internal.ConventionalAnnotatable implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TypeBase&#xA;Inherits ConventionalAnnotatable&#xA;Implements IMutableTypeBase" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="F#" Value="type TypeBase = class&#xA;    inherit ConventionalAnnotatable&#xA;    interface IMutableTypeBase&#xA;    interface ITypeBase&#xA;    interface IAnnotatable&#xA;    interface IMutableAnnotatable" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="C#" Value="public abstract class TypeBase : Microsoft.EntityFrameworkCore.Metadata.Internal.ConventionAnnotatable, Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase" FrameworkAlternate="efcore-3.0;efcore-3.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TypeBase extends Microsoft.EntityFrameworkCore.Metadata.Internal.ConventionAnnotatable implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-3.0;efcore-3.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TypeBase&#xA;Inherits ConventionAnnotatable&#xA;Implements IConventionTypeBase, IMutableTypeBase" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="F#" Value="type TypeBase = class&#xA;    inherit ConventionAnnotatable&#xA;    interface IMutableTypeBase&#xA;    interface ITypeBase&#xA;    interface IAnnotatable&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionTypeBase&#xA;    interface IConventionAnnotatable" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="C#" Value="public abstract class TypeBase : Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable, Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TypeBase extends Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="C#" Value="public abstract class TypeBase : Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable, Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TypeBase extends Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TypeBase&#xA;Inherits ConventionAnnotatable&#xA;Implements IConventionTypeBase, IMutableTypeBase, ITypeBase" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="F#" Value="type TypeBase = class&#xA;    inherit ConventionAnnotatable&#xA;    interface IMutableTypeBase&#xA;    interface IReadOnlyTypeBase&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionTypeBase&#xA;    interface IConventionAnnotatable&#xA;    interface ITypeBase&#xA;    interface IAnnotatable" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>1.1.0.0</AssemblyVersion>
    <AssemblyVersion>1.1.6.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.3.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.11.0</AssemblyVersion>
    <AssemblyVersion>2.2.6.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Internal.ConventionalAnnotatable</BaseTypeName>
    <BaseTypeName FrameworkAlternate="efcore-3.0;efcore-3.1">Microsoft.EntityFrameworkCore.Metadata.Internal.ConventionAnnotatable</BaseTypeName>
    <BaseTypeName FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.ITypeBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBase (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.#ctor(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, model As Model, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase : string * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase (name, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBase (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.#ctor(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, model As Model, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase : string * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase (name, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="2" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBase (Type clrType, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type clrType, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.#ctor(System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (clrType As Type, model As Model, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase (clrType, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="2" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="clrType">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBase (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, type As Type, model As Model, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase : string * Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase (name, type, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBase (Type clrType, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type clrType, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.#ctor(System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (clrType As Type, model As Model, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase (clrType, model, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="protected TypeBase (Type type, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (type As Type, model As Model, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase (type, model, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="clrType">To be added.</param>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty? AddComplexProperty (System.Reflection.MemberInfo memberInfo, bool collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty AddComplexProperty(class System.Reflection.MemberInfo memberInfo, bool collection, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.AddComplexProperty(System.Reflection.MemberInfo,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddComplexProperty (memberInfo As MemberInfo, collection As Boolean, configurationSource As ConfigurationSource) As ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member AddComplexProperty : System.Reflection.MemberInfo * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&#xA;override this.AddComplexProperty : System.Reflection.MemberInfo * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Usage="typeBase.AddComplexProperty (memberInfo, collection, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="2" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty? AddComplexProperty (string name, bool collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty AddComplexProperty(string name, bool collection, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.AddComplexProperty(System.String,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddComplexProperty (name As String, collection As Boolean, configurationSource As ConfigurationSource) As ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member AddComplexProperty : string * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&#xA;override this.AddComplexProperty : string * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Usage="typeBase.AddComplexProperty (name, collection, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="2" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty? AddComplexProperty (string name, Type propertyType, Type targetType, bool collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty AddComplexProperty(string name, class System.Type propertyType, class System.Type targetType, bool collection, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.AddComplexProperty(System.String,System.Type,System.Type,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddComplexProperty (name As String, propertyType As Type, targetType As Type, collection As Boolean, configurationSource As ConfigurationSource) As ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member AddComplexProperty : string * Type * Type * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&#xA;override this.AddComplexProperty : string * Type * Type * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Usage="typeBase.AddComplexProperty (name, propertyType, targetType, collection, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="targetType" Type="System.Type" Index="2" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="collection" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="4" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="targetType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty? AddComplexProperty (string name, Type propertyType, System.Reflection.MemberInfo? memberInfo, string? complexTypeName, Type targetType, bool collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty AddComplexProperty(string name, class System.Type propertyType, class System.Reflection.MemberInfo memberInfo, string complexTypeName, class System.Type targetType, bool collection, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.AddComplexProperty(System.String,System.Type,System.Reflection.MemberInfo,System.String,System.Type,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddComplexProperty (name As String, propertyType As Type, memberInfo As MemberInfo, complexTypeName As String, targetType As Type, collection As Boolean, configurationSource As ConfigurationSource) As ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member AddComplexProperty : string * Type * System.Reflection.MemberInfo * string * Type * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&#xA;override this.AddComplexProperty : string * Type * System.Reflection.MemberInfo * string * Type * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Usage="typeBase.AddComplexProperty (name, propertyType, memberInfo, complexTypeName, targetType, collection, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="complexTypeName" Type="System.String" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetType" Type="System.Type" Index="4" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="collection" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="6" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="complexTypeName">To be added.</param>
        <param name="targetType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddIgnored">
      <MemberSignature Language="C#" Value="public virtual void AddIgnored (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddIgnored(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.AddIgnored(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddIgnored (name As String, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member AddIgnored : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.AddIgnored : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="typeBase.AddIgnored (name, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual string AddIgnored (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string AddIgnored(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddIgnored (name As String, configurationSource As ConfigurationSource) As String" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member AddIgnored : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; string&#xA;override this.AddIgnored : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; string" Usage="typeBase.AddIgnored (name, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public virtual string? AddIgnored (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? AddProperty (System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(class System.Reflection.MemberInfo memberInfo, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.AddProperty(System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (memberInfo As MemberInfo, configurationSource As ConfigurationSource) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="typeBase.AddProperty (memberInfo, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? AddProperty (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.AddProperty(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, configurationSource As ConfigurationSource) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="typeBase.AddProperty (name, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? AddProperty (string name, Type propertyType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(string name, class System.Type propertyType, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.AddProperty(System.String,System.Type,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, propertyType As Type, typeConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As ConfigurationSource) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : string * Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="typeBase.AddProperty (name, propertyType, typeConfigurationSource, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? AddProperty (string name, Type propertyType, System.Reflection.MemberInfo? memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(string name, class System.Type propertyType, class System.Reflection.MemberInfo memberInfo, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.AddProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, propertyType As Type, memberInfo As MemberInfo, typeConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As ConfigurationSource) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Type * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : string * Type * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="typeBase.AddProperty (name, propertyType, memberInfo, typeConfigurationSource, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="4" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseBuilder">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder BaseBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder BaseBuilder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.BaseBuilder" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property BaseBuilder As InternalTypeBaseBuilder" />
      <MemberSignature Language="F#" Value="member this.BaseBuilder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.BaseBuilder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase? BaseType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.BaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property BaseType As TypeBase" />
      <MemberSignature Language="F#" Value="member this.BaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Builder">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Builder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Builder As InternalTypeBaseBuilder" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Builder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public static string? CheckChangeTrackingStrategy (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase typeBase, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy value, bool requireFullNotifications);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CheckChangeTrackingStrategy(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase typeBase, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy value, bool requireFullNotifications) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.CheckChangeTrackingStrategy(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckChangeTrackingStrategy (typeBase As IReadOnlyTypeBase, value As ChangeTrackingStrategy, requireFullNotifications As Boolean) As String" />
      <MemberSignature Language="F#" Value="static member CheckChangeTrackingStrategy : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * bool -&gt; string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.CheckChangeTrackingStrategy (typeBase, value, requireFullNotifications)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeBase" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="value" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="requireFullNotifications" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="typeBase">To be added.</param>
        <param name="value">To be added.</param>
        <param name="requireFullNotifications">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearCaches">
      <MemberSignature Language="C#" Value="public virtual void ClearCaches ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearCaches() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.ClearCaches" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ClearCaches ()" />
      <MemberSignature Language="F#" Value="abstract member ClearCaches : unit -&gt; unit&#xA;override this.ClearCaches : unit -&gt; unit" Usage="typeBase.ClearCaches " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClrType">
      <MemberSignature Language="C#" Value="public virtual Type ClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.ClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClrType As Type" />
      <MemberSignature Language="F#" Value="member this.ClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.ClrType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructorBinding">
      <MemberSignature Language="C#" Value="public abstract Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? ConstructorBinding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding ConstructorBinding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.ConstructorBinding" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ConstructorBinding As InstantiationBinding" />
      <MemberSignature Language="F#" Value="member this.ConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.ConstructorBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.SortedSet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt; DirectlyDerivedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedSet`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt; DirectlyDerivedTypes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.DirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DirectlyDerivedTypes As SortedSet(Of TypeBase)" />
      <MemberSignature Language="F#" Value="member this.DirectlyDerivedTypes : System.Collections.Generic.SortedSet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.DirectlyDerivedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedSet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindComplexPropertiesInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; FindComplexPropertiesInHierarchy (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; FindComplexPropertiesInHierarchy(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindComplexPropertiesInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindComplexPropertiesInHierarchy (propertyName As String) As IEnumerable(Of ComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindComplexPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;&#xA;override this.FindComplexPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;" Usage="typeBase.FindComplexPropertiesInHierarchy propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty? FindComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty FindComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindComplexProperty (name As String) As ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&#xA;override this.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Usage="typeBase.FindComplexProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty? FindDeclaredComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty FindDeclaredComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindDeclaredComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredComplexProperty (name As String) As ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&#xA;override this.FindDeclaredComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Usage="typeBase.FindDeclaredComplexProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredIgnoredConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? FindDeclaredIgnoredConfigurationSource (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; FindDeclaredIgnoredConfigurationSource(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindDeclaredIgnoredConfigurationSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredIgnoredConfigurationSource (name As String) As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredIgnoredConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.FindDeclaredIgnoredConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="typeBase.FindDeclaredIgnoredConfigurationSource name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredIgnoredMemberConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? FindDeclaredIgnoredMemberConfigurationSource (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; FindDeclaredIgnoredMemberConfigurationSource(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindDeclaredIgnoredMemberConfigurationSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredIgnoredMemberConfigurationSource (name As String) As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredIgnoredMemberConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.FindDeclaredIgnoredMemberConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="typeBase.FindDeclaredIgnoredMemberConfigurationSource name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? FindDeclaredProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindDeclaredProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredProperty (name As String) As Property" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="typeBase.FindDeclaredProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedComplexProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; FindDerivedComplexProperties (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; FindDerivedComplexProperties(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindDerivedComplexProperties(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedComplexProperties (propertyName As String) As IEnumerable(Of ComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedComplexProperties : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;&#xA;override this.FindDerivedComplexProperties : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;" Usage="typeBase.FindDerivedComplexProperties propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedComplexPropertiesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; FindDerivedComplexPropertiesInclusive (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; FindDerivedComplexPropertiesInclusive(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindDerivedComplexPropertiesInclusive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedComplexPropertiesInclusive (propertyName As String) As IEnumerable(Of ComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedComplexPropertiesInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;&#xA;override this.FindDerivedComplexPropertiesInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;" Usage="typeBase.FindDerivedComplexPropertiesInclusive propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindDerivedProperties (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindDerivedProperties(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindDerivedProperties(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedProperties (propertyName As String) As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedProperties : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.FindDerivedProperties : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="typeBase.FindDerivedProperties propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedPropertiesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindDerivedPropertiesInclusive (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindDerivedPropertiesInclusive(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindDerivedPropertiesInclusive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedPropertiesInclusive (propertyName As String) As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedPropertiesInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.FindDerivedPropertiesInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="typeBase.FindDerivedPropertiesInclusive propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIgnoredConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? FindIgnoredConfigurationSource (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; FindIgnoredConfigurationSource(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindIgnoredConfigurationSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIgnoredConfigurationSource (name As String) As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member FindIgnoredConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.FindIgnoredConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="typeBase.FindIgnoredConfigurationSource name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindIgnoredConfigurationSource(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIgnoredMemberConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? FindIgnoredMemberConfigurationSource (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; FindIgnoredMemberConfigurationSource(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindIgnoredMemberConfigurationSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIgnoredMemberConfigurationSource (name As String) As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member FindIgnoredMemberConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.FindIgnoredMemberConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="typeBase.FindIgnoredMemberConfigurationSource name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndexerPropertyInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.PropertyInfo FindIndexerPropertyInfo ();" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo FindIndexerPropertyInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindIndexerPropertyInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndexerPropertyInfo () As PropertyInfo" />
      <MemberSignature Language="F#" Value="abstract member FindIndexerPropertyInfo : unit -&gt; System.Reflection.PropertyInfo&#xA;override this.FindIndexerPropertyInfo : unit -&gt; System.Reflection.PropertyInfo" Usage="typeBase.FindIndexerPropertyInfo " />
      <MemberSignature Language="C#" Value="public virtual System.Reflection.PropertyInfo? FindIndexerPropertyInfo ();" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindIndexerPropertyInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMember">
      <MemberSignature Language="C#" Value="public abstract Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase? FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindMember (name As String) As PropertyBase" />
      <MemberSignature Language="F#" Value="abstract member FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase" Usage="typeBase.FindMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindMembersInHierarchy (name As String) As IEnumerable(Of PropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="typeBase.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? FindProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindProperties(class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; propertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindProperties(System.Collections.Generic.IReadOnlyList{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindProperties (propertyNames As IReadOnlyList(Of String)) As IReadOnlyList(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="typeBase.FindProperties propertyNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IReadOnlyList&lt;System.String&gt;" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyNames">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindPropertiesInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindPropertiesInHierarchy (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindPropertiesInHierarchy(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindPropertiesInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindPropertiesInHierarchy (propertyName As String) As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member FindPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.FindPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="typeBase.FindPropertiesInHierarchy propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? FindProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindProperty (name As String) As Property" />
      <MemberSignature Language="F#" Value="abstract member FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="typeBase.FindProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTrackingStrategy GetChangeTrackingStrategy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy GetChangeTrackingStrategy() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetChangeTrackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChangeTrackingStrategy () As ChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member GetChangeTrackingStrategy : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&#xA;override this.GetChangeTrackingStrategy : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Usage="typeBase.GetChangeTrackingStrategy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetChangeTrackingStrategy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTrackingStrategy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeTrackingStrategyConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetChangeTrackingStrategyConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetChangeTrackingStrategyConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetChangeTrackingStrategyConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChangeTrackingStrategyConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetChangeTrackingStrategyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetChangeTrackingStrategyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="typeBase.GetChangeTrackingStrategyConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetChangeTrackingStrategyConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetComplexProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; GetComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; GetComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetComplexProperties () As IEnumerable(Of ComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;&#xA;override this.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;" Usage="typeBase.GetComplexProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource GetConfigurationSource ();" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource GetConfigurationSource() cil managed" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigurationSource () As ConfigurationSource" />
      <MemberSignature Language="F#" Value="abstract member GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&#xA;override this.GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Usage="typeBase.GetConfigurationSource " FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&#xA;override this.GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Usage="typeBase.GetConfigurationSource " FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredComplexProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; GetDeclaredComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; GetDeclaredComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetDeclaredComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredComplexProperties () As IEnumerable(Of ComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;&#xA;override this.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;" Usage="typeBase.GetDeclaredComplexProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredMembers">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetDeclaredMembers () As IEnumerable(Of PropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="typeBase.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredProperties () As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="typeBase.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedComplexProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; GetDerivedComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; GetDerivedComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetDerivedComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedComplexProperties () As IEnumerable(Of ComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;&#xA;override this.GetDerivedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;" Usage="typeBase.GetDerivedComplexProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetDerivedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetDerivedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetDerivedProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedProperties () As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="typeBase.GetDerivedProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt; GetDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt; GetDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedTypes () As IEnumerable(Of TypeBase)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt;&#xA;override this.GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt;" Usage="typeBase.GetDerivedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedTypes&lt;T&gt;">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;T&gt; GetDerivedTypes&lt;T&gt; () where T : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase;" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; GetDerivedTypes&lt;(class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase) T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetDerivedTypes``1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDerivedTypes(Of T As TypeBase) () As IEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedTypes : unit -&gt; seq&lt;'T (requires 'T :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase)&gt; (requires 'T :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase)&#xA;override this.GetDerivedTypes : unit -&gt; seq&lt;'T (requires 'T :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase)&gt; (requires 'T :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase)" Usage="typeBase.GetDerivedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedTypesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt; GetDerivedTypesInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt; GetDerivedTypesInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetDerivedTypesInclusive" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedTypesInclusive () As IEnumerable(Of TypeBase)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt;&#xA;override this.GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt;" Usage="typeBase.GetDerivedTypesInclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlattenedComplexProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; GetFlattenedComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; GetFlattenedComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetFlattenedComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Overridable Function GetFlattenedComplexProperties () As IEnumerable(Of ComplexProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetFlattenedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;&#xA;override this.GetFlattenedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;" Usage="typeBase.GetFlattenedComplexProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase+&lt;GetFlattenedComplexProperties&gt;d__108))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase+&lt;GetFlattenedComplexProperties&gt;d__108))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all <see cref="T:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" /> members from this type and all nested complex types, if any.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlattenedDeclaredProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetFlattenedDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetFlattenedDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetFlattenedDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Overridable Function GetFlattenedDeclaredProperties () As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetFlattenedDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetFlattenedDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="typeBase.GetFlattenedDeclaredProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase+&lt;GetFlattenedDeclaredProperties&gt;d__109))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase+&lt;GetFlattenedDeclaredProperties&gt;d__109))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IProperty" /> members from this type and all nested complex types, if any.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlattenedProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetFlattenedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetFlattenedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetFlattenedProperties" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Overridable Function GetFlattenedProperties () As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetFlattenedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetFlattenedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="typeBase.GetFlattenedProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase+&lt;GetFlattenedProperties&gt;d__107))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase+&lt;GetFlattenedProperties&gt;d__107))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IProperty" /> members from this type and all nested complex types, if any.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIgnoredMembers">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;string&gt; GetIgnoredMembers ();" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; GetIgnoredMembers() cil managed" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetIgnoredMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIgnoredMembers () As IReadOnlyList(Of String)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member GetIgnoredMembers : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;string&gt;&#xA;override this.GetIgnoredMembers : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;string&gt;" Usage="typeBase.GetIgnoredMembers " FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetIgnoredMembers ();" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetIgnoredMembers() cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIgnoredMembers () As IEnumerable(Of String)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetIgnoredMembers : unit -&gt; seq&lt;string&gt;&#xA;override this.GetIgnoredMembers : unit -&gt; seq&lt;string&gt;" Usage="typeBase.GetIgnoredMembers " FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetIgnoredMembers</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetIgnoredMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers () As IEnumerable(Of PropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="typeBase.GetMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNavigationAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.PropertyAccessMode GetNavigationAccessMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode GetNavigationAccessMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetNavigationAccessMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNavigationAccessMode () As PropertyAccessMode" />
      <MemberSignature Language="F#" Value="abstract member GetNavigationAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode&#xA;override this.GetNavigationAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode" Usage="typeBase.GetNavigationAccessMode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetNavigationAccessMode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.PropertyAccessMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProperties () As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="typeBase.GetProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.PropertyAccessMode GetPropertyAccessMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode GetPropertyAccessMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetPropertyAccessMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPropertyAccessMode () As PropertyAccessMode" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode&#xA;override this.GetPropertyAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode" Usage="typeBase.GetPropertyAccessMode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetPropertyAccessMode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.PropertyAccessMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeFields">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.Dictionary&lt;string,System.Reflection.FieldInfo&gt; GetRuntimeFields ();" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.Dictionary`2&lt;string, class System.Reflection.FieldInfo&gt; GetRuntimeFields() cil managed" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetRuntimeFields" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRuntimeFields () As Dictionary(Of String, FieldInfo)" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeFields : unit -&gt; System.Collections.Generic.Dictionary&lt;string, System.Reflection.FieldInfo&gt;&#xA;override this.GetRuntimeFields : unit -&gt; System.Collections.Generic.Dictionary&lt;string, System.Reflection.FieldInfo&gt;" Usage="typeBase.GetRuntimeFields " FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyDictionary&lt;string,System.Reflection.FieldInfo&gt; GetRuntimeFields ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;string, class System.Reflection.FieldInfo&gt; GetRuntimeFields() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRuntimeFields () As IReadOnlyDictionary(Of String, FieldInfo)" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeFields : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;string, System.Reflection.FieldInfo&gt;&#xA;override this.GetRuntimeFields : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;string, System.Reflection.FieldInfo&gt;" Usage="typeBase.GetRuntimeFields " FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-2.1;efcore-2.2">System.Collections.Generic.Dictionary&lt;System.String,System.Reflection.FieldInfo&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.Reflection.FieldInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.Dictionary&lt;string,System.Reflection.PropertyInfo&gt; GetRuntimeProperties ();" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.Dictionary`2&lt;string, class System.Reflection.PropertyInfo&gt; GetRuntimeProperties() cil managed" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetRuntimeProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRuntimeProperties () As Dictionary(Of String, PropertyInfo)" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeProperties : unit -&gt; System.Collections.Generic.Dictionary&lt;string, System.Reflection.PropertyInfo&gt;&#xA;override this.GetRuntimeProperties : unit -&gt; System.Collections.Generic.Dictionary&lt;string, System.Reflection.PropertyInfo&gt;" Usage="typeBase.GetRuntimeProperties " FrameworkAlternate="efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyDictionary&lt;string,System.Reflection.PropertyInfo&gt; GetRuntimeProperties ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;string, class System.Reflection.PropertyInfo&gt; GetRuntimeProperties() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRuntimeProperties () As IReadOnlyDictionary(Of String, PropertyInfo)" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeProperties : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;string, System.Reflection.PropertyInfo&gt;&#xA;override this.GetRuntimeProperties : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;string, System.Reflection.PropertyInfo&gt;" Usage="typeBase.GetRuntimeProperties " FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-2.1;efcore-2.2">System.Collections.Generic.Dictionary&lt;System.String,System.Reflection.PropertyInfo&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.Reflection.PropertyInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSnapshottableMembers">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetSnapshottableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetSnapshottableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.GetSnapshottableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Overridable Function GetSnapshottableMembers () As IEnumerable(Of PropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;&#xA;override this.GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="typeBase.GetSnapshottableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase+&lt;GetSnapshottableMembers&gt;d__110))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase+&lt;GetSnapshottableMembers&gt;d__110))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasSharedClrType">
      <MemberSignature Language="C#" Value="public virtual bool HasSharedClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasSharedClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.HasSharedClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasSharedClrType As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasSharedClrType : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.HasSharedClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-5.0">P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.HasSharedClrType</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.HasSharedClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public virtual void Ignore (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Ignore(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Ignore(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Ignore (name As String, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit)" />
      <MemberSignature Language="F#" Value="abstract member Ignore : string * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.Ignore : string * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="typeBase.Ignore (name, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public virtual void Ignore (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Ignore(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Ignore(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Ignore (name As String, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, Optional runConventions As Boolean = true)" />
      <MemberSignature Language="F#" Value="abstract member Ignore : string * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; unit&#xA;override this.Ignore : string * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; unit" Usage="typeBase.Ignore (name, configurationSource, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase derivedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase derivedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.IsAssignableFrom(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (derivedType As TypeBase) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase -&gt; bool&#xA;override this.IsAssignableFrom : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase -&gt; bool" Usage="typeBase.IsAssignableFrom derivedType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="derivedType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="derivedType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIgnored">
      <MemberSignature Language="C#" Value="public virtual bool IsIgnored (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsIgnored(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.IsIgnored(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsIgnored (name As String) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsIgnored : string -&gt; bool&#xA;override this.IsIgnored : string -&gt; bool" Usage="typeBase.IsIgnored name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.IsIgnored(System.String)</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.IsIgnored(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInModel">
      <MemberSignature Language="C#" Value="public abstract bool IsInModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.IsInModel" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInModel As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsInModel : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.IsInModel" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.IsInModel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPropertyBag">
      <MemberSignature Language="C#" Value="public virtual bool IsPropertyBag { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPropertyBag" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.IsPropertyBag" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsPropertyBag As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsPropertyBag : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.IsPropertyBag" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-5.0">P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.IsPropertyBag</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.IsPropertyBag</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty IConventionTypeBase.AddComplexProperty (string name, bool collection, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty(string name, bool collection, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#AddComplexProperty(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddComplexProperty (name As String, collection As Boolean, fromDataAnnotation As Boolean) As IConventionComplexProperty Implements IConventionTypeBase.AddComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty : string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty : string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty (name, collection, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty IConventionTypeBase.AddComplexProperty (string name, Type propertyType, Type targetType, string complexTypeName, bool collection, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty(string name, class System.Type propertyType, class System.Type targetType, string complexTypeName, bool collection, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#AddComplexProperty(System.String,System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddComplexProperty (name As String, propertyType As Type, targetType As Type, complexTypeName As String, collection As Boolean, fromDataAnnotation As Boolean) As IConventionComplexProperty Implements IConventionTypeBase.AddComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty : string * Type * Type * string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty : string * Type * Type * string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty (name, propertyType, targetType, complexTypeName, collection, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty(System.String,System.Type,System.Type,System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetType" Type="System.Type" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="complexTypeName" Type="System.String" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="targetType">To be added.</param>
        <param name="complexTypeName">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty IConventionTypeBase.AddComplexProperty (string name, Type propertyType, System.Reflection.MemberInfo memberInfo, Type targetType, string complexTypeName, bool collection, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty(string name, class System.Type propertyType, class System.Reflection.MemberInfo memberInfo, class System.Type targetType, string complexTypeName, bool collection, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#AddComplexProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddComplexProperty (name As String, propertyType As Type, memberInfo As MemberInfo, targetType As Type, complexTypeName As String, collection As Boolean, fromDataAnnotation As Boolean) As IConventionComplexProperty Implements IConventionTypeBase.AddComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty : string * Type * System.Reflection.MemberInfo * Type * string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty : string * Type * System.Reflection.MemberInfo * Type * string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty (name, propertyType, memberInfo, targetType, complexTypeName, collection, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddComplexProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Type,System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetType" Type="System.Type" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="complexTypeName" Type="System.String" Index="4" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="6" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="targetType">To be added.</param>
        <param name="complexTypeName">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored">
      <MemberSignature Language="C#" Value="void IConventionTypeBase.AddIgnored (string name, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored(string name, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#AddIgnored(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub AddIgnored (name As String, fromDataAnnotation As Boolean) Implements IConventionTypeBase.AddIgnored" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored : string * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored : string * bool -&gt; unit" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored (name, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="string IConventionTypeBase.AddIgnored (string name, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored(string name, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function AddIgnored (name As String, fromDataAnnotation As Boolean) As String Implements IConventionTypeBase.AddIgnored" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored : string * bool -&gt; string&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored : string * bool -&gt; string" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored (name, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="string? IConventionTypeBase.AddIgnored (string name, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddIgnored(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionTypeBase.AddProperty (string name, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty(string name, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#AddProperty(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, fromDataAnnotation As Boolean) As IConventionProperty Implements IConventionTypeBase.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty (name, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionTypeBase.AddProperty (string name, Type propertyType, bool setTypeConfigurationSource, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty(string name, class System.Type propertyType, bool setTypeConfigurationSource, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#AddProperty(System.String,System.Type,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, propertyType As Type, setTypeConfigurationSource As Boolean, fromDataAnnotation As Boolean) As IConventionProperty Implements IConventionTypeBase.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty : string * Type * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty : string * Type * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty (name, propertyType, setTypeConfigurationSource, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty(System.String,System.Type,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="setTypeConfigurationSource" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="setTypeConfigurationSource">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionTypeBase.AddProperty (string name, Type propertyType, System.Reflection.MemberInfo memberInfo, bool setTypeConfigurationSource, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty(string name, class System.Type propertyType, class System.Reflection.MemberInfo memberInfo, bool setTypeConfigurationSource, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#AddProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, propertyType As Type, memberInfo As MemberInfo, setTypeConfigurationSource As Boolean, fromDataAnnotation As Boolean) As IConventionProperty Implements IConventionTypeBase.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty : string * Type * System.Reflection.MemberInfo * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty : string * Type * System.Reflection.MemberInfo * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty (name, propertyType, memberInfo, setTypeConfigurationSource, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.AddProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="setTypeConfigurationSource" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="setTypeConfigurationSource">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionTypeBaseBuilder Implements IConventionTypeBase.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty IConventionTypeBase.FindComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#FindComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindComplexProperty (name As String) As IConventionComplexProperty Implements IConventionTypeBase.FindComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMember">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase IConventionTypeBase.FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMember (name As String) As IConventionPropertyBase Implements IConventionTypeBase.FindMember" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt; IConventionTypeBase.FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMembersInHierarchy (name As String) As IEnumerable(Of IConventionPropertyBase) Implements IConventionTypeBase.FindMembersInHierarchy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindMembersInHierarchy(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionTypeBase.FindProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IConventionProperty Implements IConventionTypeBase.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt; IConventionTypeBase.GetComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#GetComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetComplexProperties () As IEnumerable(Of IConventionComplexProperty) Implements IConventionTypeBase.GetComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt; IConventionTypeBase.GetDeclaredComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#GetDeclaredComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredComplexProperties () As IEnumerable(Of IConventionComplexProperty) Implements IConventionTypeBase.GetDeclaredComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt; IConventionTypeBase.GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredMembers () As IEnumerable(Of IConventionPropertyBase) Implements IConventionTypeBase.GetDeclaredMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; IConventionTypeBase.GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredProperties () As IEnumerable(Of IConventionProperty) Implements IConventionTypeBase.GetDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt; IConventionTypeBase.GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#GetMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetMembers () As IEnumerable(Of IConventionPropertyBase) Implements IConventionTypeBase.GetMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; IConventionTypeBase.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IConventionProperty) Implements IConventionTypeBase.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionModel Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionModel Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IConventionModel Implements IConventionTypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IConventionModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty IConventionTypeBase.RemoveComplexProperty (Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty(class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#RemoveComplexProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveComplexProperty (property As IConventionComplexProperty) As IConventionComplexProperty Implements IConventionTypeBase.RemoveComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty IConventionTypeBase.RemoveComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#RemoveComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveComplexProperty (name As String) As IConventionComplexProperty Implements IConventionTypeBase.RemoveComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionTypeBase.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (property As IReadOnlyProperty) As IConventionProperty Implements IConventionTypeBase.RemoveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionTypeBase.RemoveProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#RemoveProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (name As String) As IConventionProperty Implements IConventionTypeBase.RemoveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.SetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? IConventionTypeBase.SetChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.SetChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy), fromDataAnnotation As Boolean) As Nullable(Of ChangeTrackingStrategy) Implements IConventionTypeBase.SetChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.SetChangeTrackingStrategy (changeTrackingStrategy, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty IMutableTypeBase.AddComplexProperty (string name, bool collection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty(string name, bool collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#AddComplexProperty(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddComplexProperty (name As String, collection As Boolean) As IMutableComplexProperty Implements IMutableTypeBase.AddComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty (name, collection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="collection">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty IMutableTypeBase.AddComplexProperty (string name, Type propertyType, Type targetType, string complexTypeName, bool collection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty(string name, class System.Type propertyType, class System.Type targetType, string complexTypeName, bool collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#AddComplexProperty(System.String,System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddComplexProperty (name As String, propertyType As Type, targetType As Type, complexTypeName As String, collection As Boolean) As IMutableComplexProperty Implements IMutableTypeBase.AddComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty : string * Type * Type * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty : string * Type * Type * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty (name, propertyType, targetType, complexTypeName, collection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty(System.String,System.Type,System.Type,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetType" Type="System.Type" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="complexTypeName" Type="System.String" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="targetType">To be added.</param>
        <param name="complexTypeName">To be added.</param>
        <param name="collection">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty IMutableTypeBase.AddComplexProperty (string name, Type propertyType, System.Reflection.MemberInfo memberInfo, Type targetType, string complexTypeName, bool collection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty(string name, class System.Type propertyType, class System.Reflection.MemberInfo memberInfo, class System.Type targetType, string complexTypeName, bool collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#AddComplexProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddComplexProperty (name As String, propertyType As Type, memberInfo As MemberInfo, targetType As Type, complexTypeName As String, collection As Boolean) As IMutableComplexProperty Implements IMutableTypeBase.AddComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty : string * Type * System.Reflection.MemberInfo * Type * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty : string * Type * System.Reflection.MemberInfo * Type * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty (name, propertyType, memberInfo, targetType, complexTypeName, collection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddComplexProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Type,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetType" Type="System.Type" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="complexTypeName" Type="System.String" Index="4" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="targetType">To be added.</param>
        <param name="complexTypeName">To be added.</param>
        <param name="collection">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored">
      <MemberSignature Language="C#" Value="void IMutableTypeBase.AddIgnored (string name);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored(string name) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#AddIgnored(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddIgnored (name As String) Implements IMutableTypeBase.AddIgnored" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored : string -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored : string -&gt; unit" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored name" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="string IMutableTypeBase.AddIgnored (string name);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored(string name) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function AddIgnored (name As String) As String Implements IMutableTypeBase.AddIgnored" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored : string -&gt; string&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored : string -&gt; string" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored name" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="string? IMutableTypeBase.AddIgnored (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddIgnored(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableTypeBase.AddProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#AddProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String) As IMutableProperty Implements IMutableTypeBase.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableTypeBase.AddProperty (string name, Type propertyType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty(string name, class System.Type propertyType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#AddProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, propertyType As Type) As IMutableProperty Implements IMutableTypeBase.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty : string * Type -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty : string * Type -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty (name, propertyType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableTypeBase.AddProperty (string name, Type propertyType, System.Reflection.MemberInfo memberInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty(string name, class System.Type propertyType, class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#AddProperty(System.String,System.Type,System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, propertyType As Type, memberInfo As MemberInfo) As IMutableProperty Implements IMutableTypeBase.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty : string * Type * System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty : string * Type * System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty (name, propertyType, memberInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.AddProperty(System.String,System.Type,System.Reflection.MemberInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty IMutableTypeBase.FindComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#FindComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindComplexProperty (name As String) As IMutableComplexProperty Implements IMutableTypeBase.FindComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMember">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase IMutableTypeBase.FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMember (name As String) As IMutablePropertyBase Implements IMutableTypeBase.FindMember" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt; IMutableTypeBase.FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMembersInHierarchy (name As String) As IEnumerable(Of IMutablePropertyBase) Implements IMutableTypeBase.FindMembersInHierarchy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindMembersInHierarchy(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableTypeBase.FindProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IMutableProperty Implements IMutableTypeBase.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt; IMutableTypeBase.GetComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#GetComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetComplexProperties () As IEnumerable(Of IMutableComplexProperty) Implements IMutableTypeBase.GetComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt; IMutableTypeBase.GetDeclaredComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#GetDeclaredComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredComplexProperties () As IEnumerable(Of IMutableComplexProperty) Implements IMutableTypeBase.GetDeclaredComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt; IMutableTypeBase.GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredMembers () As IEnumerable(Of IMutablePropertyBase) Implements IMutableTypeBase.GetDeclaredMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; IMutableTypeBase.GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredProperties () As IEnumerable(Of IMutableProperty) Implements IMutableTypeBase.GetDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt; IMutableTypeBase.GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#GetMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetMembers () As IEnumerable(Of IMutablePropertyBase) Implements IMutableTypeBase.GetMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutablePropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; IMutableTypeBase.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IMutableProperty) Implements IMutableTypeBase.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IMutableModel Implements IMutableTypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty IMutableTypeBase.RemoveComplexProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#RemoveComplexProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveComplexProperty (property As IReadOnlyProperty) As IMutableComplexProperty Implements IMutableTypeBase.RemoveComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty IMutableTypeBase.RemoveComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#RemoveComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveComplexProperty (name As String) As IMutableComplexProperty Implements IMutableTypeBase.RemoveComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableTypeBase.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (property As IReadOnlyProperty) As IMutableProperty Implements IMutableTypeBase.RemoveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableTypeBase.RemoveProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#RemoveProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (name As String) As IMutableProperty Implements IMutableTypeBase.RemoveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.SetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="void IMutableTypeBase.SetChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.SetChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy})" />
      <MemberSignature Language="VB.NET" Value="Sub SetChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy)) Implements IMutableTypeBase.SetChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; -&gt; unit" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.SetChangeTrackingStrategy changeTrackingStrategy" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ClrType">
      <MemberSignature Language="C#" Value="Type Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#ClrType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ClrType As Type Implements IReadOnlyTypeBase.ClrType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty IReadOnlyTypeBase.FindComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindComplexProperty (name As String) As IReadOnlyComplexProperty Implements IReadOnlyTypeBase.FindComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty IReadOnlyTypeBase.FindDeclaredComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindDeclaredComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredComplexProperty (name As String) As IReadOnlyComplexProperty Implements IReadOnlyTypeBase.FindDeclaredComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty IReadOnlyTypeBase.FindDeclaredProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredProperty (name As String) As IReadOnlyProperty Implements IReadOnlyTypeBase.FindDeclaredProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindDeclaredProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase IReadOnlyTypeBase.FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMember (name As String) As IReadOnlyPropertyBase Implements IReadOnlyTypeBase.FindMember" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; IReadOnlyTypeBase.FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMembersInHierarchy (name As String) As IEnumerable(Of IReadOnlyPropertyBase) Implements IReadOnlyTypeBase.FindMembersInHierarchy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindMembersInHierarchy(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyTypeBase.FindProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties(class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; propertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindProperties(System.Collections.Generic.IReadOnlyList{System.String})" />
      <MemberSignature Language="VB.NET" Value="Function FindProperties (propertyNames As IReadOnlyList(Of String)) As IReadOnlyList(Of IReadOnlyProperty) Implements IReadOnlyTypeBase.FindProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties propertyNames" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperties(System.Collections.Generic.IReadOnlyList{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IReadOnlyList&lt;System.String&gt;" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyNames">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty IReadOnlyTypeBase.FindProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IReadOnlyProperty Implements IReadOnlyTypeBase.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; IReadOnlyTypeBase.GetComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetComplexProperties () As IEnumerable(Of IReadOnlyComplexProperty) Implements IReadOnlyTypeBase.GetComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; IReadOnlyTypeBase.GetDeclaredComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDeclaredComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredComplexProperties () As IEnumerable(Of IReadOnlyComplexProperty) Implements IReadOnlyTypeBase.GetDeclaredComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; IReadOnlyTypeBase.GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredMembers () As IEnumerable(Of IReadOnlyPropertyBase) Implements IReadOnlyTypeBase.GetDeclaredMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyTypeBase.GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredProperties () As IEnumerable(Of IReadOnlyProperty) Implements IReadOnlyTypeBase.GetDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; IReadOnlyTypeBase.GetDerivedComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDerivedComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedComplexProperties () As IEnumerable(Of IReadOnlyComplexProperty) Implements IReadOnlyTypeBase.GetDerivedComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyTypeBase.GetDerivedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetDerivedProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedProperties () As IEnumerable(Of IReadOnlyProperty) Implements IReadOnlyTypeBase.GetDerivedProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetDerivedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; IReadOnlyTypeBase.GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetMembers () As IEnumerable(Of IReadOnlyPropertyBase) Implements IReadOnlyTypeBase.GetMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyTypeBase.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IReadOnlyProperty) Implements IReadOnlyTypeBase.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IReadOnlyModel Implements IReadOnlyTypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ClrType">
      <MemberSignature Language="C#" Value="Type Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#ClrType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ClrType As Type Implements ITypeBase.ClrType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty ITypeBase.FindComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindComplexProperty (name As String) As IComplexProperty Implements ITypeBase.FindComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindComplexProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IProperty ITypeBase.FindDeclaredProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IProperty Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredProperty (name As String) As IProperty Implements ITypeBase.FindDeclaredProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindDeclaredProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase ITypeBase.FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMember (name As String) As IPropertyBase Implements ITypeBase.FindMember" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IPropertyBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; ITypeBase.FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindMembersInHierarchy (name As String) As IEnumerable(Of IPropertyBase) Implements ITypeBase.FindMembersInHierarchy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindMembersInHierarchy(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IProperty ITypeBase.FindProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IProperty Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IProperty Implements ITypeBase.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; ITypeBase.GetComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetComplexProperties () As IEnumerable(Of IComplexProperty) Implements ITypeBase.GetComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; ITypeBase.GetDeclaredComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetDeclaredComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredComplexProperties () As IEnumerable(Of IComplexProperty) Implements ITypeBase.GetDeclaredComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; ITypeBase.GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredMembers () As IEnumerable(Of IPropertyBase) Implements ITypeBase.GetDeclaredMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ITypeBase.GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredProperties () As IEnumerable(Of IProperty) Implements ITypeBase.GetDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; ITypeBase.GetFlattenedComplexProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetFlattenedComplexProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetFlattenedComplexProperties () As IEnumerable(Of IComplexProperty) Implements ITypeBase.GetFlattenedComplexProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedComplexProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IComplexProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all properties that implement <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" />, including those on complex types.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ITypeBase.GetFlattenedDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetFlattenedDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetFlattenedDeclaredProperties () As IEnumerable(Of IProperty) Implements ITypeBase.GetFlattenedDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all properties declared properties that implement <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IProperty" />, including those on complex types.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ITypeBase.GetFlattenedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetFlattenedProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetFlattenedProperties () As IEnumerable(Of IProperty) Implements ITypeBase.GetFlattenedProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetFlattenedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all properties that implement <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IProperty" />, including those on complex types.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; ITypeBase.GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetMembers () As IEnumerable(Of IPropertyBase) Implements ITypeBase.GetMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ITypeBase.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IProperty) Implements ITypeBase.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; ITypeBase.GetSnapshottableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt; Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#GetSnapshottableMembers" />
      <MemberSignature Language="VB.NET" Value="Function GetSnapshottableMembers () As IEnumerable(Of IPropertyBase) Implements ITypeBase.GetSnapshottableMembers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;" Usage="typeBase.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.GetSnapshottableMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns all properties that implement <see cref="T:Microsoft.EntityFrameworkCore.Metadata.IProperty" />, including those on complex types.
            </summary>
        <returns>The properties.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IModel Implements ITypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IModel" Usage="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Model">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Model Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Model Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Model" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Model As Model" />
      <MemberSignature Language="F#" Value="member this.Model : Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Model" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Model</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Name</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTypeMemberIgnored">
      <MemberSignature Language="C#" Value="public abstract void OnTypeMemberIgnored (string name);" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnTypeMemberIgnored(string name) cil managed" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.OnTypeMemberIgnored(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub OnTypeMemberIgnored (name As String)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member OnTypeMemberIgnored : string -&gt; unit" Usage="typeBase.OnTypeMemberIgnored name" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public abstract string OnTypeMemberIgnored (string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string OnTypeMemberIgnored(string name) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function OnTypeMemberIgnored (name As String) As String" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member OnTypeMemberIgnored : string -&gt; string" Usage="typeBase.OnTypeMemberIgnored name" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public abstract string? OnTypeMemberIgnored (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.SortedDictionary&lt;string,Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedDictionary`2&lt;string, class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Properties" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property Properties As SortedDictionary(Of String, Property)" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.SortedDictionary&lt;string, Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyMetadataChanged">
      <MemberSignature Language="C#" Value="public abstract void PropertyMetadataChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PropertyMetadataChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.PropertyMetadataChanged" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PropertyMetadataChanged ()" />
      <MemberSignature Language="F#" Value="abstract member PropertyMetadataChanged : unit -&gt; unit" Usage="typeBase.PropertyMetadataChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty? RemoveComplexProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty RemoveComplexProperty(class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.RemoveComplexProperty(Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveComplexProperty (property As ComplexProperty) As ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member RemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&#xA;override this.RemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Usage="typeBase.RemoveComplexProperty property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty? RemoveComplexProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty RemoveComplexProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.RemoveComplexProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveComplexProperty (name As String) As ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member RemoveComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&#xA;override this.RemoveComplexProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Usage="typeBase.RemoveComplexProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveIgnored">
      <MemberSignature Language="C#" Value="public virtual void RemoveIgnored (string name);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveIgnored(string name) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.RemoveIgnored(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveIgnored (name As String)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member RemoveIgnored : string -&gt; unit&#xA;override this.RemoveIgnored : string -&gt; unit" Usage="typeBase.RemoveIgnored name" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual string RemoveIgnored (string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string RemoveIgnored(string name) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveIgnored (name As String) As String" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member RemoveIgnored : string -&gt; string&#xA;override this.RemoveIgnored : string -&gt; string" Usage="typeBase.RemoveIgnored name" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public virtual string? RemoveIgnored (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.RemoveIgnored(System.String)</InterfaceMember>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.RemoveIgnored(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.Internal.Property)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveProperty (property As Property) As Property" />
      <MemberSignature Language="F#" Value="abstract member RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="typeBase.RemoveProperty property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? RemoveProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property RemoveProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.RemoveProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveProperty (name As String) As Property" />
      <MemberSignature Language="F#" Value="abstract member RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="typeBase.RemoveProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? SetChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; SetChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy), configurationSource As ConfigurationSource) As Nullable(Of ChangeTrackingStrategy)" />
      <MemberSignature Language="F#" Value="abstract member SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;&#xA;override this.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Usage="typeBase.SetChangeTrackingStrategy (changeTrackingStrategy, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNavigationAccessMode">
      <MemberSignature Language="C#" Value="public virtual void SetNavigationAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNavigationAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.SetNavigationAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetNavigationAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetNavigationAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetNavigationAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="typeBase.SetNavigationAccessMode (propertyAccessMode, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.PropertyAccessMode? SetNavigationAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; SetNavigationAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetNavigationAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As ConfigurationSource) As Nullable(Of PropertyAccessMode)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="abstract member SetNavigationAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;&#xA;override this.SetNavigationAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" Usage="typeBase.SetNavigationAccessMode (propertyAccessMode, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual void SetPropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetPropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.SetPropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetPropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="typeBase.SetPropertyAccessMode (propertyAccessMode, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.PropertyAccessMode? SetPropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; SetPropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetPropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As ConfigurationSource) As Nullable(Of PropertyAccessMode)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;&#xA;override this.SetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" Usage="typeBase.SetPropertyAccessMode (propertyAccessMode, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToEnumerable&lt;T&gt;">
      <MemberSignature Language="C#" Value="protected static System.Collections.Generic.IEnumerable&lt;T&gt; ToEnumerable&lt;T&gt; (T? element) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; ToEnumerable&lt;class T&gt;(!!T element) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.ToEnumerable``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ToEnumerable(Of T As Class) (element As T) As IEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="static member ToEnumerable : 'T -&gt; seq&lt;'T (requires 'T : null)&gt; (requires 'T : null)" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.ToEnumerable element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="T" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="element">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unignore">
      <MemberSignature Language="C#" Value="public virtual void Unignore (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unignore(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.Unignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unignore (name As String)" />
      <MemberSignature Language="F#" Value="abstract member Unignore : string -&gt; unit&#xA;override this.Unignore : string -&gt; unit" Usage="typeBase.Unignore name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.UpdateConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="typeBase.UpdateConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.UpdateConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="typeBase.UpdateConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateClrMember">
      <MemberSignature Language="C#" Value="protected virtual Type? ValidateClrMember (string name, System.Reflection.MemberInfo memberInfo, bool throwOnNameMismatch = true);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type ValidateClrMember(string name, class System.Reflection.MemberInfo memberInfo, bool throwOnNameMismatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase.ValidateClrMember(System.String,System.Reflection.MemberInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ValidateClrMember (name As String, memberInfo As MemberInfo, Optional throwOnNameMismatch As Boolean = true) As Type" />
      <MemberSignature Language="F#" Value="abstract member ValidateClrMember : string * System.Reflection.MemberInfo * bool -&gt; Type&#xA;override this.ValidateClrMember : string * System.Reflection.MemberInfo * bool -&gt; Type" Usage="typeBase.ValidateClrMember (name, memberInfo, throwOnNameMismatch)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="throwOnNameMismatch" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="throwOnNameMismatch">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
