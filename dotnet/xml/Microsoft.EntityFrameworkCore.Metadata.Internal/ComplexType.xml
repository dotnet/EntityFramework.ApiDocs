<Type Name="ComplexType" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType">
  <TypeSignature Language="C#" Value="public class ComplexType : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase, Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType, Microsoft.EntityFrameworkCore.Metadata.IMutableComplexType, Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeComplexType" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ComplexType extends Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IComplexType, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType, class Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexType, class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeComplexType, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType" />
  <TypeSignature Language="VB.NET" Value="Public Class ComplexType&#xA;Inherits TypeBase&#xA;Implements IConventionComplexType, IMutableComplexType, IRuntimeComplexType" />
  <TypeSignature Language="F#" Value="type ComplexType = class&#xA;    inherit TypeBase&#xA;    interface IMutableComplexType&#xA;    interface IReadOnlyComplexType&#xA;    interface IReadOnlyTypeBase&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IMutableTypeBase&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionComplexType&#xA;    interface IConventionTypeBase&#xA;    interface IConventionAnnotatable&#xA;    interface IRuntimeComplexType&#xA;    interface IComplexType&#xA;    interface ITypeBase&#xA;    interface IAnnotatable&#xA;    interface IRuntimeTypeBase" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IComplexType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableComplexType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeComplexType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.ITypeBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ComplexType (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty property, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, type As Type, property As ComplexProperty, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType : string * Type * Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType (name, type, property, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseBuilder">
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder BaseBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder BaseBuilder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.BaseBuilder" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property BaseBuilder As InternalTypeBaseBuilder" />
      <MemberSignature Language="F#" Value="member this.BaseBuilder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.BaseBuilder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType? BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseType As ComplexType" />
      <MemberSignature Language="F#" Value="member this.BaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Builder">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexTypeBuilder Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexTypeBuilder Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Builder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Builder As InternalComplexTypeBuilder" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexTypeBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Builder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexTypeBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty ComplexProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty ComplexProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ComplexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ComplexProperty As ComplexProperty" />
      <MemberSignature Language="F#" Value="member this.ComplexProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ComplexProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructorBinding">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? ConstructorBinding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding ConstructorBinding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ConstructorBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConstructorBinding As InstantiationBinding" />
      <MemberSignature Language="F#" Value="member this.ConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ConstructorBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingEntityType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType ContainingEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType ContainingEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ContainingEntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainingEntityType As EntityType" />
      <MemberSignature Language="F#" Value="member this.ContainingEntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ContainingEntityType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DebugView">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.DebugView" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DebugView As DebugView" />
      <MemberSignature Language="F#" Value="member this.DebugView : Microsoft.EntityFrameworkCore.Infrastructure.DebugView" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.DebugView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Infrastructure.DebugView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMember">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase? FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindMember (name As String) As PropertyBase" />
      <MemberSignature Language="F#" Value="override this.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase" Usage="complexType.FindMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; FindMembersInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; FindMembersInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindMembersInHierarchy (name As String) As IEnumerable(Of PropertyBase)" />
      <MemberSignature Language="F#" Value="override this.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="complexType.FindMembersInHierarchy name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeignKeyProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ForeignKeyProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ForeignKeyProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ForeignKeyProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ForeignKeyProperties As IReadOnlyList(Of IProperty)" />
      <MemberSignature Language="F#" Value="member this.ForeignKeyProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ForeignKeyProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetBaseTypeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetBaseTypeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.GetBaseTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetBaseTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetBaseTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="complexType.GetBaseTypeConfigurationSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorBindingConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetConstructorBindingConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetConstructorBindingConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.GetConstructorBindingConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConstructorBindingConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="complexType.GetConstructorBindingConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetConstructorBindingConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredMembers">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetDeclaredMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetDeclaredMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDeclaredMembers () As IEnumerable(Of PropertyBase)" />
      <MemberSignature Language="F#" Value="override this.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="complexType.GetDeclaredMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType&gt; GetDirectlyDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType&gt; GetDirectlyDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.GetDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDirectlyDerivedTypes () As IEnumerable(Of ComplexType)" />
      <MemberSignature Language="F#" Value="abstract member GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType&gt;&#xA;override this.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType&gt;" Usage="complexType.GetDirectlyDerivedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers () As IEnumerable(Of PropertyBase)" />
      <MemberSignature Language="F#" Value="override this.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="complexType.GetMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRootType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType GetRootType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType GetRootType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.GetRootType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRootType () As ComplexType" />
      <MemberSignature Language="F#" Value="abstract member GetRootType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType&#xA;override this.GetRootType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType" Usage="complexType.GetRootType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetServiceOnlyConstructorBindingConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetServiceOnlyConstructorBindingConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetServiceOnlyConstructorBindingConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.GetServiceOnlyConstructorBindingConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServiceOnlyConstructorBindingConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetServiceOnlyConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetServiceOnlyConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="complexType.GetServiceOnlyConstructorBindingConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType derivedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType derivedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.IsAssignableFrom(Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (derivedType As ComplexType) As Boolean" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType -&gt; bool" Usage="complexType.IsAssignableFrom derivedType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="derivedType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType" />
      </Parameters>
      <Docs>
        <param name="derivedType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInModel">
      <MemberSignature Language="C#" Value="public override bool IsInModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.IsInModel" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsInModel As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsInModel : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.IsInModel" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.IsInModel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IComplexProperty Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IComplexProperty Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IComplexType#ComplexProperty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ComplexProperty As IComplexProperty Implements IComplexType.ComplexProperty" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IComplexProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IComplexType.ComplexProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IComplexProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IConventionAnnotatable#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionAnnotatableBuilder Implements IConventionAnnotatable.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexTypeBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexTypeBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IConventionComplexType#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionComplexTypeBuilder Implements IConventionComplexType.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexTypeBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexTypeBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.ComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.ComplexProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.ComplexProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IConventionComplexType#ComplexProperty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ComplexProperty As IConventionComplexProperty Implements IConventionComplexType.ComplexProperty" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.ComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.ComplexProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionComplexType.ComplexProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.ContainingEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.ContainingEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.ContainingEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IConventionTypeBase#ContainingEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainingEntityType As IConventionEntityType Implements IConventionTypeBase.ContainingEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.ContainingEntityType : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.ContainingEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.ContainingEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableComplexType.ComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty Microsoft.EntityFrameworkCore.Metadata.IMutableComplexType.ComplexProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty Microsoft.EntityFrameworkCore.Metadata.IMutableComplexType.ComplexProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IMutableComplexType#ComplexProperty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ComplexProperty As IMutableComplexProperty Implements IMutableComplexType.ComplexProperty" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableComplexType.ComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableComplexType.ComplexProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableComplexType.ComplexProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableComplexProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.ContainingEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.ContainingEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.ContainingEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#ContainingEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainingEntityType As IMutableEntityType Implements IMutableTypeBase.ContainingEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.ContainingEntityType : Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.ContainingEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.ContainingEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IMutableModel Implements IMutableTypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyComplexType#ComplexProperty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ComplexProperty As IReadOnlyComplexProperty Implements IReadOnlyComplexType.ComplexProperty" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexType.ComplexProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyComplexProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#ContainingEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainingEntityType As IReadOnlyEntityType Implements IReadOnlyTypeBase.ContainingEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.ContainingEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IReadOnlyModel Implements IReadOnlyTypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#ContainingEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainingEntityType As IEntityType Implements ITypeBase.ContainingEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IComplexType.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.ContainingEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IModel Implements ITypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IModel" Usage="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAnnotationSet">
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? annotation, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? oldAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation OnAnnotationSet(string name, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation annotation, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation oldAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.OnAnnotationSet(System.String,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnAnnotationSet (name As String, annotation As IConventionAnnotation, oldAnnotation As IConventionAnnotation) As IConventionAnnotation" />
      <MemberSignature Language="F#" Value="override this.OnAnnotationSet : string * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" Usage="complexType.OnAnnotationSet (name, annotation, oldAnnotation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="annotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" />
        <Parameter Name="oldAnnotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" />
      </Parameters>
      <Docs>
        <param name="name">The key of the set annotation.</param>
        <param name="annotation">The annotation set.</param>
        <param name="oldAnnotation">The old annotation.</param>
        <summary>
                Runs the conventions when an annotation was set or removed.
            </summary>
        <returns>The annotation that was set.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTypeMemberIgnored">
      <MemberSignature Language="C#" Value="public override string? OnTypeMemberIgnored (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string OnTypeMemberIgnored(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.OnTypeMemberIgnored(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function OnTypeMemberIgnored (name As String) As String" />
      <MemberSignature Language="F#" Value="override this.OnTypeMemberIgnored : string -&gt; string" Usage="complexType.OnTypeMemberIgnored name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceOnlyConstructorBinding">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? ServiceOnlyConstructorBinding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding ServiceOnlyConstructorBinding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ServiceOnlyConstructorBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ServiceOnlyConstructorBinding As InstantiationBinding" />
      <MemberSignature Language="F#" Value="member this.ServiceOnlyConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ServiceOnlyConstructorBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBaseType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType? SetBaseType (Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType? newBaseType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType SetBaseType(class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType newBaseType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.SetBaseType(Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetBaseType (newBaseType As ComplexType, configurationSource As ConfigurationSource) As ComplexType" />
      <MemberSignature Language="F#" Value="abstract member SetBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType&#xA;override this.SetBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType" Usage="complexType.SetBaseType (newBaseType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="newBaseType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetConstructorBinding">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? SetConstructorBinding (Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? constructorBinding, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding SetConstructorBinding(class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding constructorBinding, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.SetConstructorBinding(Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetConstructorBinding (constructorBinding As InstantiationBinding, configurationSource As ConfigurationSource) As InstantiationBinding" />
      <MemberSignature Language="F#" Value="abstract member SetConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding&#xA;override this.SetConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" Usage="complexType.SetConstructorBinding (constructorBinding, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructorBinding" Type="Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="constructorBinding">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRemovedFromModel">
      <MemberSignature Language="C#" Value="public virtual void SetRemovedFromModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRemovedFromModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.SetRemovedFromModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRemovedFromModel ()" />
      <MemberSignature Language="F#" Value="abstract member SetRemovedFromModel : unit -&gt; unit&#xA;override this.SetRemovedFromModel : unit -&gt; unit" Usage="complexType.SetRemovedFromModel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetServiceOnlyConstructorBinding">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? SetServiceOnlyConstructorBinding (Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? constructorBinding, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding SetServiceOnlyConstructorBinding(class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding constructorBinding, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.SetServiceOnlyConstructorBinding(Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetServiceOnlyConstructorBinding (constructorBinding As InstantiationBinding, configurationSource As ConfigurationSource) As InstantiationBinding" />
      <MemberSignature Language="F#" Value="abstract member SetServiceOnlyConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding&#xA;override this.SetServiceOnlyConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" Usage="complexType.SetServiceOnlyConstructorBinding (constructorBinding, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructorBinding" Type="Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="constructorBinding">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complexType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueGeneratingProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ValueGeneratingProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ValueGeneratingProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ValueGeneratingProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueGeneratingProperties As IReadOnlyList(Of IProperty)" />
      <MemberSignature Language="F#" Value="member this.ValueGeneratingProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexType.ValueGeneratingProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
