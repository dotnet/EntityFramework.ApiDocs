<Type Name="InternalElementTypeBuilder" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder">
  <TypeSignature Language="C#" Value="public class InternalElementTypeBuilder : Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt;, Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InternalElementTypeBuilder extends Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder`2&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt; implements class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder, class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class InternalElementTypeBuilder&#xA;Inherits AnnotatableBuilder(Of ElementType, InternalModelBuilder)&#xA;Implements IConventionElementTypeBuilder" />
  <TypeSignature Language="F#" Value="type InternalElementTypeBuilder = class&#xA;    inherit AnnotatableBuilder&lt;ElementType, InternalModelBuilder&gt;&#xA;    interface IConventionElementTypeBuilder&#xA;    interface IConventionAnnotatableBuilder" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="TMetadata">Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType</BaseTypeArgument>
      <BaseTypeArgument TypeParamName="TModelBuilder">Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalElementTypeBuilder (Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType element, Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder modelBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType element, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder modelBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (element As ElementType, modelBuilder As InternalModelBuilder)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder : Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType * Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder (element, modelBuilder)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="element" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ElementType" />
        <Parameter Name="modelBuilder" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <param name="modelBuilder">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetConversion">
      <MemberSignature Language="C#" Value="public virtual bool CanSetConversion (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetConversion(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetConversion(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetConversion (converter As ValueConverter, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetConversion (converter, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetConversion">
      <MemberSignature Language="C#" Value="public virtual bool CanSetConversion (Type? providerClrType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetConversion(class System.Type providerClrType, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetConversion(System.Type,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetConversion (providerClrType As Type, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetConversion : Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetConversion : Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetConversion (providerClrType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetConverter">
      <MemberSignature Language="C#" Value="public virtual bool CanSetConverter (Type? converterType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetConverter(class System.Type converterType, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetConverter(System.Type,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetConverter (converterType As Type, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetConverter : Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetConverter : Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetConverter (converterType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetIsRequired">
      <MemberSignature Language="C#" Value="public virtual bool CanSetIsRequired (bool? required, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetIsRequired(valuetype System.Nullable`1&lt;bool&gt; required, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetIsRequired(System.Nullable{System.Boolean},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetIsRequired (required As Nullable(Of Boolean), configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetIsRequired : Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetIsRequired : Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetIsRequired (required, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="required" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="required">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetIsUnicode">
      <MemberSignature Language="C#" Value="public virtual bool CanSetIsUnicode (bool? unicode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetIsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetIsUnicode(System.Nullable{System.Boolean},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetIsUnicode (unicode As Nullable(Of Boolean), configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetIsUnicode : Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetIsUnicode : Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetIsUnicode (unicode, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetMaxLength">
      <MemberSignature Language="C#" Value="public virtual bool CanSetMaxLength (int? maxLength, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetMaxLength(System.Nullable{System.Int32},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetMaxLength (maxLength As Nullable(Of Integer), configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetMaxLength : Nullable&lt;int&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetMaxLength : Nullable&lt;int&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetMaxLength (maxLength, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetPrecision">
      <MemberSignature Language="C#" Value="public virtual bool CanSetPrecision (int? precision, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetPrecision(valuetype System.Nullable`1&lt;int32&gt; precision, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetPrecision(System.Nullable{System.Int32},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetPrecision (precision As Nullable(Of Integer), configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetPrecision : Nullable&lt;int&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetPrecision : Nullable&lt;int&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetPrecision (precision, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetScale">
      <MemberSignature Language="C#" Value="public virtual bool CanSetScale (int? scale, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetScale(valuetype System.Nullable`1&lt;int32&gt; scale, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetScale(System.Nullable{System.Int32},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetScale (scale As Nullable(Of Integer), configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetScale : Nullable&lt;int&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetScale : Nullable&lt;int&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetScale (scale, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetTypeMapping">
      <MemberSignature Language="C#" Value="public virtual bool CanSetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetTypeMapping (typeMapping As CoreTypeMapping, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetTypeMapping (typeMapping, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetValueComparer">
      <MemberSignature Language="C#" Value="public virtual bool CanSetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetValueComparer (comparer As ValueComparer, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetValueComparer (comparer, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetValueComparer">
      <MemberSignature Language="C#" Value="public virtual bool CanSetValueComparer (Type? comparerType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetValueComparer(class System.Type comparerType, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.CanSetValueComparer(System.Type,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetValueComparer (comparerType As Type, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetValueComparer : Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetValueComparer : Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalElementTypeBuilder.CanSetValueComparer (comparerType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConversion">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? HasConversion (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder HasConversion(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.HasConversion(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConversion (converter As ValueConverter, configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.HasConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.HasConversion (converter, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConversion">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? HasConversion (Type? providerClrType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder HasConversion(class System.Type providerClrType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.HasConversion(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConversion (providerClrType As Type, configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasConversion : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.HasConversion : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.HasConversion (providerClrType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConverter">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? HasConverter (Type? converterType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder HasConverter(class System.Type converterType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.HasConverter(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConverter (converterType As Type, configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasConverter : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.HasConverter : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.HasConverter (converterType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasMaxLength">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? HasMaxLength (int? maxLength, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder HasMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.HasMaxLength(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasMaxLength (maxLength As Nullable(Of Integer), configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasMaxLength : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.HasMaxLength : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.HasMaxLength (maxLength, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrecision">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? HasPrecision (int? precision, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder HasPrecision(valuetype System.Nullable`1&lt;int32&gt; precision, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.HasPrecision(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasPrecision (precision As Nullable(Of Integer), configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasPrecision : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.HasPrecision : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.HasPrecision (precision, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasScale">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? HasScale (int? scale, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder HasScale(valuetype System.Nullable`1&lt;int32&gt; scale, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.HasScale(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasScale (scale As Nullable(Of Integer), configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasScale : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.HasScale : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.HasScale (scale, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasTypeMapping">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? HasTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder HasTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.HasTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasTypeMapping (typeMapping As CoreTypeMapping, configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.HasTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.HasTypeMapping (typeMapping, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValueComparer">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? HasValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder HasValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.HasValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasValueComparer (comparer As ValueComparer, configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.HasValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.HasValueComparer (comparer, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValueComparer">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? HasValueComparer (Type? comparerType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder HasValueComparer(class System.Type comparerType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.HasValueComparer(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasValueComparer (comparerType As Type, configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasValueComparer : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.HasValueComparer : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.HasValueComparer (comparerType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequired">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? IsRequired (bool? required, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder IsRequired(valuetype System.Nullable`1&lt;bool&gt; required, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.IsRequired(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsRequired (required As Nullable(Of Boolean), configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member IsRequired : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.IsRequired : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.IsRequired (required, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="required" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="required">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder? IsUnicode (bool? unicode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder IsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.IsUnicode(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsUnicode (unicode As Nullable(Of Boolean), configurationSource As ConfigurationSource) As InternalElementTypeBuilder" />
      <MemberSignature Language="F#" Value="abstract member IsUnicode : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder&#xA;override this.IsUnicode : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder" Usage="internalElementTypeBuilder.IsUnicode (unicode, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetConversion (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetConversion(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetConversion (converter As ValueConverter, fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetConversion" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion (converter, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetConversion (Type? providerClrType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion(class System.Type providerClrType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetConversion(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetConversion (providerClrType As Type, fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetConversion" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion : Type * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion : Type * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion (providerClrType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConversion(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConverter">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetConverter (Type? converterType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConverter(class System.Type converterType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetConverter(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetConverter (converterType As Type, fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConverter : Type * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConverter : Type * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConverter (converterType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetConverter(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsRequired">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetIsRequired (bool? required, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsRequired(valuetype System.Nullable`1&lt;bool&gt; required, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetIsRequired(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetIsRequired (required As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetIsRequired" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsRequired : Nullable&lt;bool&gt; * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsRequired : Nullable&lt;bool&gt; * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsRequired (required, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsRequired(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="required" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="required">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsUnicode">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetIsUnicode (bool? unicode, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetIsUnicode(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetIsUnicode (unicode As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetIsUnicode" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsUnicode : Nullable&lt;bool&gt; * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsUnicode : Nullable&lt;bool&gt; * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsUnicode (unicode, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetIsUnicode(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetMaxLength">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetMaxLength (int? maxLength, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetMaxLength(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetMaxLength (maxLength As Nullable(Of Integer), fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetMaxLength" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetMaxLength : Nullable&lt;int&gt; * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetMaxLength : Nullable&lt;int&gt; * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetMaxLength (maxLength, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetMaxLength(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetPrecision">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetPrecision (int? precision, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetPrecision(valuetype System.Nullable`1&lt;int32&gt; precision, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetPrecision(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetPrecision (precision As Nullable(Of Integer), fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetPrecision" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetPrecision : Nullable&lt;int&gt; * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetPrecision : Nullable&lt;int&gt; * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetPrecision (precision, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetPrecision(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetScale">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetScale (int? scale, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetScale(valuetype System.Nullable`1&lt;int32&gt; scale, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetScale(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetScale (scale As Nullable(Of Integer), fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetScale" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetScale : Nullable&lt;int&gt; * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetScale : Nullable&lt;int&gt; * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetScale (scale, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetScale(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetTypeMapping">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetTypeMapping (typeMapping As CoreTypeMapping, fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetTypeMapping (typeMapping, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetValueComparer (comparer As ValueComparer, fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer (comparer, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer">
      <MemberSignature Language="C#" Value="bool IConventionElementTypeBuilder.CanSetValueComparer (Type? comparerType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer(class System.Type comparerType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#CanSetValueComparer(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetValueComparer (comparerType As Type, fromDataAnnotation As Boolean) As Boolean Implements IConventionElementTypeBuilder.CanSetValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer : Type * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer : Type * bool -&gt; bool" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer (comparerType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.CanSetValueComparer(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasAnnotation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasAnnotation (string? name, object? value, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasAnnotation(string name, object value, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasAnnotation(System.String,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasAnnotation (name As String, value As Object, fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasAnnotation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasAnnotation : string * obj * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasAnnotation : string * obj * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasAnnotation (name, value, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasAnnotation(System.String,System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="value">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasConversion (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter? converter, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasConversion(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasConversion (converter As ValueConverter, fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasConversion" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion (converter, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="converter">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasConversion (Type? providerClrType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion(class System.Type providerClrType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasConversion(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasConversion (providerClrType As Type, fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasConversion" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion : Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion : Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion (providerClrType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConversion(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="providerClrType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConverter">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasConverter (Type? converterType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConverter(class System.Type converterType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasConverter(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasConverter (converterType As Type, fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasConverter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConverter : Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConverter : Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConverter (converterType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasConverter(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="converterType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasMaxLength">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasMaxLength (int? maxLength, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasMaxLength(valuetype System.Nullable`1&lt;int32&gt; maxLength, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasMaxLength(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasMaxLength (maxLength As Nullable(Of Integer), fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasMaxLength" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasMaxLength : Nullable&lt;int&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasMaxLength : Nullable&lt;int&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasMaxLength (maxLength, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasMaxLength(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="maxLength">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNoAnnotation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasNoAnnotation (string? name, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNoAnnotation(string name, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasNoAnnotation(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasNoAnnotation (name As String, fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasNoAnnotation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNoAnnotation : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNoAnnotation : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNoAnnotation (name, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNoAnnotation(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNonNullAnnotation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasNonNullAnnotation (string? name, object? value, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNonNullAnnotation(string name, object value, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasNonNullAnnotation(System.String,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasNonNullAnnotation (name As String, value As Object, fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasNonNullAnnotation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNonNullAnnotation : string * obj * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNonNullAnnotation : string * obj * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNonNullAnnotation (name, value, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasNonNullAnnotation(System.String,System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="value">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasPrecision">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasPrecision (int? precision, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasPrecision(valuetype System.Nullable`1&lt;int32&gt; precision, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasPrecision(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasPrecision (precision As Nullable(Of Integer), fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasPrecision" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasPrecision : Nullable&lt;int&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasPrecision : Nullable&lt;int&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasPrecision (precision, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasPrecision(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="precision">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasScale">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasScale (int? scale, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasScale(valuetype System.Nullable`1&lt;int32&gt; scale, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasScale(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasScale (scale As Nullable(Of Integer), fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasScale" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasScale : Nullable&lt;int&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasScale : Nullable&lt;int&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasScale (scale, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasScale(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasTypeMapping">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasTypeMapping (Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping? typeMapping, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasTypeMapping(class Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping typeMapping, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasTypeMapping (typeMapping As CoreTypeMapping, fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasTypeMapping" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasTypeMapping : Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasTypeMapping (typeMapping, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasTypeMapping(Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeMapping" Type="Microsoft.EntityFrameworkCore.Storage.CoreTypeMapping" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeMapping">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasValueComparer (Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer? comparer, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer(class Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer comparer, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasValueComparer (comparer As ValueComparer, fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer : Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer (comparer, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer(Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.HasValueComparer (Type? comparerType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer(class System.Type comparerType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#HasValueComparer(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasValueComparer (comparerType As Type, fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.HasValueComparer" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer : Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer : Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer (comparerType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.HasValueComparer(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparerType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="comparerType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsRequired">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.IsRequired (bool? required, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsRequired(valuetype System.Nullable`1&lt;bool&gt; required, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#IsRequired(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsRequired (required As Nullable(Of Boolean), fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.IsRequired" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsRequired : Nullable&lt;bool&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsRequired : Nullable&lt;bool&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsRequired (required, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsRequired(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="required" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="required">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsUnicode">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder? IConventionElementTypeBuilder.IsUnicode (bool? unicode, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsUnicode(valuetype System.Nullable`1&lt;bool&gt; unicode, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#IsUnicode(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsUnicode (unicode As Nullable(Of Boolean), fromDataAnnotation As Boolean) As IConventionElementTypeBuilder Implements IConventionElementTypeBuilder.IsUnicode" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsUnicode : Nullable&lt;bool&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsUnicode : Nullable&lt;bool&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="internalElementTypeBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsUnicode (unicode, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.IsUnicode(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="unicode">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.Metadata">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionElementType Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionElementType Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.Metadata" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionElementTypeBuilder#Metadata" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Metadata As IConventionElementType Implements IConventionElementTypeBuilder.Metadata" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.Metadata : Microsoft.EntityFrameworkCore.Metadata.IConventionElementType" Usage="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.Metadata" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder.Metadata</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionElementType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="This">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder This { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder This" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.This" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property This As IConventionElementTypeBuilder" />
      <MemberSignature Language="F#" Value="member this.This : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalElementTypeBuilder.This" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionElementTypeBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
