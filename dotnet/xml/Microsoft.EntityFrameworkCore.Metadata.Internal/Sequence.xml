<Type Name="Sequence" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence">
  <TypeSignature Language="C#" Value="public class Sequence : Microsoft.EntityFrameworkCore.Metadata.IMutableSequence" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Sequence extends System.Object implements class Microsoft.EntityFrameworkCore.Metadata.IMutableSequence, class Microsoft.EntityFrameworkCore.Metadata.ISequence" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" />
  <TypeSignature Language="VB.NET" Value="Public Class Sequence&#xA;Implements IMutableSequence" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="F#" Value="type Sequence = class&#xA;    interface IMutableSequence&#xA;    interface ISequence" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="C#" Value="public class Sequence : Microsoft.EntityFrameworkCore.Metadata.IConventionSequence, Microsoft.EntityFrameworkCore.Metadata.IMutableSequence" FrameworkAlternate="efcore-3.0;efcore-3.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Sequence extends System.Object implements class Microsoft.EntityFrameworkCore.Metadata.IConventionSequence, class Microsoft.EntityFrameworkCore.Metadata.IMutableSequence, class Microsoft.EntityFrameworkCore.Metadata.ISequence" FrameworkAlternate="efcore-3.0;efcore-3.1" />
  <TypeSignature Language="VB.NET" Value="Public Class Sequence&#xA;Implements IConventionSequence, IMutableSequence" FrameworkAlternate="efcore-3.0;efcore-3.1" />
  <TypeSignature Language="F#" Value="type Sequence = class&#xA;    interface IMutableSequence&#xA;    interface ISequence&#xA;    interface IConventionSequence" FrameworkAlternate="efcore-3.0;efcore-3.1" />
  <TypeSignature Language="C#" Value="public class Sequence : Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable, Microsoft.EntityFrameworkCore.Metadata.IConventionSequence, Microsoft.EntityFrameworkCore.Metadata.IMutableSequence" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Sequence extends Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionSequence, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableSequence, class Microsoft.EntityFrameworkCore.Metadata.ISequence" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="VB.NET" Value="Public Class Sequence&#xA;Inherits ConventionAnnotatable&#xA;Implements IConventionSequence, IMutableSequence" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="F#" Value="type Sequence = class&#xA;    inherit ConventionAnnotatable&#xA;    interface IMutableSequence&#xA;    interface ISequence&#xA;    interface IAnnotatable&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionSequence&#xA;    interface IConventionAnnotatable" FrameworkAlternate="efcore-5.0" />
  <TypeSignature Language="C#" Value="public class Sequence : Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable, Microsoft.EntityFrameworkCore.Metadata.IConventionSequence, Microsoft.EntityFrameworkCore.Metadata.IMutableSequence, Microsoft.EntityFrameworkCore.Metadata.ISequence" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Sequence extends Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionSequence, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableSequence, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySequence, class Microsoft.EntityFrameworkCore.Metadata.ISequence" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="VB.NET" Value="Public Class Sequence&#xA;Inherits ConventionAnnotatable&#xA;Implements IConventionSequence, IMutableSequence, ISequence" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="F#" Value="type Sequence = class&#xA;    inherit ConventionAnnotatable&#xA;    interface IMutableSequence&#xA;    interface IReadOnlySequence&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionSequence&#xA;    interface IConventionAnnotatable&#xA;    interface ISequence&#xA;    interface IAnnotatable" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.3.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.11.0</AssemblyVersion>
    <AssemblyVersion>2.2.6.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Infrastructure.ConventionAnnotatable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableSequence</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.ISequence</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionSequence</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlySequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Sequence (Microsoft.EntityFrameworkCore.Metadata.IModel model, string annotationName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.IModel model, string annotationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.#ctor(Microsoft.EntityFrameworkCore.Metadata.IModel,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (model As IModel, annotationName As String)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence : Microsoft.EntityFrameworkCore.Metadata.IModel * string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence (model, annotationName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Obsolete("Use the other constructor")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use the other constructor")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IModel" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="annotationName" Type="System.String" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="annotationName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Sequence (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel model, string annotationName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel model, string annotationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.#ctor(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (model As IReadOnlyModel, annotationName As String)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel * string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence (model, annotationName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Obsolete("Use the other constructor")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use the other constructor")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="annotationName" Type="System.String" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="annotationName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Sequence (Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string schema, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string schema, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.#ctor(Microsoft.EntityFrameworkCore.Metadata.IMutableModel,System.String,System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (model As IMutableModel, name As String, schema As String, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence : Microsoft.EntityFrameworkCore.Metadata.IMutableModel * string * string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence (model, name, schema, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="schema" Type="System.String" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="name">To be added.</param>
        <param name="schema">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Sequence (Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string annotationName, string name, string schema = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string annotationName, string name, string schema) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.#ctor(Microsoft.EntityFrameworkCore.Metadata.IMutableModel,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (model As IMutableModel, annotationName As String, name As String, Optional schema As String = Nothing)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence : Microsoft.EntityFrameworkCore.Metadata.IMutableModel * string * string * string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence (model, annotationName, name, schema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="annotationName" Type="System.String" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="schema" Type="System.String" Index="3" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="annotationName">To be added.</param>
        <param name="name">To be added.</param>
        <param name="schema">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Sequence (string name, string schema, Microsoft.EntityFrameworkCore.Metadata.IModel model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, string schema, class Microsoft.EntityFrameworkCore.Metadata.IModel model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.#ctor(System.String,System.String,Microsoft.EntityFrameworkCore.Metadata.IModel,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, schema As String, model As IModel, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence : string * string * Microsoft.EntityFrameworkCore.Metadata.IModel * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence (name, schema, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="schema" Type="System.String" Index="1" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IModel" Index="2" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="schema">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Sequence (string name, string? schema, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, string schema, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.#ctor(System.String,System.String,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, schema As String, model As IReadOnlyModel, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence : string * string * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence (name, schema, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="schema" Type="System.String" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="schema">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSequence">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence AddSequence (Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string schema, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence AddSequence(class Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string schema, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.AddSequence(Microsoft.EntityFrameworkCore.Metadata.IMutableModel,System.String,System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddSequence (model As IMutableModel, name As String, schema As String, configurationSource As ConfigurationSource) As Sequence" />
      <MemberSignature Language="F#" Value="static member AddSequence : Microsoft.EntityFrameworkCore.Metadata.IMutableModel * string * string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.AddSequence (model, name, schema, configurationSource)" />
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence AddSequence (Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string? schema, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="schema" Type="System.String" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="name">To be added.</param>
        <param name="schema">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Builder">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.Builders.Internal.InternalSequenceBuilder Builder { get; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.Internal.InternalSequenceBuilder Builder" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Builder" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Builder As InternalSequenceBuilder" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.Internal.InternalSequenceBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Builder" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSequenceBuilder Builder { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSequenceBuilder Builder" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Builder As InternalSequenceBuilder" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSequenceBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Builder" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.Builders.Internal.InternalSequenceBuilder</ReturnType>
        <ReturnType FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Metadata.Internal.InternalSequenceBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClrType">
      <MemberSignature Language="C#" Value="public virtual Type ClrType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.ClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ClrType As Type" />
      <MemberSignature Language="F#" Value="member this.ClrType : Type with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.ClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.ClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0">
          <AttributeName Language="C#">[System.Obsolete("Use Type")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use Type")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultClrType">
      <MemberSignature Language="C#" Value="public static readonly Type DefaultClrType;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type DefaultClrType" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultClrType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultClrType As Type " />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultClrType" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultIncrementBy">
      <MemberSignature Language="C#" Value="public const int DefaultIncrementBy = 1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultIncrementBy = (1)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultIncrementBy" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultIncrementBy As Integer  = 1" />
      <MemberSignature Language="F#" Value="val mutable DefaultIncrementBy : int" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultIncrementBy" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultIsCyclic">
      <MemberSignature Language="C#" Value="public static readonly bool DefaultIsCyclic;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly bool DefaultIsCyclic" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultIsCyclic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultIsCyclic As Boolean " />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultIsCyclic : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultIsCyclic" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaxValue">
      <MemberSignature Language="C#" Value="public static readonly long? DefaultMaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Nullable`1&lt;int64&gt; DefaultMaxValue" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultMaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultMaxValue As Nullable(Of Long) " />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultMaxValue : Nullable&lt;int64&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultMaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinValue">
      <MemberSignature Language="C#" Value="public static readonly long? DefaultMinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Nullable`1&lt;int64&gt; DefaultMinValue" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultMinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultMinValue As Nullable(Of Long) " />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultMinValue : Nullable&lt;int64&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultMinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStartValue">
      <MemberSignature Language="C#" Value="public const int DefaultStartValue = 1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultStartValue = (1)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultStartValue" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultStartValue As Integer  = 1" />
      <MemberSignature Language="F#" Value="val mutable DefaultStartValue : int" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.DefaultStartValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSequence">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.ISequence FindSequence (Microsoft.EntityFrameworkCore.Metadata.IModel model, string name, string schema);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.ISequence FindSequence(class Microsoft.EntityFrameworkCore.Metadata.IModel model, string name, string schema) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.FindSequence(Microsoft.EntityFrameworkCore.Metadata.IModel,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindSequence (model As IModel, name As String, schema As String) As ISequence" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="static member FindSequence : Microsoft.EntityFrameworkCore.Metadata.IModel * string * string -&gt; Microsoft.EntityFrameworkCore.Metadata.ISequence" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.FindSequence (model, name, schema)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence FindSequence (Microsoft.EntityFrameworkCore.Metadata.IModel model, string name, string schema);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence FindSequence(class Microsoft.EntityFrameworkCore.Metadata.IModel model, string name, string schema) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindSequence (model As IModel, name As String, schema As String) As Sequence" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="static member FindSequence : Microsoft.EntityFrameworkCore.Metadata.IModel * string * string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.FindSequence (model, name, schema)" FrameworkAlternate="efcore-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">Microsoft.EntityFrameworkCore.Metadata.ISequence</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IModel" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="schema" Type="System.String" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="name">To be added.</param>
        <param name="schema">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSequence">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.ISequence? FindSequence (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel model, string name, string? schema);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.ISequence FindSequence(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel model, string name, string schema) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.FindSequence(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindSequence (model As IReadOnlyModel, name As String, schema As String) As ISequence" />
      <MemberSignature Language="F#" Value="static member FindSequence : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel * string * string -&gt; Microsoft.EntityFrameworkCore.Metadata.ISequence" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.FindSequence (model, name, schema)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ISequence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="schema" Type="System.String" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="name">To be added.</param>
        <param name="schema">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetClrTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetClrTypeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetClrTypeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetClrTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClrTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetClrTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetClrTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="sequence.GetClrTypeConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.GetClrTypeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0">
          <AttributeName Language="C#">[System.Obsolete("Use GetTypeConfigurationSource")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use GetTypeConfigurationSource")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource GetConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigurationSource () As ConfigurationSource" />
      <MemberSignature Language="F#" Value="abstract member GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&#xA;override this.GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Usage="sequence.GetConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.GetConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIncrementByConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetIncrementByConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetIncrementByConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetIncrementByConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIncrementByConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIncrementByConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetIncrementByConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="sequence.GetIncrementByConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.GetIncrementByConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsCyclicConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetIsCyclicConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetIsCyclicConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetIsCyclicConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsCyclicConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsCyclicConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetIsCyclicConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="sequence.GetIsCyclicConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.GetIsCyclicConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxValueConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetMaxValueConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetMaxValueConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetMaxValueConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMaxValueConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetMaxValueConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetMaxValueConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="sequence.GetMaxValueConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.GetMaxValueConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMinValueConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetMinValueConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetMinValueConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetMinValueConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMinValueConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetMinValueConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetMinValueConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="sequence.GetMinValueConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.GetMinValueConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSequences">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence&gt; GetSequences (Microsoft.EntityFrameworkCore.Metadata.IModel model);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence&gt; GetSequences(class Microsoft.EntityFrameworkCore.Metadata.IModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetSequences(Microsoft.EntityFrameworkCore.Metadata.IModel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSequences (model As IModel) As IEnumerable(Of Sequence)" />
      <MemberSignature Language="F#" Value="static member GetSequences : Microsoft.EntityFrameworkCore.Metadata.IModel -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetSequences model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IModel" Index="0" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSequences">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ISequence&gt; GetSequences (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel model);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.ISequence&gt; GetSequences(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetSequences(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSequences (model As IReadOnlyModel) As IEnumerable(Of ISequence)" />
      <MemberSignature Language="F#" Value="static member GetSequences : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.ISequence&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetSequences model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ISequence&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSequences">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence&gt; GetSequences (Microsoft.EntityFrameworkCore.Metadata.IModel model, string annotationPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence&gt; GetSequences(class Microsoft.EntityFrameworkCore.Metadata.IModel model, string annotationPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetSequences(Microsoft.EntityFrameworkCore.Metadata.IModel,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSequences (model As IModel, annotationPrefix As String) As IEnumerable(Of Sequence)" />
      <MemberSignature Language="F#" Value="static member GetSequences : Microsoft.EntityFrameworkCore.Metadata.IModel * string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetSequences (model, annotationPrefix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IModel" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="annotationPrefix" Type="System.String" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="annotationPrefix">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStartValueConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetStartValueConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetStartValueConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetStartValueConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStartValueConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetStartValueConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetStartValueConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="sequence.GetStartValueConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.GetStartValueConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetTypeConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetTypeConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.GetTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="sequence.GetTypeConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.GetTypeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public virtual int IncrementBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IncrementBy" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.IncrementBy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IncrementBy As Integer" />
      <MemberSignature Language="F#" Value="member this.IncrementBy : int with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.IncrementBy" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.IncrementBy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCyclic">
      <MemberSignature Language="C#" Value="public virtual bool IsCyclic { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCyclic" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.IsCyclic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsCyclic As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsCyclic : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.IsCyclic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.IsCyclic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInModel">
      <MemberSignature Language="C#" Value="public virtual bool IsInModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.IsInModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInModel As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsInModel : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.IsInModel" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.IsInModel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Indicates whether the sequence is read-only.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public virtual long? MaxValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; MaxValue" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaxValue As Nullable(Of Long)" />
      <MemberSignature Language="F#" Value="member this.MaxValue : Nullable&lt;int64&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.MaxValue" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.MaxValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionSequenceBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionSequenceBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IConventionSequence#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionSequenceBuilder Implements IConventionSequence.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionSequenceBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionSequenceBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionModel Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionModel Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IConventionSequence#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IConventionModel Implements IConventionSequence.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Model : Microsoft.EntityFrameworkCore.Metadata.IConventionModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType">
      <MemberSignature Language="C#" Value="void IConventionSequence.SetClrType (Type clrType, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType(class System.Type clrType, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IConventionSequence#SetClrType(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub SetClrType (clrType As Type, fromDataAnnotation As Boolean) Implements IConventionSequence.SetClrType" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType : Type * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType : Type * bool -&gt; unit" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType (clrType, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Type IConventionSequence.SetClrType (Type type, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType(class System.Type type, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0" />
      <MemberSignature Language="VB.NET" Value="Function SetClrType (type As Type, fromDataAnnotation As Boolean) As Type Implements IConventionSequence.SetClrType" FrameworkAlternate="efcore-5.0;efcore-6.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType : Type * bool -&gt; Type" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType (type, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0" />
      <MemberSignature Language="C#" Value="Type? IConventionSequence.SetClrType (Type? type, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetClrType(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0">System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      </Parameters>
      <Docs>
        <param name="clrType">To be added.</param>
        <param name="type">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy">
      <MemberSignature Language="C#" Value="void IConventionSequence.SetIncrementBy (int? incrementBy, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy(valuetype System.Nullable`1&lt;int32&gt; incrementBy, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IConventionSequence#SetIncrementBy(System.Nullable{System.Int32},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub SetIncrementBy (incrementBy As Nullable(Of Integer), fromDataAnnotation As Boolean) Implements IConventionSequence.SetIncrementBy" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy : Nullable&lt;int&gt; * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy : Nullable&lt;int&gt; * bool -&gt; unit" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy (incrementBy, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="int? IConventionSequence.SetIncrementBy (int? incrementBy, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy(valuetype System.Nullable`1&lt;int32&gt; incrementBy, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function SetIncrementBy (incrementBy As Nullable(Of Integer), fromDataAnnotation As Boolean) As Nullable(Of Integer) Implements IConventionSequence.SetIncrementBy" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy : Nullable&lt;int&gt; * bool -&gt; Nullable&lt;int&gt;" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy (incrementBy, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIncrementBy(System.Nullable{System.Int32},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="incrementBy" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="incrementBy">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic">
      <MemberSignature Language="C#" Value="void IConventionSequence.SetIsCyclic (bool? cyclic, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic(valuetype System.Nullable`1&lt;bool&gt; cyclic, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IConventionSequence#SetIsCyclic(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub SetIsCyclic (cyclic As Nullable(Of Boolean), fromDataAnnotation As Boolean) Implements IConventionSequence.SetIsCyclic" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic : Nullable&lt;bool&gt; * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic : Nullable&lt;bool&gt; * bool -&gt; unit" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic (cyclic, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="bool? IConventionSequence.SetIsCyclic (bool? cyclic, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic(valuetype System.Nullable`1&lt;bool&gt; cyclic, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function SetIsCyclic (cyclic As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Nullable(Of Boolean) Implements IConventionSequence.SetIsCyclic" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic (cyclic, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetIsCyclic(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cyclic" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="cyclic">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue">
      <MemberSignature Language="C#" Value="void IConventionSequence.SetMaxValue (long? maxValue, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue(valuetype System.Nullable`1&lt;int64&gt; maxValue, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IConventionSequence#SetMaxValue(System.Nullable{System.Int64},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub SetMaxValue (maxValue As Nullable(Of Long), fromDataAnnotation As Boolean) Implements IConventionSequence.SetMaxValue" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue : Nullable&lt;int64&gt; * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue : Nullable&lt;int64&gt; * bool -&gt; unit" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue (maxValue, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="long? IConventionSequence.SetMaxValue (long? maxValue, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int64&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue(valuetype System.Nullable`1&lt;int64&gt; maxValue, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function SetMaxValue (maxValue As Nullable(Of Long), fromDataAnnotation As Boolean) As Nullable(Of Long) Implements IConventionSequence.SetMaxValue" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue : Nullable&lt;int64&gt; * bool -&gt; Nullable&lt;int64&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue : Nullable&lt;int64&gt; * bool -&gt; Nullable&lt;int64&gt;" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue (maxValue, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMaxValue(System.Nullable{System.Int64},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Nullable&lt;System.Int64&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="maxValue">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue">
      <MemberSignature Language="C#" Value="void IConventionSequence.SetMinValue (long? minValue, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue(valuetype System.Nullable`1&lt;int64&gt; minValue, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IConventionSequence#SetMinValue(System.Nullable{System.Int64},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub SetMinValue (minValue As Nullable(Of Long), fromDataAnnotation As Boolean) Implements IConventionSequence.SetMinValue" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue : Nullable&lt;int64&gt; * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue : Nullable&lt;int64&gt; * bool -&gt; unit" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue (minValue, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="long? IConventionSequence.SetMinValue (long? minValue, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int64&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue(valuetype System.Nullable`1&lt;int64&gt; minValue, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function SetMinValue (minValue As Nullable(Of Long), fromDataAnnotation As Boolean) As Nullable(Of Long) Implements IConventionSequence.SetMinValue" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue : Nullable&lt;int64&gt; * bool -&gt; Nullable&lt;int64&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue : Nullable&lt;int64&gt; * bool -&gt; Nullable&lt;int64&gt;" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue (minValue, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetMinValue(System.Nullable{System.Int64},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Nullable&lt;System.Int64&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="minValue">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue">
      <MemberSignature Language="C#" Value="void IConventionSequence.SetStartValue (long? startValue, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue(valuetype System.Nullable`1&lt;int64&gt; startValue, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IConventionSequence#SetStartValue(System.Nullable{System.Int64},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub SetStartValue (startValue As Nullable(Of Long), fromDataAnnotation As Boolean) Implements IConventionSequence.SetStartValue" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue : Nullable&lt;int64&gt; * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue : Nullable&lt;int64&gt; * bool -&gt; unit" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue (startValue, fromDataAnnotation)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="long? IConventionSequence.SetStartValue (long? startValue, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int64&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue(valuetype System.Nullable`1&lt;int64&gt; startValue, bool fromDataAnnotation) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Function SetStartValue (startValue As Nullable(Of Long), fromDataAnnotation As Boolean) As Nullable(Of Long) Implements IConventionSequence.SetStartValue" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue : Nullable&lt;int64&gt; * bool -&gt; Nullable&lt;int64&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue : Nullable&lt;int64&gt; * bool -&gt; Nullable&lt;int64&gt;" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue (startValue, fromDataAnnotation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetStartValue(System.Nullable{System.Int64},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startValue" Type="System.Nullable&lt;System.Int64&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="startValue">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetType">
      <MemberSignature Language="C#" Value="Type IConventionSequence.SetType (Type type, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetType(class System.Type type, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IConventionSequence#SetType(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetType (type As Type, fromDataAnnotation As Boolean) As Type Implements IConventionSequence.SetType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetType : Type * bool -&gt; Type&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetType : Type * bool -&gt; Type" Usage="sequence.Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetType (type, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Type? IConventionSequence.SetType (Type? type, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionSequence.SetType(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#IMutableSequence#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IMutableModel Implements IMutableSequence.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.Model : Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ISequence.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ISequence.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ISequence.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Microsoft#EntityFrameworkCore#Metadata#ISequence#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IModel Implements ISequence.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ISequence.Model : Microsoft.EntityFrameworkCore.Metadata.IModel" Usage="Microsoft.EntityFrameworkCore.Metadata.ISequence.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.ISequence.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public virtual long? MinValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; MinValue" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MinValue As Nullable(Of Long)" />
      <MemberSignature Language="F#" Value="member this.MinValue : Nullable&lt;int64&gt; with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.MinValue" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.MinValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Model">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Model Model { get; }" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Model Model" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Model" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Model As Model" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="F#" Value="member this.Model : Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Model" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IMutableModel Model { get; }" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableModel Model" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Model As IMutableModel" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="member this.Model : Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Model" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IModel Model { get; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IModel Model" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Model As IModel" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="member this.Model : Microsoft.EntityFrameworkCore.Metadata.IModel" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Model" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Model { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Model" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Model As IReadOnlyModel" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.Model : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Model" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1">P:Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.Model</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-5.0">P:Microsoft.EntityFrameworkCore.Metadata.ISequence.Model</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlySequence.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2">Microsoft.EntityFrameworkCore.Metadata.Internal.Model</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">Microsoft.EntityFrameworkCore.Metadata.IMutableModel</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IModel</ReturnType>
        <ReturnType FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelSchema">
      <MemberSignature Language="C#" Value="public virtual string? ModelSchema { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ModelSchema" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.ModelSchema" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModelSchema As String" />
      <MemberSignature Language="F#" Value="member this.ModelSchema : string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.ModelSchema" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlySequence.ModelSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Name" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual string Name { get; set; }" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Name As String" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Name" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">P:Microsoft.EntityFrameworkCore.Metadata.ISequence.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSequence">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.ISequence RemoveSequence (Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string schema = default);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.ISequence RemoveSequence(class Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string schema) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.RemoveSequence(Microsoft.EntityFrameworkCore.Metadata.IMutableModel,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveSequence (model As IMutableModel, name As String, Optional schema As String = Nothing) As ISequence" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="static member RemoveSequence : Microsoft.EntityFrameworkCore.Metadata.IMutableModel * string * string -&gt; Microsoft.EntityFrameworkCore.Metadata.ISequence" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.RemoveSequence (model, name, schema)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence RemoveSequence (Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string schema);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence RemoveSequence(class Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string schema) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveSequence (model As IMutableModel, name As String, schema As String) As Sequence" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="static member RemoveSequence : Microsoft.EntityFrameworkCore.Metadata.IMutableModel * string * string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.RemoveSequence (model, name, schema)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence? RemoveSequence (Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, string name, string? schema);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">Microsoft.EntityFrameworkCore.Metadata.ISequence</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="schema" Type="System.String" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="name">To be added.</param>
        <param name="schema">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Schema">
      <MemberSignature Language="C#" Value="public virtual string Schema { get; }" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string Schema" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Schema" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Schema As String" />
      <MemberSignature Language="F#" Value="member this.Schema : string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Schema" />
      <MemberSignature Language="C#" Value="public virtual string? Schema { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">P:Microsoft.EntityFrameworkCore.Metadata.ISequence.Schema</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlySequence.Schema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClrType">
      <MemberSignature Language="C#" Value="public virtual void SetClrType (Type clrType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetClrType(class System.Type clrType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetClrType(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetClrType (clrType As Type, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="sequence.SetClrType (clrType, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Type SetClrType (Type type, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetClrType(class System.Type type, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetClrType (type As Type, configurationSource As ConfigurationSource) As Type" FrameworkAlternate="efcore-5.0;efcore-6.0" />
      <MemberSignature Language="F#" Value="abstract member SetClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetClrType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="sequence.SetClrType (type, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0" />
      <MemberSignature Language="C#" Value="public virtual Type? SetClrType (Type? type, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0">
          <AttributeName Language="C#">[System.Obsolete("Use SetType")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use SetType")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0">System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      </Parameters>
      <Docs>
        <param name="clrType">To be added.</param>
        <param name="type">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIncrementBy">
      <MemberSignature Language="C#" Value="public virtual void SetIncrementBy (int? incrementBy, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIncrementBy(valuetype System.Nullable`1&lt;int32&gt; incrementBy, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetIncrementBy(System.Nullable{System.Int32},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIncrementBy (incrementBy As Nullable(Of Integer), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetIncrementBy : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetIncrementBy : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="sequence.SetIncrementBy (incrementBy, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual int? SetIncrementBy (int? incrementBy, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int32&gt; SetIncrementBy(valuetype System.Nullable`1&lt;int32&gt; incrementBy, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetIncrementBy (incrementBy As Nullable(Of Integer), configurationSource As ConfigurationSource) As Nullable(Of Integer)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetIncrementBy : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;&#xA;override this.SetIncrementBy : Nullable&lt;int&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int&gt;" Usage="sequence.SetIncrementBy (incrementBy, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="incrementBy" Type="System.Nullable&lt;System.Int32&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="incrementBy">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsCyclic">
      <MemberSignature Language="C#" Value="public virtual void SetIsCyclic (bool? cyclic, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsCyclic(valuetype System.Nullable`1&lt;bool&gt; cyclic, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetIsCyclic(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsCyclic (cyclic As Nullable(Of Boolean), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetIsCyclic : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetIsCyclic : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="sequence.SetIsCyclic (cyclic, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual bool? SetIsCyclic (bool? cyclic, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; SetIsCyclic(valuetype System.Nullable`1&lt;bool&gt; cyclic, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetIsCyclic (cyclic As Nullable(Of Boolean), configurationSource As ConfigurationSource) As Nullable(Of Boolean)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetIsCyclic : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;&#xA;override this.SetIsCyclic : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;" Usage="sequence.SetIsCyclic (cyclic, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cyclic" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="cyclic">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMaxValue">
      <MemberSignature Language="C#" Value="public virtual void SetMaxValue (long? maxValue, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMaxValue(valuetype System.Nullable`1&lt;int64&gt; maxValue, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetMaxValue(System.Nullable{System.Int64},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMaxValue (maxValue As Nullable(Of Long), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetMaxValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetMaxValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="sequence.SetMaxValue (maxValue, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual long? SetMaxValue (long? maxValue, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int64&gt; SetMaxValue(valuetype System.Nullable`1&lt;int64&gt; maxValue, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetMaxValue (maxValue As Nullable(Of Long), configurationSource As ConfigurationSource) As Nullable(Of Long)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetMaxValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int64&gt;&#xA;override this.SetMaxValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int64&gt;" Usage="sequence.SetMaxValue (maxValue, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Nullable&lt;System.Int64&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="maxValue">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMinValue">
      <MemberSignature Language="C#" Value="public virtual void SetMinValue (long? minValue, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMinValue(valuetype System.Nullable`1&lt;int64&gt; minValue, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetMinValue(System.Nullable{System.Int64},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMinValue (minValue As Nullable(Of Long), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetMinValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetMinValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="sequence.SetMinValue (minValue, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual long? SetMinValue (long? minValue, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int64&gt; SetMinValue(valuetype System.Nullable`1&lt;int64&gt; minValue, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetMinValue (minValue As Nullable(Of Long), configurationSource As ConfigurationSource) As Nullable(Of Long)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetMinValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int64&gt;&#xA;override this.SetMinValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int64&gt;" Usage="sequence.SetMinValue (minValue, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Nullable&lt;System.Int64&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="minValue">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetName">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence SetName (Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence sequence, string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence SetName(class Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, class Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence sequence, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetName(Microsoft.EntityFrameworkCore.Metadata.IMutableModel,Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetName (model As IMutableModel, sequence As Sequence, name As String) As Sequence" />
      <MemberSignature Language="F#" Value="static member SetName : Microsoft.EntityFrameworkCore.Metadata.IMutableModel * Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence * string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetName (model, sequence, name)" />
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence? SetName (Microsoft.EntityFrameworkCore.Metadata.IMutableModel model, Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence sequence, string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="sequence" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <param name="sequence">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRemovedFromModel">
      <MemberSignature Language="C#" Value="public virtual void SetRemovedFromModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRemovedFromModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetRemovedFromModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRemovedFromModel ()" />
      <MemberSignature Language="F#" Value="abstract member SetRemovedFromModel : unit -&gt; unit&#xA;override this.SetRemovedFromModel : unit -&gt; unit" Usage="sequence.SetRemovedFromModel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStartValue">
      <MemberSignature Language="C#" Value="public virtual void SetStartValue (long? startValue, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStartValue(valuetype System.Nullable`1&lt;int64&gt; startValue, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetStartValue(System.Nullable{System.Int64},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetStartValue (startValue As Nullable(Of Long), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetStartValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetStartValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="sequence.SetStartValue (startValue, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual long? SetStartValue (long? startValue, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;int64&gt; SetStartValue(valuetype System.Nullable`1&lt;int64&gt; startValue, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetStartValue (startValue As Nullable(Of Long), configurationSource As ConfigurationSource) As Nullable(Of Long)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetStartValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int64&gt;&#xA;override this.SetStartValue : Nullable&lt;int64&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;int64&gt;" Usage="sequence.SetStartValue (startValue, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startValue" Type="System.Nullable&lt;System.Int64&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="startValue">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetType">
      <MemberSignature Language="C#" Value="public virtual Type SetType (Type type, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type SetType(class System.Type type, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SetType(System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetType (type As Type, configurationSource As ConfigurationSource) As Type" />
      <MemberSignature Language="F#" Value="abstract member SetType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type&#xA;override this.SetType : Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Type" Usage="sequence.SetType (type, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Type? SetType (Type? type, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartValue">
      <MemberSignature Language="C#" Value="public virtual long StartValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 StartValue" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.StartValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property StartValue As Long" />
      <MemberSignature Language="F#" Value="member this.StartValue : int64 with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.StartValue" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.StartValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportedTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IReadOnlyCollection&lt;Type&gt; SupportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IReadOnlyCollection`1&lt;class System.Type&gt; SupportedTypes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SupportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportedTypes As IReadOnlyCollection(Of Type)" />
      <MemberSignature Language="F#" Value="static member SupportedTypes : System.Collections.Generic.IReadOnlyCollection&lt;Type&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.SupportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyCollection&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="sequence.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Type As Type" />
      <MemberSignature Language="F#" Value="member this.Type : Type with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.Type" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableSequence.Type</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.Sequence.UpdateConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="sequence.UpdateConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.Relational</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
