<Type Name="EntityType" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType">
  <TypeSignature Language="C#" Value="public class EntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.ConventionalAnnotatable, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" FrameworkAlternate="efcore-1.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EntityType extends Microsoft.EntityFrameworkCore.Metadata.Internal.ConventionalAnnotatable implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" FrameworkAlternate="efcore-1.0" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" />
  <TypeSignature Language="VB.NET" Value="Public Class EntityType&#xA;Inherits ConventionalAnnotatable&#xA;Implements IMutableEntityType" FrameworkAlternate="efcore-1.0" />
  <TypeSignature Language="F#" Value="type EntityType = class&#xA;    inherit ConventionalAnnotatable&#xA;    interface IMutableEntityType&#xA;    interface IEntityType&#xA;    interface IAnnotatable&#xA;    interface IMutableAnnotatable" FrameworkAlternate="efcore-1.0" />
  <TypeSignature Language="C#" Value="public class EntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EntityType extends Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType, class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="VB.NET" Value="Public Class EntityType&#xA;Inherits TypeBase&#xA;Implements IMutableEntityType" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="F#" Value="type EntityType = class&#xA;    inherit TypeBase&#xA;    interface IMutableEntityType&#xA;    interface IEntityType&#xA;    interface ITypeBase&#xA;    interface IAnnotatable&#xA;    interface IMutableTypeBase&#xA;    interface IMutableAnnotatable" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
  <TypeSignature Language="C#" Value="public class EntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EntityType extends Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType, class Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType, class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="VB.NET" Value="Public Class EntityType&#xA;Inherits TypeBase&#xA;Implements IConventionEntityType, IMutableEntityType" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="F#" Value="type EntityType = class&#xA;    inherit TypeBase&#xA;    interface IMutableEntityType&#xA;    interface IEntityType&#xA;    interface ITypeBase&#xA;    interface IAnnotatable&#xA;    interface IMutableTypeBase&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionEntityType&#xA;    interface IConventionTypeBase&#xA;    interface IConventionAnnotatable" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
  <TypeSignature Language="C#" Value="public class EntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EntityType extends Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType, class Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType, class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-6.0;efcore-7.0" />
  <TypeSignature Language="VB.NET" Value="Public Class EntityType&#xA;Inherits TypeBase&#xA;Implements IConventionEntityType, IMutableEntityType, IRuntimeEntityType" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
  <TypeSignature Language="F#" Value="type EntityType = class&#xA;    inherit TypeBase&#xA;    interface IMutableEntityType&#xA;    interface IReadOnlyEntityType&#xA;    interface IReadOnlyTypeBase&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IMutableTypeBase&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionEntityType&#xA;    interface IConventionTypeBase&#xA;    interface IConventionAnnotatable&#xA;    interface IRuntimeEntityType&#xA;    interface IEntityType&#xA;    interface ITypeBase&#xA;    interface IAnnotatable" FrameworkAlternate="efcore-6.0;efcore-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EntityType extends Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase implements class Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable, class Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType, class Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType, class Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType, class Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase, class Microsoft.EntityFrameworkCore.Metadata.ITypeBase" FrameworkAlternate="efcore-8.0" />
  <TypeSignature Language="F#" Value="type EntityType = class&#xA;    inherit TypeBase&#xA;    interface IMutableEntityType&#xA;    interface IReadOnlyEntityType&#xA;    interface IReadOnlyTypeBase&#xA;    interface IReadOnlyAnnotatable&#xA;    interface IMutableTypeBase&#xA;    interface IMutableAnnotatable&#xA;    interface IConventionEntityType&#xA;    interface IConventionTypeBase&#xA;    interface IConventionAnnotatable&#xA;    interface IRuntimeEntityType&#xA;    interface IEntityType&#xA;    interface ITypeBase&#xA;    interface IAnnotatable&#xA;    interface IRuntimeTypeBase" FrameworkAlternate="efcore-8.0" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <AssemblyVersion>1.0.6.0</AssemblyVersion>
    <AssemblyVersion>1.1.0.0</AssemblyVersion>
    <AssemblyVersion>1.1.6.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.3.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.11.0</AssemblyVersion>
    <AssemblyVersion>2.2.6.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Internal.ConventionalAnnotatable</BaseTypeName>
    <BaseTypeName FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IEntityType</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableAnnotatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.ITypeBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IReadOnlyAnnotatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="efcore-8.0">
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, model As Model, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : string * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (name, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, model As Model, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : string * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (name, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (Type clrType, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type clrType, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (clrType As Type, model As Model, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (clrType, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="clrType">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, bool owned, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, bool owned, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, model As Model, owned As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : string * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (name, model, owned, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="owned" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="model">To be added.</param>
        <param name="owned">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, type As Type, model As Model, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : string * Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (name, type, model, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="2" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (Type type, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, bool owned, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, bool owned, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (type As Type, model As Model, owned As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (type, model, owned, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="owned" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="owned">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (Type clrType, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type clrType, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (clrType As Type, model As Model, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (clrType, model, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public EntityType (Type type, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (type As Type, model As Model, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (type, model, configurationSource)" FrameworkAlternate="efcore-5.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="clrType">To be added.</param>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, model As Model, definingNavigationName As String, definingEntityType As EntityType, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : string * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * string * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (name, model, definingNavigationName, definingEntityType, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="definingNavigationName" Type="System.String" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="definingEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="4" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="model">To be added.</param>
        <param name="definingNavigationName">To be added.</param>
        <param name="definingEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, model As Model, definingNavigationName As String, definingEntityType As EntityType, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : string * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * string * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (name, model, definingNavigationName, definingEntityType, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="definingNavigationName" Type="System.String" Index="2" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="definingEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="3" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="4" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="model">To be added.</param>
        <param name="definingNavigationName">To be added.</param>
        <param name="definingEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (string name, Type type, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, bool owned, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, bool owned, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, type As Type, model As Model, owned As Boolean, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : string * Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (name, type, model, owned, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="owned" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="4" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="owned">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (Type clrType, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type clrType, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (clrType As Type, model As Model, definingNavigationName As String, definingEntityType As EntityType, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * string * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (clrType, model, definingNavigationName, definingEntityType, configurationSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="definingNavigationName" Type="System.String" Index="2" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="definingEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="3" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="4" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="clrType">To be added.</param>
        <param name="model">To be added.</param>
        <param name="definingNavigationName">To be added.</param>
        <param name="definingEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityType (Type clrType, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type clrType, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.#ctor(System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.Model,System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (clrType As Type, model As Model, definingNavigationName As String, definingEntityType As EntityType, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * string * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (clrType, model, definingNavigationName, definingEntityType, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public EntityType (Type type, Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class Microsoft.EntityFrameworkCore.Metadata.Internal.Model model, string definingNavigationName, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType definingEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (type As Type, model As Model, definingNavigationName As String, definingEntityType As EntityType, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType : Type * Microsoft.EntityFrameworkCore.Metadata.Internal.Model * string * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType (type, model, definingNavigationName, definingEntityType, configurationSource)" FrameworkAlternate="efcore-5.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clrType" Type="System.Type" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="model" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="definingNavigationName" Type="System.String" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="definingEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="4" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="clrType">To be added.</param>
        <param name="type">To be added.</param>
        <param name="model">To be added.</param>
        <param name="definingNavigationName">To be added.</param>
        <param name="definingEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddData">
      <MemberSignature Language="C#" Value="public virtual void AddData (System.Collections.Generic.IEnumerable&lt;object&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddData(class System.Collections.Generic.IEnumerable`1&lt;object&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddData(System.Collections.Generic.IEnumerable{System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddData (data As IEnumerable(Of Object))" />
      <MemberSignature Language="F#" Value="abstract member AddData : seq&lt;obj&gt; -&gt; unit&#xA;override this.AddData : seq&lt;obj&gt; -&gt; unit" Usage="entityType.AddData data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddData(System.Collections.Generic.IEnumerable{System.Object})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" Index="0" FrameworkAlternate="efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddData">
      <MemberSignature Language="C#" Value="public virtual void AddData (object[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddData(object[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddData(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddData (data As Object())" />
      <MemberSignature Language="F#" Value="abstract member AddData : obj[] -&gt; unit&#xA;override this.AddData : obj[] -&gt; unit" Usage="entityType.AddData data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object[]" Index="0" FrameworkAlternate="efcore-2.1" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, class Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddForeignKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.Internal.Key,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddForeignKey (property As Property, principalKey As Key, principalEntityType As EntityType, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member AddForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.AddForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.AddForeignKey (property, principalKey, principalEntityType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="3" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? configurationSource = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.Internal.Key,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddForeignKey (properties As IReadOnlyList(Of Property), principalKey As Key, principalEntityType As EntityType, Optional configurationSource As Nullable(Of ConfigurationSource) = 0) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.AddForeignKey (properties, principalKey, principalEntityType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="2" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Index="3" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? componentConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, class Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; componentConfigurationSource, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddForeignKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.Internal.Key,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddForeignKey (property As Property, principalKey As Key, principalEntityType As EntityType, componentConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As ConfigurationSource) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member AddForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.AddForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.AddForeignKey (property, principalKey, principalEntityType, componentConfigurationSource, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? AddForeignKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? componentConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="componentConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="4" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <param name="componentConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? componentConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; componentConfigurationSource, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.Internal.Key,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddForeignKey (properties As IReadOnlyList(Of Property), principalKey As Key, principalEntityType As EntityType, componentConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As ConfigurationSource) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.AddForeignKey (properties, principalKey, principalEntityType, componentConfigurationSource, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? AddForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? componentConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="componentConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="4" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <param name="componentConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? configurationSource = 0, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey AddForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; configurationSource, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.Internal.Key,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddForeignKey (properties As IReadOnlyList(Of Property), principalKey As Key, principalEntityType As EntityType, Optional configurationSource As Nullable(Of ConfigurationSource) = 0, Optional runConventions As Boolean = true) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.AddForeignKey (properties, principalKey, principalEntityType, configurationSource, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Index="3" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddIndex(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddIndex (property As Property, configurationSource As ConfigurationSource) As Index" />
      <MemberSignature Language="F#" Value="abstract member AddIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.AddIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.AddIndex (property, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? AddIndex (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddIndex(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddIndex (property As Property, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit) As Index" />
      <MemberSignature Language="F#" Value="abstract member AddIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.AddIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.AddIndex (property, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddIndex (properties As IReadOnlyList(Of Property), configurationSource As ConfigurationSource) As Index" />
      <MemberSignature Language="F#" Value="abstract member AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.AddIndex (properties, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddIndex (properties As IReadOnlyList(Of Property), Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit) As Index" />
      <MemberSignature Language="F#" Value="abstract member AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.AddIndex (properties, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, string name, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddIndex(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddIndex (property As Property, name As String, configurationSource As ConfigurationSource) As Index" />
      <MemberSignature Language="F#" Value="abstract member AddIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.AddIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.AddIndex (property, name, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? AddIndex (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index AddIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, string name, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddIndex (properties As IReadOnlyList(Of Property), name As String, configurationSource As ConfigurationSource) As Index" />
      <MemberSignature Language="F#" Value="abstract member AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.AddIndex (properties, name, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key AddKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key AddKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddKey (property As Property, configurationSource As ConfigurationSource) As Key" />
      <MemberSignature Language="F#" Value="abstract member AddKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.AddKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.AddKey (property, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? AddKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key AddKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key AddKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddKey (property As Property, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit) As Key" />
      <MemberSignature Language="F#" Value="abstract member AddKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.AddKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.AddKey (property, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key AddKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key AddKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddKey (properties As IReadOnlyList(Of Property), configurationSource As ConfigurationSource) As Key" />
      <MemberSignature Language="F#" Value="abstract member AddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.AddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.AddKey (properties, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? AddKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key AddKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key AddKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddKey (properties As IReadOnlyList(Of Property), Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit) As Key" />
      <MemberSignature Language="F#" Value="abstract member AddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.AddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.AddKey (properties, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation (Microsoft.EntityFrameworkCore.Metadata.MemberIdentity navigationMember, Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation(valuetype Microsoft.EntityFrameworkCore.Metadata.MemberIdentity navigationMember, class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddNavigation(Microsoft.EntityFrameworkCore.Metadata.MemberIdentity,Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNavigation (navigationMember As MemberIdentity, foreignKey As ForeignKey, pointsToPrincipal As Boolean) As Navigation" />
      <MemberSignature Language="F#" Value="abstract member AddNavigation : Microsoft.EntityFrameworkCore.Metadata.MemberIdentity * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.AddNavigation : Microsoft.EntityFrameworkCore.Metadata.MemberIdentity * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.AddNavigation (navigationMember, foreignKey, pointsToPrincipal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigationMember" Type="Microsoft.EntityFrameworkCore.Metadata.MemberIdentity" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="pointsToPrincipal" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="navigationMember">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <param name="pointsToPrincipal">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation (System.Reflection.PropertyInfo navigationProperty, Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation(class System.Reflection.PropertyInfo navigationProperty, class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddNavigation(System.Reflection.PropertyInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNavigation (navigationProperty As PropertyInfo, foreignKey As ForeignKey, pointsToPrincipal As Boolean) As Navigation" />
      <MemberSignature Language="F#" Value="abstract member AddNavigation : System.Reflection.PropertyInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.AddNavigation : System.Reflection.PropertyInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.AddNavigation (navigationProperty, foreignKey, pointsToPrincipal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigationProperty" Type="System.Reflection.PropertyInfo" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0" />
        <Parameter Name="pointsToPrincipal" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0" />
      </Parameters>
      <Docs>
        <param name="navigationProperty">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <param name="pointsToPrincipal">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation(string name, class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddNavigation(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNavigation (name As String, foreignKey As ForeignKey, pointsToPrincipal As Boolean) As Navigation" />
      <MemberSignature Language="F#" Value="abstract member AddNavigation : string * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.AddNavigation : string * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.AddNavigation (name, foreignKey, pointsToPrincipal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" />
        <Parameter Name="pointsToPrincipal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <param name="pointsToPrincipal">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation (System.Reflection.MemberInfo navigationProperty, Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation(class System.Reflection.MemberInfo navigationProperty, class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal) cil managed" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddNavigation(System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNavigation (navigationProperty As MemberInfo, foreignKey As ForeignKey, pointsToPrincipal As Boolean) As Navigation" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member AddNavigation : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.AddNavigation : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.AddNavigation (navigationProperty, foreignKey, pointsToPrincipal)" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation (System.Reflection.MemberInfo navigationMember, Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation AddNavigation(class System.Reflection.MemberInfo navigationMember, class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey, bool pointsToPrincipal) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNavigation (navigationMember As MemberInfo, foreignKey As ForeignKey, pointsToPrincipal As Boolean) As Navigation" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member AddNavigation : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.AddNavigation : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.AddNavigation (navigationMember, foreignKey, pointsToPrincipal)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigationProperty" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="navigationMember" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Index="1" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="pointsToPrincipal" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="navigationProperty">To be added.</param>
        <param name="navigationMember">To be added.</param>
        <param name="foreignKey">To be added.</param>
        <param name="pointsToPrincipal">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(class System.Reflection.MemberInfo memberInfo, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (memberInfo As MemberInfo, configurationSource As ConfigurationSource) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (memberInfo, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? AddProperty (System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(class System.Reflection.MemberInfo memberInfo, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (memberInfo As MemberInfo, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (memberInfo, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, configurationSource As ConfigurationSource) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (name, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? AddProperty (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Use an overload that accepts a type")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(class System.Reflection.MemberInfo memberInfo, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (memberInfo As MemberInfo, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, Optional runConventions As Boolean = true) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (memberInfo, configurationSource, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (System.Reflection.PropertyInfo propertyInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(class System.Reflection.PropertyInfo propertyInfo, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.Reflection.PropertyInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (propertyInfo As PropertyInfo, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, Optional runConventions As Boolean = true) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : System.Reflection.PropertyInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : System.Reflection.PropertyInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (propertyInfo, configurationSource, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="0" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (string name, Type propertyType = default, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(string name, class System.Type propertyType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, Optional propertyType As Type = Nothing, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, Optional runConventions As Boolean = true) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Type * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : string * Type * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (name, propertyType, configurationSource, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="2" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (string name, Type propertyType = default, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? typeConfigurationSource = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(string name, class System.Type propertyType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; typeConfigurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.String,System.Type,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, Optional propertyType As Type = Nothing, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, Optional typeConfigurationSource As Nullable(Of ConfigurationSource) = 0) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Type * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : string * Type * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (name, propertyType, configurationSource, typeConfigurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="2" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Index="3" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (string name, Type propertyType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(string name, class System.Type propertyType, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.String,System.Type,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, propertyType As Type, typeConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As ConfigurationSource) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : string * Type * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (name, propertyType, typeConfigurationSource, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? AddProperty (string name, Type propertyType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (string name, Type propertyType = default, bool? shadow = default, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(string name, class System.Type propertyType, valuetype System.Nullable`1&lt;bool&gt; shadow, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.String,System.Type,System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, Optional propertyType As Type = Nothing, Optional shadow As Nullable(Of Boolean) = Nothing, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, Optional runConventions As Boolean = true) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Type * Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : string * Type * Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (name, propertyType, shadow, configurationSource, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="shadow" Type="System.Nullable&lt;System.Boolean&gt;" Index="2" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="3" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="shadow">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty (string name, Type propertyType, System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property AddProperty(string name, class System.Type propertyType, class System.Reflection.MemberInfo memberInfo, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddProperty (name As String, propertyType As Type, memberInfo As MemberInfo, typeConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As ConfigurationSource) As Property" />
      <MemberSignature Language="F#" Value="abstract member AddProperty : string * Type * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.AddProperty : string * Type * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.AddProperty (name, propertyType, memberInfo, typeConfigurationSource, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? AddProperty (string name, Type propertyType, System.Reflection.MemberInfo? memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="4" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddServiceProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty AddServiceProperty (System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty AddServiceProperty(class System.Reflection.MemberInfo memberInfo, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddServiceProperty(System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddServiceProperty (memberInfo As MemberInfo, configurationSource As ConfigurationSource) As ServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member AddServiceProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&#xA;override this.AddServiceProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty" Usage="entityType.AddServiceProperty (memberInfo, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddServiceProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty AddServiceProperty (System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty AddServiceProperty(class System.Reflection.MemberInfo memberInfo, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddServiceProperty(System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddServiceProperty (memberInfo As MemberInfo, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit) As ServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member AddServiceProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&#xA;override this.AddServiceProperty : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty" Usage="entityType.AddServiceProperty (memberInfo, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddServiceProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty AddServiceProperty (System.Reflection.MemberInfo memberInfo, Type serviceType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty AddServiceProperty(class System.Reflection.MemberInfo memberInfo, class System.Type serviceType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddServiceProperty(System.Reflection.MemberInfo,System.Type,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddServiceProperty (memberInfo As MemberInfo, serviceType As Type, configurationSource As ConfigurationSource) As ServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member AddServiceProperty : System.Reflection.MemberInfo * Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&#xA;override this.AddServiceProperty : System.Reflection.MemberInfo * Type * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty" Usage="entityType.AddServiceProperty (memberInfo, serviceType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="serviceType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="2" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="serviceType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSkipNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation AddSkipNavigation (string name, System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation AddSkipNavigation(string name, class System.Reflection.MemberInfo memberInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddSkipNavigation(System.String,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,System.Boolean,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddSkipNavigation (name As String, memberInfo As MemberInfo, targetEntityType As EntityType, collection As Boolean, onDependent As Boolean, configurationSource As ConfigurationSource) As SkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member AddSkipNavigation : string * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * bool * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&#xA;override this.AddSkipNavigation : string * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * bool * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="entityType.AddSkipNavigation (name, memberInfo, targetEntityType, collection, onDependent, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? AddSkipNavigation (string name, System.Reflection.MemberInfo? memberInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="targetEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="onDependent" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="5" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="targetEntityType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="onDependent">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSkipNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? AddSkipNavigation (string name, Type? navigationType, System.Reflection.MemberInfo? memberInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation AddSkipNavigation(string name, class System.Type navigationType, class System.Reflection.MemberInfo memberInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType targetEntityType, bool collection, bool onDependent, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddSkipNavigation(System.String,System.Type,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,System.Boolean,System.Boolean,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddSkipNavigation (name As String, navigationType As Type, memberInfo As MemberInfo, targetEntityType As EntityType, collection As Boolean, onDependent As Boolean, configurationSource As ConfigurationSource) As SkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member AddSkipNavigation : string * Type * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * bool * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&#xA;override this.AddSkipNavigation : string * Type * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * bool * bool * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="entityType.AddSkipNavigation (name, navigationType, memberInfo, targetEntityType, collection, onDependent, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="navigationType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="onDependent" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="6" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="navigationType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="targetEntityType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="onDependent">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddTrigger">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger? AddTrigger (string modelName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger AddTrigger(string modelName, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.AddTrigger(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddTrigger (modelName As String, configurationSource As ConfigurationSource) As Trigger" />
      <MemberSignature Language="F#" Value="abstract member AddTrigger : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger&#xA;override this.AddTrigger : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger" Usage="entityType.AddTrigger (modelName, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="modelName" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="modelName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseBuilder">
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder BaseBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder BaseBuilder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.BaseBuilder" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property BaseBuilder As InternalTypeBaseBuilder" />
      <MemberSignature Language="F#" Value="member this.BaseBuilder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.BaseBuilder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType BaseType { get; }" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseType As EntityType" />
      <MemberSignature Language="F#" Value="member this.BaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.BaseType" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType? BaseType { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Builder">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeBuilder Builder { get; set; }" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeBuilder Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Builder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Builder As InternalEntityTypeBuilder" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeBuilder with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Builder" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeBuilder Builder { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Builder As InternalEntityTypeBuilder" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.Builder : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Builder" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalEntityTypeBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ChangeTrackingStrategy ChangeTrackingStrategy { get; set; }" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.Metadata.ChangeTrackingStrategy ChangeTrackingStrategy" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ChangeTrackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ChangeTrackingStrategy As ChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="member this.ChangeTrackingStrategy : Microsoft.EntityFrameworkCore.Metadata.ChangeTrackingStrategy with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ChangeTrackingStrategy" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTrackingStrategy ChangeTrackingStrategy { get; set; }" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy ChangeTrackingStrategy" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="F#" Value="member this.ChangeTrackingStrategy : Microsoft.EntityFrameworkCore.ChangeTrackingStrategy with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ChangeTrackingStrategy" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0;efcore-1.1">Microsoft.EntityFrameworkCore.Metadata.ChangeTrackingStrategy</ReturnType>
        <ReturnType FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2">Microsoft.EntityFrameworkCore.ChangeTrackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual string CheckChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CheckChangeTrackingStrategy(valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.CheckChangeTrackingStrategy(Microsoft.EntityFrameworkCore.ChangeTrackingStrategy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CheckChangeTrackingStrategy (value As ChangeTrackingStrategy) As String" />
      <MemberSignature Language="F#" Value="abstract member CheckChangeTrackingStrategy : Microsoft.EntityFrameworkCore.ChangeTrackingStrategy -&gt; string&#xA;override this.CheckChangeTrackingStrategy : Microsoft.EntityFrameworkCore.ChangeTrackingStrategy -&gt; string" Usage="entityType.CheckChangeTrackingStrategy value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual string CheckChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy value, bool requireFullNotifications);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CheckChangeTrackingStrategy(valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy value, bool requireFullNotifications) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.CheckChangeTrackingStrategy(Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CheckChangeTrackingStrategy (value As ChangeTrackingStrategy, requireFullNotifications As Boolean) As String" />
      <MemberSignature Language="F#" Value="abstract member CheckChangeTrackingStrategy : Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * bool -&gt; string&#xA;override this.CheckChangeTrackingStrategy : Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * bool -&gt; string" Usage="entityType.CheckChangeTrackingStrategy (value, requireFullNotifications)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="0" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="requireFullNotifications" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="requireFullNotifications">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public static string? CheckChangeTrackingStrategy (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType, Microsoft.EntityFrameworkCore.ChangeTrackingStrategy value, bool requireFullNotifications);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CheckChangeTrackingStrategy(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType, valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy value, bool requireFullNotifications) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.CheckChangeTrackingStrategy(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType,Microsoft.EntityFrameworkCore.ChangeTrackingStrategy,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckChangeTrackingStrategy (entityType As IReadOnlyEntityType, value As ChangeTrackingStrategy, requireFullNotifications As Boolean) As String" />
      <MemberSignature Language="F#" Value="static member CheckChangeTrackingStrategy : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType * Microsoft.EntityFrameworkCore.ChangeTrackingStrategy * bool -&gt; string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.CheckChangeTrackingStrategy (entityType, value, requireFullNotifications)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
        <Parameter Name="value" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0" />
        <Parameter Name="requireFullNotifications" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="requireFullNotifications">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckDiscriminatorValue">
      <MemberSignature Language="C#" Value="public virtual void CheckDiscriminatorValue (Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CheckDiscriminatorValue(class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.CheckDiscriminatorValue(Microsoft.EntityFrameworkCore.Metadata.IEntityType,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CheckDiscriminatorValue (entityType As IEntityType, value As Object)" />
      <MemberSignature Language="F#" Value="abstract member CheckDiscriminatorValue : Microsoft.EntityFrameworkCore.Metadata.IEntityType * obj -&gt; unit&#xA;override this.CheckDiscriminatorValue : Microsoft.EntityFrameworkCore.Metadata.IEntityType * obj -&gt; unit" Usage="entityType.CheckDiscriminatorValue (entityType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="value">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckDiscriminatorValue">
      <MemberSignature Language="C#" Value="public static object? CheckDiscriminatorValue (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType, object? value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CheckDiscriminatorValue(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType entityType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.CheckDiscriminatorValue(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckDiscriminatorValue (entityType As IReadOnlyEntityType, value As Object) As Object" />
      <MemberSignature Language="F#" Value="static member CheckDiscriminatorValue : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType * obj -&gt; obj" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.CheckDiscriminatorValue (entityType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="0" FrameworkAlternate="efcore-6.0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="efcore-6.0" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="value">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckQueryFilter">
      <MemberSignature Language="C#" Value="public virtual string CheckQueryFilter (System.Linq.Expressions.LambdaExpression queryFilter);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CheckQueryFilter(class System.Linq.Expressions.LambdaExpression queryFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.CheckQueryFilter(System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CheckQueryFilter (queryFilter As LambdaExpression) As String" />
      <MemberSignature Language="F#" Value="abstract member CheckQueryFilter : System.Linq.Expressions.LambdaExpression -&gt; string&#xA;override this.CheckQueryFilter : System.Linq.Expressions.LambdaExpression -&gt; string" Usage="entityType.CheckQueryFilter queryFilter" />
      <MemberSignature Language="C#" Value="public virtual string? CheckQueryFilter (System.Linq.Expressions.LambdaExpression? queryFilter);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queryFilter" Type="System.Linq.Expressions.LambdaExpression" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="queryFilter">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearCaches">
      <MemberSignature Language="C#" Value="public override void ClearCaches ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ClearCaches() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ClearCaches" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ClearCaches ()" />
      <MemberSignature Language="F#" Value="override this.ClearCaches : unit -&gt; unit" Usage="entityType.ClearCaches " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClrType">
      <MemberSignature Language="C#" Value="public virtual Type ClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ClrType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClrType As Type" />
      <MemberSignature Language="F#" Value="member this.ClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ClrType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructorBinding">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? ConstructorBinding { get; set; }" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding ConstructorBinding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ConstructorBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ConstructorBinding As InstantiationBinding" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="member this.ConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ConstructorBinding" />
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? ConstructorBinding { get; set; }" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConstructorBinding As InstantiationBinding" FrameworkAlternate="efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Counts">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts Counts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts Counts" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Counts" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Counts As PropertyCounts" />
      <MemberSignature Language="F#" Value="member this.Counts : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Counts" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.Counts</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyCounts</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DebugView">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.DebugView&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; DebugView { get; }" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.DebugView`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; DebugView" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.DebugView" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DebugView As DebugView(Of EntityType)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="member this.DebugView : Microsoft.EntityFrameworkCore.Metadata.Internal.DebugView&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.DebugView" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView { get; }" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Infrastructure.DebugView DebugView" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DebugView As DebugView" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.DebugView : Microsoft.EntityFrameworkCore.Infrastructure.DebugView" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.DebugView" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">Microsoft.EntityFrameworkCore.Metadata.Internal.DebugView&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">Microsoft.EntityFrameworkCore.Infrastructure.DebugView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefiningEntityType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType DefiningEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType DefiningEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.DefiningEntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefiningEntityType As EntityType" />
      <MemberSignature Language="F#" Value="member this.DefiningEntityType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.DefiningEntityType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefiningNavigationName">
      <MemberSignature Language="C#" Value="public virtual string DefiningNavigationName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefiningNavigationName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.DefiningNavigationName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefiningNavigationName As String" />
      <MemberSignature Language="F#" Value="member this.DefiningNavigationName : string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.DefiningNavigationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IEntityType.DefiningNavigationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefiningQuery">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.LambdaExpression DefiningQuery { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.Expressions.LambdaExpression DefiningQuery" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.DefiningQuery" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DefiningQuery As LambdaExpression" />
      <MemberSignature Language="F#" Value="member this.DefiningQuery : System.Linq.Expressions.LambdaExpression with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.DefiningQuery" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.DefiningQuery</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyShadowValuesFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; EmptyShadowValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; EmptyShadowValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.EmptyShadowValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EmptyShadowValuesFactory As Func(Of ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.EmptyShadowValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.EmptyShadowValuesFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.EmptyShadowValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindDeclaredForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindDeclaredForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredForeignKey (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.FindDeclaredForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.FindDeclaredForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? FindDeclaredForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindDeclaredForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.FindDeclaredForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.FindDeclaredForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDeclaredForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDeclaredForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredForeignKeys (properties As IReadOnlyList(Of IProperty)) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindDeclaredForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindDeclaredForeignKeys properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDeclaredForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDeclaredForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindDeclaredForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindDeclaredForeignKeys properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindDeclaredIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindDeclaredIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredIndex (properties As IReadOnlyList(Of IProperty)) As Index" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.FindDeclaredIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.FindDeclaredIndex properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? FindDeclaredIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindDeclaredIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As Index" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.FindDeclaredIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.FindDeclaredIndex properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindDeclaredIndex (string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindDeclaredIndex(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredIndex(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredIndex (name As String) As Index" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.FindDeclaredIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.FindDeclaredIndex name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? FindDeclaredIndex (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindDeclaredKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindDeclaredKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredKey (properties As IReadOnlyList(Of IProperty)) As Key" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.FindDeclaredKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.FindDeclaredKey properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? FindDeclaredKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindDeclaredKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As Key" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.FindDeclaredKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.FindDeclaredKey properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation FindDeclaredNavigation (string name);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation FindDeclaredNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredNavigation (name As String) As Navigation" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.FindDeclaredNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.FindDeclaredNavigation name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation? FindDeclaredNavigation (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredOwnership">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindDeclaredOwnership ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindDeclaredOwnership() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredOwnership" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredOwnership () As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredOwnership : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.FindDeclaredOwnership : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.FindDeclaredOwnership " />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? FindDeclaredOwnership ();" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindDeclaredPrimaryKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindDeclaredPrimaryKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredPrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredPrimaryKey () As Key" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.FindDeclaredPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.FindDeclaredPrimaryKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindDeclaredProperty (string propertyName);" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindDeclaredProperty(string propertyName) cil managed" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredProperty (propertyName As String) As Property" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.FindDeclaredProperty propertyName" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindDeclaredProperty (string name);" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindDeclaredProperty(string name) cil managed" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredProperty (name As String) As Property" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.FindDeclaredProperty name" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? FindDeclaredProperty (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredServiceProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty FindDeclaredServiceProperty (string name);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty FindDeclaredServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredServiceProperty (name As String) As ServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&#xA;override this.FindDeclaredServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty" Usage="entityType.FindDeclaredServiceProperty name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty? FindDeclaredServiceProperty (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredSkipNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation FindDeclaredSkipNavigation (string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation FindDeclaredSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredSkipNavigation (name As String) As SkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&#xA;override this.FindDeclaredSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="entityType.FindDeclaredSkipNavigation name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? FindDeclaredSkipNavigation (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDeclaredTrigger">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger? FindDeclaredTrigger (string modelName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger FindDeclaredTrigger(string modelName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDeclaredTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDeclaredTrigger (modelName As String) As Trigger" />
      <MemberSignature Language="F#" Value="abstract member FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger&#xA;override this.FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger" Usage="entityType.FindDeclaredTrigger modelName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="modelName" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="modelName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDerivedForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDerivedForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedForeignKeys (properties As IReadOnlyList(Of IProperty)) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindDerivedForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindDerivedForeignKeys properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDerivedForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDerivedForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindDerivedForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindDerivedForeignKeys properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDerivedForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDerivedForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedForeignKeys (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindDerivedForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindDerivedForeignKeys (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDerivedForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindDerivedForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindDerivedForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindDerivedForeignKeys (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedIndexes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindDerivedIndexes (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindDerivedIndexes(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedIndexes(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedIndexes (properties As IReadOnlyList(Of IProperty)) As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedIndexes : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.FindDerivedIndexes : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.FindDerivedIndexes properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedIndexes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindDerivedIndexes (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindDerivedIndexes(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedIndexes(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedIndexes (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedIndexes : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.FindDerivedIndexes : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.FindDerivedIndexes properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedIndexes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindDerivedIndexes (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindDerivedIndexes(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedIndexes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedIndexes (name As String) As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedIndexes : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.FindDerivedIndexes : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.FindDerivedIndexes name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindDerivedNavigations (string navigationName);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindDerivedNavigations(string navigationName) cil managed" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedNavigations(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedNavigations (navigationName As String) As IEnumerable(Of Navigation)" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedNavigations : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;&#xA;override this.FindDerivedNavigations : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;" Usage="entityType.FindDerivedNavigations navigationName" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindDerivedNavigations (string name);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindDerivedNavigations(string name) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedNavigations (name As String) As IEnumerable(Of Navigation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedNavigations : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;&#xA;override this.FindDerivedNavigations : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;" Usage="entityType.FindDerivedNavigations name" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigationName" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="navigationName">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindDerivedProperties (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindDerivedProperties(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedProperties(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedProperties (propertyName As String) As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedProperties : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.FindDerivedProperties : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="entityType.FindDerivedProperties propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedPropertiesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindDerivedPropertiesInclusive (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindDerivedPropertiesInclusive(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedPropertiesInclusive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedPropertiesInclusive (propertyName As String) As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedPropertiesInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.FindDerivedPropertiesInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="entityType.FindDerivedPropertiesInclusive propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedServiceProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; FindDerivedServiceProperties (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; FindDerivedServiceProperties(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedServiceProperties(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedServiceProperties (propertyName As String) As IEnumerable(Of ServiceProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedServiceProperties : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;&#xA;override this.FindDerivedServiceProperties : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;" Usage="entityType.FindDerivedServiceProperties propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedServicePropertiesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; FindDerivedServicePropertiesInclusive (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; FindDerivedServicePropertiesInclusive(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedServicePropertiesInclusive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedServicePropertiesInclusive (propertyName As String) As IEnumerable(Of ServiceProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedServicePropertiesInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;&#xA;override this.FindDerivedServicePropertiesInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;" Usage="entityType.FindDerivedServicePropertiesInclusive propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedSkipNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; FindDerivedSkipNavigations (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; FindDerivedSkipNavigations(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedSkipNavigations(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedSkipNavigations (name As String) As IEnumerable(Of SkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedSkipNavigations : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;&#xA;override this.FindDerivedSkipNavigations : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;" Usage="entityType.FindDerivedSkipNavigations name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindDerivedSkipNavigationsInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; FindDerivedSkipNavigationsInclusive (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; FindDerivedSkipNavigationsInclusive(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindDerivedSkipNavigationsInclusive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindDerivedSkipNavigationsInclusive (name As String) As IEnumerable(Of SkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member FindDerivedSkipNavigationsInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;&#xA;override this.FindDerivedSkipNavigationsInclusive : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;" Usage="entityType.FindDerivedSkipNavigationsInclusive name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindForeignKey (Microsoft.EntityFrameworkCore.Metadata.IProperty property, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IProperty property, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKey(Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKey (property As IProperty, principalKey As IKey, principalEntityType As IEntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKey : Microsoft.EntityFrameworkCore.Metadata.IProperty * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.FindForeignKey : Microsoft.EntityFrameworkCore.Metadata.IProperty * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.FindForeignKey (property, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? FindForeignKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKey (property As IReadOnlyProperty, principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.FindForeignKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.FindForeignKey (property, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKey (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeys (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeys(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKeys(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKeys (property As IProperty) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeys : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindForeignKeys : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindForeignKeys property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeys (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeys(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKeys(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKeys (property As IReadOnlyProperty) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeys : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindForeignKeys : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindForeignKeys property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKeys (properties As IReadOnlyList(Of IProperty)) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindForeignKeys properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindForeignKeys properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeysInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeysInHierarchy (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeysInHierarchy(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKeysInHierarchy(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKeysInHierarchy (properties As IReadOnlyList(Of IProperty)) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeysInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindForeignKeysInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindForeignKeysInHierarchy properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeysInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeysInHierarchy (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeysInHierarchy(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKeysInHierarchy(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKeysInHierarchy (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeysInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindForeignKeysInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindForeignKeysInHierarchy properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeysInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeysInHierarchy (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeysInHierarchy(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKeysInHierarchy(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKeysInHierarchy (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeysInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindForeignKeysInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindForeignKeysInHierarchy (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForeignKeysInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeysInHierarchy (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; FindForeignKeysInHierarchy(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindForeignKeysInHierarchy(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindForeignKeysInHierarchy (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member FindForeignKeysInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.FindForeignKeysInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.FindForeignKeysInHierarchy (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIgnoredConfigurationSource">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? FindIgnoredConfigurationSource (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; FindIgnoredConfigurationSource(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIgnoredConfigurationSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindIgnoredConfigurationSource (name As String) As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="override this.FindIgnoredConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityType.FindIgnoredConfigurationSource name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase.FindIgnoredConfigurationSource(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIgnoredMemberConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? FindIgnoredMemberConfigurationSource (string name);" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; FindIgnoredMemberConfigurationSource(string name) cil managed" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIgnoredMemberConfigurationSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIgnoredMemberConfigurationSource (name As String) As Nullable(Of ConfigurationSource)" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="F#" Value="abstract member FindIgnoredMemberConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.FindIgnoredMemberConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="entityType.FindIgnoredMemberConfigurationSource name" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? FindIgnoredMemberConfigurationSource (string name);" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; FindIgnoredMemberConfigurationSource(string name) cil managed" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindIgnoredMemberConfigurationSource (name As String) As Nullable(Of ConfigurationSource)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="F#" Value="override this.FindIgnoredMemberConfigurationSource : string -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="entityType.FindIgnoredMemberConfigurationSource name" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindIndex (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindIndex(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIndex(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndex (property As IProperty) As Index" />
      <MemberSignature Language="F#" Value="abstract member FindIndex : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.FindIndex : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.FindIndex property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? FindIndex (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindIndex(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIndex(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndex (property As IReadOnlyProperty) As Index" />
      <MemberSignature Language="F#" Value="abstract member FindIndex : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.FindIndex : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.FindIndex property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndex (properties As IReadOnlyList(Of IProperty)) As Index" />
      <MemberSignature Language="F#" Value="abstract member FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.FindIndex properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As Index" />
      <MemberSignature Language="F#" Value="abstract member FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.FindIndex properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindIndex (string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index FindIndex(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIndex(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndex (name As String) As Index" />
      <MemberSignature Language="F#" Value="abstract member FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.FindIndex name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? FindIndex (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndexesInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindIndexesInHierarchy (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindIndexesInHierarchy(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIndexesInHierarchy(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndexesInHierarchy (properties As IReadOnlyList(Of IProperty)) As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member FindIndexesInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.FindIndexesInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.FindIndexesInHierarchy properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndexesInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindIndexesInHierarchy (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindIndexesInHierarchy(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIndexesInHierarchy(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndexesInHierarchy (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member FindIndexesInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.FindIndexesInHierarchy : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.FindIndexesInHierarchy properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIndexesInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindIndexesInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; FindIndexesInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindIndexesInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindIndexesInHierarchy (name As String) As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member FindIndexesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.FindIndexesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.FindIndexesInHierarchy name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindKey (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindKey(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindKey(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindKey (property As IProperty) As Key" />
      <MemberSignature Language="F#" Value="abstract member FindKey : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.FindKey : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.FindKey property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? FindKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindKey(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindKey (property As IReadOnlyProperty) As Key" />
      <MemberSignature Language="F#" Value="abstract member FindKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.FindKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.FindKey property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindKey (properties As IReadOnlyList(Of IProperty)) As Key" />
      <MemberSignature Language="F#" Value="abstract member FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.FindKey properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As Key" />
      <MemberSignature Language="F#" Value="abstract member FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.FindKey properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMember">
      <MemberSignature Language="C#" Value="public override Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase? FindMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase FindMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindMember (name As String) As PropertyBase" />
      <MemberSignature Language="F#" Value="override this.FindMember : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase" Usage="entityType.FindMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMembersInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; FindMembersInHierarchy (string name);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; FindMembersInHierarchy(string name) cil managed" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindMembersInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembersInHierarchy (name As String) As IEnumerable(Of PropertyBase)" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="abstract member FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;&#xA;override this.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="entityType.FindMembersInHierarchy name" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; FindMembersInHierarchy (string name);" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; FindMembersInHierarchy(string name) cil managed" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindMembersInHierarchy (name As String) As IEnumerable(Of PropertyBase)" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="F#" Value="override this.FindMembersInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="entityType.FindMembersInHierarchy name" FrameworkAlternate="efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation FindNavigation (System.Reflection.MemberInfo memberInfo);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation FindNavigation(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindNavigation(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindNavigation (memberInfo As MemberInfo) As Navigation" />
      <MemberSignature Language="F#" Value="abstract member FindNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.FindNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.FindNavigation memberInfo" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation? FindNavigation (System.Reflection.MemberInfo memberInfo);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation FindNavigation (System.Reflection.PropertyInfo propertyInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation FindNavigation(class System.Reflection.PropertyInfo propertyInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindNavigation(System.Reflection.PropertyInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindNavigation (propertyInfo As PropertyInfo) As Navigation" />
      <MemberSignature Language="F#" Value="abstract member FindNavigation : System.Reflection.PropertyInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.FindNavigation : System.Reflection.PropertyInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.FindNavigation propertyInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation FindNavigation (string name);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation FindNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindNavigation (name As String) As Navigation" />
      <MemberSignature Language="F#" Value="abstract member FindNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.FindNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.FindNavigation name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation? FindNavigation (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNavigationsInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindNavigationsInHierarchy (string propertyName);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindNavigationsInHierarchy(string propertyName) cil managed" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindNavigationsInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindNavigationsInHierarchy (propertyName As String) As IEnumerable(Of Navigation)" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0" />
      <MemberSignature Language="F#" Value="abstract member FindNavigationsInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;&#xA;override this.FindNavigationsInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;" Usage="entityType.FindNavigationsInHierarchy propertyName" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindNavigationsInHierarchy (string navigationName);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindNavigationsInHierarchy(string navigationName) cil managed" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindNavigationsInHierarchy (navigationName As String) As IEnumerable(Of Navigation)" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member FindNavigationsInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;&#xA;override this.FindNavigationsInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;" Usage="entityType.FindNavigationsInHierarchy navigationName" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindNavigationsInHierarchy (string name);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; FindNavigationsInHierarchy(string name) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindNavigationsInHierarchy (name As String) As IEnumerable(Of Navigation)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member FindNavigationsInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;&#xA;override this.FindNavigationsInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;" Usage="entityType.FindNavigationsInHierarchy name" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0" />
        <Parameter Name="navigationName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <param name="navigationName">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindOwnership">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindOwnership ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey FindOwnership() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindOwnership" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindOwnership () As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member FindOwnership : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.FindOwnership : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.FindOwnership " />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? FindOwnership ();" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindPrimaryKey ();" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindPrimaryKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindPrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindPrimaryKey () As Key" />
      <MemberSignature Language="F#" Value="abstract member FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.FindPrimaryKey " />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? FindPrimaryKey ();" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key FindPrimaryKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindPrimaryKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindPrimaryKey (properties As IReadOnlyList(Of Property)) As Key" />
      <MemberSignature Language="F#" Value="abstract member FindPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.FindPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.FindPrimaryKey properties" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? FindPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? properties);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindProperties(class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; propertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindProperties(System.Collections.Generic.IReadOnlyList{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindProperties (propertyNames As IReadOnlyList(Of String)) As IReadOnlyList(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="entityType.FindProperties propertyNames" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? FindProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IReadOnlyList&lt;System.String&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="propertyNames">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindPropertiesInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindPropertiesInHierarchy (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; FindPropertiesInHierarchy(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindPropertiesInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindPropertiesInHierarchy (propertyName As String) As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member FindPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.FindPropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="entityType.FindPropertiesInHierarchy propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindProperty (System.Reflection.PropertyInfo propertyInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindProperty(class System.Reflection.PropertyInfo propertyInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindProperty(System.Reflection.PropertyInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindProperty (propertyInfo As PropertyInfo) As Property" />
      <MemberSignature Language="F#" Value="abstract member FindProperty : System.Reflection.PropertyInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.FindProperty : System.Reflection.PropertyInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.FindProperty propertyInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindProperty (string name);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindProperty (name As String) As Property" />
      <MemberSignature Language="F#" Value="abstract member FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.FindProperty name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? FindProperty (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindServicePropertiesInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; FindServicePropertiesInHierarchy (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; FindServicePropertiesInHierarchy(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindServicePropertiesInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindServicePropertiesInHierarchy (propertyName As String) As IEnumerable(Of ServiceProperty)" />
      <MemberSignature Language="F#" Value="abstract member FindServicePropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;&#xA;override this.FindServicePropertiesInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;" Usage="entityType.FindServicePropertiesInHierarchy propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindServiceProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindServiceProperty (System.Reflection.MemberInfo memberInfo);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property FindServiceProperty(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindServiceProperty(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindServiceProperty (memberInfo As MemberInfo) As Property" />
      <MemberSignature Language="F#" Value="abstract member FindServiceProperty : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.FindServiceProperty : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.FindServiceProperty memberInfo" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? FindServiceProperty (System.Reflection.MemberInfo memberInfo);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindServiceProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty FindServiceProperty (string name);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty FindServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindServiceProperty (name As String) As ServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&#xA;override this.FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty" Usage="entityType.FindServiceProperty name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty? FindServiceProperty (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSkipNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation FindSkipNavigation (System.Reflection.MemberInfo memberInfo);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation FindSkipNavigation(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindSkipNavigation(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindSkipNavigation (memberInfo As MemberInfo) As SkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member FindSkipNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&#xA;override this.FindSkipNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="entityType.FindSkipNavigation memberInfo" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? FindSkipNavigation (System.Reflection.MemberInfo memberInfo);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSkipNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation FindSkipNavigation (string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation FindSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindSkipNavigation (name As String) As SkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&#xA;override this.FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="entityType.FindSkipNavigation name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? FindSkipNavigation (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSkipNavigationsInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; FindSkipNavigationsInHierarchy (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; FindSkipNavigationsInHierarchy(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.FindSkipNavigationsInHierarchy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindSkipNavigationsInHierarchy (name As String) As IEnumerable(Of SkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member FindSkipNavigationsInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;&#xA;override this.FindSkipNavigationsInHierarchy : string -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;" Usage="entityType.FindSkipNavigationsInHierarchy name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeignKeyProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ForeignKeyProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ForeignKeyProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ForeignKeyProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ForeignKeyProperties As IReadOnlyList(Of IProperty)" />
      <MemberSignature Language="F#" Value="member this.ForeignKeyProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ForeignKeyProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseTypeConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetBaseTypeConfigurationSource ();" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetBaseTypeConfigurationSource() cil managed" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetBaseTypeConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseTypeConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetBaseTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetBaseTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="entityType.GetBaseTypeConfigurationSource " FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetBaseTypeConfigurationSource ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetBaseTypeConfigurationSource() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetBaseTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetBaseTypeConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityType.GetBaseTypeConfigurationSource " FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetBaseTypeConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTrackingStrategy GetChangeTrackingStrategy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy GetChangeTrackingStrategy() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetChangeTrackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChangeTrackingStrategy () As ChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member GetChangeTrackingStrategy : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&#xA;override this.GetChangeTrackingStrategy : unit -&gt; Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" Usage="entityType.GetChangeTrackingStrategy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0">M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetChangeTrackingStrategy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTrackingStrategy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeTrackingStrategyConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetChangeTrackingStrategyConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetChangeTrackingStrategyConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetChangeTrackingStrategyConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChangeTrackingStrategyConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetChangeTrackingStrategyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetChangeTrackingStrategyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityType.GetChangeTrackingStrategyConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetChangeTrackingStrategyConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource GetConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource GetConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigurationSource () As ConfigurationSource" />
      <MemberSignature Language="F#" Value="abstract member GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&#xA;override this.GetConfigurationSource : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Usage="entityType.GetConfigurationSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorBindingConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetConstructorBindingConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetConstructorBindingConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetConstructorBindingConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConstructorBindingConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityType.GetConstructorBindingConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0">M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.GetConstructorBindingConfigurationSource</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetConstructorBindingConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IDictionary&lt;string,object&gt;&gt; GetData (bool providerValues = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Collections.Generic.IDictionary`2&lt;string, object&gt;&gt; GetData(bool providerValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetData(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetData (Optional providerValues As Boolean = false) As IEnumerable(Of IDictionary(Of String, Object))" />
      <MemberSignature Language="F#" Value="abstract member GetData : bool -&gt; seq&lt;System.Collections.Generic.IDictionary&lt;string, obj&gt;&gt;&#xA;override this.GetData : bool -&gt; seq&lt;System.Collections.Generic.IDictionary&lt;string, obj&gt;&gt;" Usage="entityType.GetData providerValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerValues" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="providerValues">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDeclaredForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDeclaredForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredForeignKeys () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetDeclaredForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.GetDeclaredForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredIndexes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetDeclaredIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetDeclaredIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredIndexes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredIndexes () As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.GetDeclaredIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.GetDeclaredIndexes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt; GetDeclaredKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt; GetDeclaredKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredKeys () As IEnumerable(Of Key)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;&#xA;override this.GetDeclaredKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;" Usage="entityType.GetDeclaredKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredMembers">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetDeclaredMembers ();" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetDeclaredMembers() cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredMembers () As IEnumerable(Of PropertyBase)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;&#xA;override this.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="entityType.GetDeclaredMembers " FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetDeclaredMembers ();" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetDeclaredMembers() cil managed" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDeclaredMembers () As IEnumerable(Of PropertyBase)" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="F#" Value="override this.GetDeclaredMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="entityType.GetDeclaredMembers " FrameworkAlternate="efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; GetDeclaredNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; GetDeclaredNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredNavigations () As IEnumerable(Of Navigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;&#xA;override this.GetDeclaredNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;" Usage="entityType.GetDeclaredNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredProperties () As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="entityType.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredReferencingForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDeclaredReferencingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDeclaredReferencingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredReferencingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredReferencingForeignKeys () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetDeclaredReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.GetDeclaredReferencingForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredReferencingSkipNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetDeclaredReferencingSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetDeclaredReferencingSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredReferencingSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredReferencingSkipNavigations () As IEnumerable(Of SkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredReferencingSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;&#xA;override this.GetDeclaredReferencingSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;" Usage="entityType.GetDeclaredReferencingSkipNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredServiceProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; GetDeclaredServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; GetDeclaredServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredServiceProperties () As IEnumerable(Of ServiceProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;&#xA;override this.GetDeclaredServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;" Usage="entityType.GetDeclaredServiceProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSkipNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetDeclaredSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetDeclaredSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredSkipNavigations () As IEnumerable(Of SkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;&#xA;override this.GetDeclaredSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;" Usage="entityType.GetDeclaredSkipNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredTriggers">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger&gt; GetDeclaredTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger&gt; GetDeclaredTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDeclaredTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDeclaredTriggers () As IEnumerable(Of Trigger)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger&gt;&#xA;override this.GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger&gt;" Usage="entityType.GetDeclaredTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDerivedForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDerivedForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedForeignKeys () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetDerivedForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.GetDerivedForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedForeignKeysInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDerivedForeignKeysInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDerivedForeignKeysInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedForeignKeysInclusive" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedForeignKeysInclusive () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedForeignKeysInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetDerivedForeignKeysInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.GetDerivedForeignKeysInclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedIndexes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetDerivedIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetDerivedIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedIndexes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedIndexes () As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.GetDerivedIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.GetDerivedIndexes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedIndexesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetDerivedIndexesInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetDerivedIndexesInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedIndexesInclusive" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedIndexesInclusive () As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedIndexesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.GetDerivedIndexesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.GetDerivedIndexesInclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; GetDerivedNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; GetDerivedNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedNavigations () As IEnumerable(Of Navigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;&#xA;override this.GetDerivedNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;" Usage="entityType.GetDerivedNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedNavigationsInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; GetDerivedNavigationsInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; GetDerivedNavigationsInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedNavigationsInclusive" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedNavigationsInclusive () As IEnumerable(Of Navigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedNavigationsInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;&#xA;override this.GetDerivedNavigationsInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;" Usage="entityType.GetDerivedNavigationsInclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetDerivedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetDerivedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedProperties () As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="entityType.GetDerivedProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedReferencingForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDerivedReferencingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDerivedReferencingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedReferencingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedReferencingForeignKeys () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetDerivedReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.GetDerivedReferencingForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedReferencingForeignKeysInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDerivedReferencingForeignKeysInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetDerivedReferencingForeignKeysInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedReferencingForeignKeysInclusive" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedReferencingForeignKeysInclusive () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedReferencingForeignKeysInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetDerivedReferencingForeignKeysInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.GetDerivedReferencingForeignKeysInclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedReferencingSkipNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetDerivedReferencingSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetDerivedReferencingSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedReferencingSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedReferencingSkipNavigations () As IEnumerable(Of SkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedReferencingSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;&#xA;override this.GetDerivedReferencingSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;" Usage="entityType.GetDerivedReferencingSkipNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedServiceProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; GetDerivedServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; GetDerivedServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedServiceProperties () As IEnumerable(Of ServiceProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;&#xA;override this.GetDerivedServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;" Usage="entityType.GetDerivedServiceProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedSkipNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetDerivedSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetDerivedSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedSkipNavigations () As IEnumerable(Of SkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;&#xA;override this.GetDerivedSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;" Usage="entityType.GetDerivedSkipNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedTypes () As IEnumerable(Of EntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;&#xA;override this.GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;" Usage="entityType.GetDerivedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivedTypesInclusive">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDerivedTypesInclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDerivedTypesInclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDerivedTypesInclusive" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDerivedTypesInclusive () As IEnumerable(Of EntityType)" />
      <MemberSignature Language="F#" Value="abstract member GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;&#xA;override this.GetDerivedTypesInclusive : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;" Usage="entityType.GetDerivedTypesInclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDirectlyDerivedTypes ();" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDirectlyDerivedTypes() cil managed" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDirectlyDerivedTypes () As IReadOnlyList(Of EntityType)" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="F#" Value="abstract member GetDirectlyDerivedTypes : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;&#xA;override this.GetDirectlyDerivedTypes : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;" Usage="entityType.GetDirectlyDerivedTypes " FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.ISet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDirectlyDerivedTypes ();" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.ISet`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDirectlyDerivedTypes() cil managed" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDirectlyDerivedTypes () As ISet(Of EntityType)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      <MemberSignature Language="F#" Value="abstract member GetDirectlyDerivedTypes : unit -&gt; System.Collections.Generic.ISet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;&#xA;override this.GetDirectlyDerivedTypes : unit -&gt; System.Collections.Generic.ISet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;" Usage="entityType.GetDirectlyDerivedTypes " FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlySet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDirectlyDerivedTypes ();" FrameworkAlternate="efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlySet`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDirectlyDerivedTypes() cil managed" FrameworkAlternate="efcore-7.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDirectlyDerivedTypes () As IReadOnlySet(Of EntityType)" FrameworkAlternate="efcore-7.0" />
      <MemberSignature Language="F#" Value="abstract member GetDirectlyDerivedTypes : unit -&gt; System.Collections.Generic.IReadOnlySet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;&#xA;override this.GetDirectlyDerivedTypes : unit -&gt; System.Collections.Generic.IReadOnlySet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;" Usage="entityType.GetDirectlyDerivedTypes " FrameworkAlternate="efcore-7.0" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDirectlyDerivedTypes ();" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt; GetDirectlyDerivedTypes() cil managed" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDirectlyDerivedTypes () As IEnumerable(Of EntityType)" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;&#xA;override this.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;" Usage="entityType.GetDirectlyDerivedTypes " FrameworkAlternate="efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0">System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0">System.Collections.Generic.ISet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-7.0">System.Collections.Generic.IReadOnlySet&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-8.0">System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiscriminatorPropertyConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetDiscriminatorPropertyConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetDiscriminatorPropertyConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDiscriminatorPropertyConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDiscriminatorPropertyConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetDiscriminatorPropertyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetDiscriminatorPropertyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityType.GetDiscriminatorPropertyConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetDiscriminatorPropertyConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiscriminatorPropertyName">
      <MemberSignature Language="C#" Value="public virtual string? GetDiscriminatorPropertyName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetDiscriminatorPropertyName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetDiscriminatorPropertyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDiscriminatorPropertyName () As String" />
      <MemberSignature Language="F#" Value="abstract member GetDiscriminatorPropertyName : unit -&gt; string&#xA;override this.GetDiscriminatorPropertyName : unit -&gt; string" Usage="entityType.GetDiscriminatorPropertyName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDiscriminatorPropertyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns the name of the property that will be used for storing a discriminator value.
            </summary>
        <returns>The name of the property that will be used for storing a discriminator value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForeignKeys () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.GetForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetForeignKeysInHierarchy">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetForeignKeysInHierarchy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetForeignKeysInHierarchy() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetForeignKeysInHierarchy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForeignKeysInHierarchy () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetForeignKeysInHierarchy : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetForeignKeysInHierarchy : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.GetForeignKeysInHierarchy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIndexes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt; GetIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetIndexes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIndexes () As IEnumerable(Of Index)" />
      <MemberSignature Language="F#" Value="abstract member GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;&#xA;override this.GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;" Usage="entityType.GetIndexes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Index&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsKeylessConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetIsKeylessConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetIsKeylessConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetIsKeylessConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIsKeylessConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetIsKeylessConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetIsKeylessConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityType.GetIsKeylessConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetIsKeylessConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt; GetKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt; GetKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKeys () As IEnumerable(Of Key)" />
      <MemberSignature Language="F#" Value="abstract member GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;&#xA;override this.GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;" Usage="entityType.GetKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Key&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetMembers ();" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetMembers() cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMembers () As IEnumerable(Of PropertyBase)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;&#xA;override this.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="entityType.GetMembers " FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetMembers ();" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetMembers() cil managed" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers () As IEnumerable(Of PropertyBase)" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="F#" Value="override this.GetMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="entityType.GetMembers " FrameworkAlternate="efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNavigationAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.PropertyAccessMode GetNavigationAccessMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode GetNavigationAccessMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetNavigationAccessMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNavigationAccessMode () As PropertyAccessMode" />
      <MemberSignature Language="F#" Value="abstract member GetNavigationAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode&#xA;override this.GetNavigationAccessMode : unit -&gt; Microsoft.EntityFrameworkCore.PropertyAccessMode" Usage="entityType.GetNavigationAccessMode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigationAccessMode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.PropertyAccessMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; GetNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt; GetNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNavigations () As IEnumerable(Of Navigation)" />
      <MemberSignature Language="F#" Value="abstract member GetNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;&#xA;override this.GetNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;" Usage="entityType.GetNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey GetOrAddForeignKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey GetOrAddForeignKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, class Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddForeignKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.Internal.Key,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddForeignKey (property As Property, principalKey As Key, principalEntityType As EntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.GetOrAddForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.GetOrAddForeignKey (property, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey GetOrAddForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey GetOrAddForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.Internal.Key principalKey, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.Internal.Key,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddForeignKey (properties As IReadOnlyList(Of Property), principalKey As Key, principalEntityType As EntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.GetOrAddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.Key * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.GetOrAddForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index GetOrAddIndex (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index GetOrAddIndex(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddIndex(Microsoft.EntityFrameworkCore.Metadata.Internal.Property)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddIndex (property As Property) As Index" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.GetOrAddIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.GetOrAddIndex property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index GetOrAddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index GetOrAddIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddIndex (properties As IReadOnlyList(Of Property)) As Index" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.GetOrAddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.GetOrAddIndex properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key GetOrAddKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key GetOrAddKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Property)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddKey (property As Property) As Key" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.GetOrAddKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.GetOrAddKey property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key GetOrAddKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key GetOrAddKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddKey (properties As IReadOnlyList(Of Property)) As Key" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.GetOrAddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.GetOrAddKey properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property GetOrAddProperty (System.Reflection.PropertyInfo propertyInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property GetOrAddProperty(class System.Reflection.PropertyInfo propertyInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddProperty(System.Reflection.PropertyInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddProperty (propertyInfo As PropertyInfo) As Property" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddProperty : System.Reflection.PropertyInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.GetOrAddProperty : System.Reflection.PropertyInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.GetOrAddProperty propertyInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property GetOrAddProperty (string name, Type propertyType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property GetOrAddProperty(string name, class System.Type propertyType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddProperty (name As String, propertyType As Type) As Property" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddProperty : string * Type -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.GetOrAddProperty : string * Type -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.GetOrAddProperty (name, propertyType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property GetOrAddProperty (string name, Type propertyType, bool shadow);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property GetOrAddProperty(string name, class System.Type propertyType, bool shadow) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddProperty(System.String,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddProperty (name As String, propertyType As Type, shadow As Boolean) As Property" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddProperty : string * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.GetOrAddProperty : string * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.GetOrAddProperty (name, propertyType, shadow)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="shadow" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="shadow">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddServiceProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty GetOrAddServiceProperty (System.Reflection.MemberInfo memberInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty GetOrAddServiceProperty(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrAddServiceProperty(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrAddServiceProperty (memberInfo As MemberInfo) As ServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member GetOrAddServiceProperty : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&#xA;override this.GetOrAddServiceProperty : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty" Usage="entityType.GetOrAddServiceProperty memberInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateEmptyMaterializer">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetOrCreateEmptyMaterializer (Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetOrCreateEmptyMaterializer(class Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrCreateEmptyMaterializer(Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrCreateEmptyMaterializer (source As IEntityMaterializerSource) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateEmptyMaterializer : Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;&#xA;override this.GetOrCreateEmptyMaterializer : Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="entityType.GetOrCreateEmptyMaterializer source" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetOrCreateEmptyMaterializer(Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateMaterializer">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; GetOrCreateMaterializer (Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; GetOrCreateMaterializer(class Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrCreateMaterializer(Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrCreateMaterializer (source As IEntityMaterializerSource) As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateMaterializer : Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;&#xA;override this.GetOrCreateMaterializer : Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource -&gt; Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="entityType.GetOrCreateMaterializer source" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetOrCreateMaterializer(Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.EntityFrameworkCore.Query.IEntityMaterializerSource" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrSetPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key GetOrSetPrimaryKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key GetOrSetPrimaryKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrSetPrimaryKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Property)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrSetPrimaryKey (property As Property) As Key" />
      <MemberSignature Language="F#" Value="abstract member GetOrSetPrimaryKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.GetOrSetPrimaryKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.GetOrSetPrimaryKey property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrSetPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key GetOrSetPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key GetOrSetPrimaryKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetOrSetPrimaryKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrSetPrimaryKey (properties As IReadOnlyList(Of Property)) As Key" />
      <MemberSignature Language="F#" Value="abstract member GetOrSetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.GetOrSetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.GetOrSetPrimaryKey properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrimaryKeyConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource? GetPrimaryKeyConfigurationSource ();" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt; GetPrimaryKeyConfigurationSource() cil managed" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetPrimaryKeyConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrimaryKeyConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetPrimaryKeyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;&#xA;override this.GetPrimaryKeyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;" Usage="entityType.GetPrimaryKeyConfigurationSource " FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetPrimaryKeyConfigurationSource ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetPrimaryKeyConfigurationSource() cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member GetPrimaryKeyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetPrimaryKeyConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityType.GetPrimaryKeyConfigurationSource " FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetPrimaryKeyConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProperties () As IEnumerable(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="entityType.GetProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetQueryFilter">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.LambdaExpression? GetQueryFilter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.LambdaExpression GetQueryFilter() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetQueryFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetQueryFilter () As LambdaExpression" />
      <MemberSignature Language="F#" Value="abstract member GetQueryFilter : unit -&gt; System.Linq.Expressions.LambdaExpression&#xA;override this.GetQueryFilter : unit -&gt; System.Linq.Expressions.LambdaExpression" Usage="entityType.GetQueryFilter " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetQueryFilter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetQueryFilterConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetQueryFilterConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetQueryFilterConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetQueryFilterConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetQueryFilterConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetQueryFilterConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetQueryFilterConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityType.GetQueryFilterConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetQueryFilterConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRawSeedData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;object&gt; GetRawSeedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;object&gt; GetRawSeedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetRawSeedData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRawSeedData () As IEnumerable(Of Object)" />
      <MemberSignature Language="F#" Value="abstract member GetRawSeedData : unit -&gt; seq&lt;obj&gt;&#xA;override this.GetRawSeedData : unit -&gt; seq&lt;obj&gt;" Usage="entityType.GetRawSeedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReferencingForeignKeys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetReferencingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt; GetReferencingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetReferencingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencingForeignKeys () As IEnumerable(Of ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member GetReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;&#xA;override this.GetReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;" Usage="entityType.GetReferencingForeignKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReferencingSkipNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetReferencingSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetReferencingSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetReferencingSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencingSkipNavigations () As IEnumerable(Of SkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetReferencingSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;&#xA;override this.GetReferencingSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;" Usage="entityType.GetReferencingSkipNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRootType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType GetRootType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType GetRootType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetRootType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRootType () As EntityType" />
      <MemberSignature Language="F#" Value="abstract member GetRootType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&#xA;override this.GetRootType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="entityType.GetRootType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSeedData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IDictionary&lt;string,object&gt;&gt; GetSeedData (bool providerValues = false);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Collections.Generic.IDictionary`2&lt;string, object&gt;&gt; GetSeedData(bool providerValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetSeedData(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSeedData (Optional providerValues As Boolean = false) As IEnumerable(Of IDictionary(Of String, Object))" />
      <MemberSignature Language="F#" Value="abstract member GetSeedData : bool -&gt; seq&lt;System.Collections.Generic.IDictionary&lt;string, obj&gt;&gt;&#xA;override this.GetSeedData : bool -&gt; seq&lt;System.Collections.Generic.IDictionary&lt;string, obj&gt;&gt;" Usage="entityType.GetSeedData providerValues" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IDictionary&lt;string,object?&gt;&gt; GetSeedData (bool providerValues = false);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSeedData(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerValues" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="providerValues">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetServiceOnlyConstructorBindingConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? GetServiceOnlyConstructorBindingConfigurationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; GetServiceOnlyConstructorBindingConfigurationSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetServiceOnlyConstructorBindingConfigurationSource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServiceOnlyConstructorBindingConfigurationSource () As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member GetServiceOnlyConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.GetServiceOnlyConstructorBindingConfigurationSource : unit -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="entityType.GetServiceOnlyConstructorBindingConfigurationSource " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0">M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.GetServiceOnlyConstructorBindingConfigurationSource</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-8.0">M:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeTypeBase.GetServiceOnlyConstructorBindingConfigurationSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetServiceProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; GetServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt; GetServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServiceProperties () As IEnumerable(Of ServiceProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;&#xA;override this.GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;" Usage="entityType.GetServiceProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSkipNavigations">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt; GetSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSkipNavigations () As IEnumerable(Of SkipNavigation)" />
      <MemberSignature Language="F#" Value="abstract member GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;&#xA;override this.GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;" Usage="entityType.GetSkipNavigations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSnapshottableMembers">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetSnapshottableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt; GetSnapshottableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.GetSnapshottableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSnapshottableMembers () As IEnumerable(Of PropertyBase)" />
      <MemberSignature Language="F#" Value="override this.GetSnapshottableMembers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;" Usage="entityType.GetSnapshottableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasBaseType">
      <MemberSignature Language="C#" Value="public virtual void HasBaseType (Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType newBaseType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HasBaseType(class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType newBaseType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.HasBaseType(Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub HasBaseType (newBaseType As EntityType, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member HasBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.HasBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="entityType.HasBaseType (newBaseType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="newBaseType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasBaseType">
      <MemberSignature Language="C#" Value="public virtual void HasBaseType (Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType entityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HasBaseType(class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType entityType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.HasBaseType(Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub HasBaseType (entityType As EntityType, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit)" />
      <MemberSignature Language="F#" Value="abstract member HasBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.HasBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="entityType.HasBaseType (entityType, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasBaseType">
      <MemberSignature Language="C#" Value="public virtual void HasBaseType (Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType entityType, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HasBaseType(class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType entityType, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.HasBaseType(Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub HasBaseType (entityType As EntityType, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, Optional runConventions As Boolean = true)" />
      <MemberSignature Language="F#" Value="abstract member HasBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; unit&#xA;override this.HasBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; unit" Usage="entityType.HasBaseType (entityType, configurationSource, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasNoKey">
      <MemberSignature Language="C#" Value="public virtual void HasNoKey (bool? keyless, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HasNoKey(valuetype System.Nullable`1&lt;bool&gt; keyless, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.HasNoKey(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub HasNoKey (keyless As Nullable(Of Boolean), configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member HasNoKey : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.HasNoKey : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="entityType.HasNoKey (keyless, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyless" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="keyless">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasServiceProperties">
      <MemberSignature Language="C#" Value="public virtual bool HasServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.HasServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasServiceProperties () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member HasServiceProperties : unit -&gt; bool&#xA;override this.HasServiceProperties : unit -&gt; bool" Usage="entityType.HasServiceProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public virtual void Ignore (string name, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Ignore(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Ignore(System.String,Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Ignore (name As String, Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit)" />
      <MemberSignature Language="F#" Value="abstract member Ignore : string * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.Ignore : string * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="entityType.Ignore (name, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object&gt; InstanceFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt; InstanceFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.InstanceFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property InstanceFactory As Func(Of MaterializationContext, Object)" />
      <MemberSignature Language="F#" Value="member this.InstanceFactory : Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.InstanceFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0">P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.InstanceFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImplicitlyCreatedJoinEntityType">
      <MemberSignature Language="C#" Value="public virtual bool IsImplicitlyCreatedJoinEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImplicitlyCreatedJoinEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.IsImplicitlyCreatedJoinEntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsImplicitlyCreatedJoinEntityType As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsImplicitlyCreatedJoinEntityType : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.IsImplicitlyCreatedJoinEntityType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInModel">
      <MemberSignature Language="C#" Value="public virtual bool IsInModel { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.IsInModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInModel As Boolean" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="member this.IsInModel : bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.IsInModel" />
      <MemberSignature Language="C#" Value="public override bool IsInModel { get; }" FrameworkAlternate="efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsInModel As Boolean" FrameworkAlternate="efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.IsInModel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyless">
      <MemberSignature Language="C#" Value="public virtual bool IsKeyless { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyless" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.IsKeyless" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsKeyless As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsKeyless : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.IsKeyless" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.IsKeyless</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOwned">
      <MemberSignature Language="C#" Value="public virtual bool IsOwned ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsOwned() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.IsOwned" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsOwned () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsOwned : unit -&gt; bool&#xA;override this.IsOwned : unit -&gt; bool" Usage="entityType.IsOwned " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.IsOwned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsQueryType">
      <MemberSignature Language="C#" Value="public virtual bool IsQueryType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsQueryType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.IsQueryType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IsQueryType As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsQueryType : bool with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.IsQueryType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.IsQueryType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionAnnotatable#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionAnnotatableBuilder Implements IConventionAnnotatable.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotatable.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey IConventionEntityType.AddForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IConventionKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType principalEntityType, bool setComponentConfigurationSource, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IConventionKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType principalEntityType, bool setComponentConfigurationSource, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},Microsoft.EntityFrameworkCore.Metadata.IConventionKey,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddForeignKey (properties As IReadOnlyList(Of IConventionProperty), principalKey As IConventionKey, principalEntityType As IConventionEntityType, setComponentConfigurationSource As Boolean, fromDataAnnotation As Boolean) As IConventionForeignKey Implements IConventionEntityType.AddForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IConventionKey * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IConventionKey * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddForeignKey (properties, principalKey, principalEntityType, setComponentConfigurationSource, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey? IConventionEntityType.AddForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IConventionKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType principalEntityType, bool setComponentConfigurationSource, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},Microsoft.EntityFrameworkCore.Metadata.IConventionKey,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="setComponentConfigurationSource" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <param name="setComponentConfigurationSource">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex IConventionEntityType.AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddIndex (properties As IReadOnlyList(Of IConventionProperty), fromDataAnnotation As Boolean) As IConventionIndex Implements IConventionEntityType.AddIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex (properties, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex? IConventionEntityType.AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex IConventionEntityType.AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, string name, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, string name, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddIndex (properties As IReadOnlyList(Of IConventionProperty), name As String, fromDataAnnotation As Boolean) As IConventionIndex Implements IConventionEntityType.AddIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex (properties, name, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex? IConventionEntityType.AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, string name, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="name">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey IConventionEntityType.AddKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddKey (properties As IReadOnlyList(Of IConventionProperty), fromDataAnnotation As Boolean) As IConventionKey Implements IConventionEntityType.AddKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddKey (properties, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey? IConventionEntityType.AddKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty? IConventionEntityType.AddProperty (string name, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty(string name, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddProperty(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, fromDataAnnotation As Boolean) As IConventionProperty Implements IConventionEntityType.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty (name, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionEntityType.AddProperty (string name, bool fromDataAnnotation);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty? IConventionEntityType.AddProperty (string name, Type propertyType, bool setTypeConfigurationSource, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty(string name, class System.Type propertyType, bool setTypeConfigurationSource, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddProperty(System.String,System.Type,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, propertyType As Type, setTypeConfigurationSource As Boolean, fromDataAnnotation As Boolean) As IConventionProperty Implements IConventionEntityType.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty : string * Type * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty : string * Type * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty (name, propertyType, setTypeConfigurationSource, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionEntityType.AddProperty (string name, Type propertyType, bool setTypeConfigurationSource, bool fromDataAnnotation);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty(System.String,System.Type,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="setTypeConfigurationSource" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="setTypeConfigurationSource">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionEntityType.AddProperty (string name, Type propertyType, System.Reflection.MemberInfo memberInfo, bool setTypeConfigurationSource, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty(string name, class System.Type propertyType, class System.Reflection.MemberInfo memberInfo, bool setTypeConfigurationSource, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, propertyType As Type, memberInfo As MemberInfo, setTypeConfigurationSource As Boolean, fromDataAnnotation As Boolean) As IConventionProperty Implements IConventionEntityType.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty : string * Type * System.Reflection.MemberInfo * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty : string * Type * System.Reflection.MemberInfo * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty (name, propertyType, memberInfo, setTypeConfigurationSource, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty? IConventionEntityType.AddProperty (string name, Type propertyType, System.Reflection.MemberInfo? memberInfo, bool setTypeConfigurationSource, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddProperty(System.String,System.Type,System.Reflection.MemberInfo,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="setTypeConfigurationSource" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="setTypeConfigurationSource">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty IConventionEntityType.AddServiceProperty (System.Reflection.MemberInfo memberInfo, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty(class System.Reflection.MemberInfo memberInfo, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddServiceProperty(System.Reflection.MemberInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddServiceProperty (memberInfo As MemberInfo, fromDataAnnotation As Boolean) As IConventionServiceProperty Implements IConventionEntityType.AddServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty : System.Reflection.MemberInfo * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty : System.Reflection.MemberInfo * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty (memberInfo, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty(System.Reflection.MemberInfo,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty IConventionEntityType.AddServiceProperty (System.Reflection.MemberInfo memberInfo, Type serviceType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty(class System.Reflection.MemberInfo memberInfo, class System.Type serviceType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddServiceProperty(System.Reflection.MemberInfo,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddServiceProperty (memberInfo As MemberInfo, serviceType As Type, fromDataAnnotation As Boolean) As IConventionServiceProperty Implements IConventionEntityType.AddServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty : System.Reflection.MemberInfo * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty : System.Reflection.MemberInfo * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty (memberInfo, serviceType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddServiceProperty(System.Reflection.MemberInfo,System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="serviceType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="serviceType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation IConventionEntityType.AddSkipNavigation (string name, System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType targetEntityType, bool collection, bool onDependent, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation(string name, class System.Reflection.MemberInfo memberInfo, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType targetEntityType, bool collection, bool onDependent, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddSkipNavigation(System.String,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddSkipNavigation (name As String, memberInfo As MemberInfo, targetEntityType As IConventionEntityType, collection As Boolean, onDependent As Boolean, fromDataAnnotation As Boolean) As IConventionSkipNavigation Implements IConventionEntityType.AddSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation : string * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation : string * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation (name, memberInfo, targetEntityType, collection, onDependent, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation? IConventionEntityType.AddSkipNavigation (string name, System.Reflection.MemberInfo? memberInfo, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType targetEntityType, bool collection, bool onDependent, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation(System.String,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="targetEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="onDependent" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="targetEntityType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="onDependent">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation IConventionEntityType.AddSkipNavigation (string name, Type navigationType, System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType targetEntityType, bool collection, bool onDependent, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation(string name, class System.Type navigationType, class System.Reflection.MemberInfo memberInfo, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType targetEntityType, bool collection, bool onDependent, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddSkipNavigation(System.String,System.Type,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddSkipNavigation (name As String, navigationType As Type, memberInfo As MemberInfo, targetEntityType As IConventionEntityType, collection As Boolean, onDependent As Boolean, fromDataAnnotation As Boolean) As IConventionSkipNavigation Implements IConventionEntityType.AddSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation : string * Type * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation : string * Type * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation (name, navigationType, memberInfo, targetEntityType, collection, onDependent, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddSkipNavigation(System.String,System.Type,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="navigationType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="onDependent" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="6" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="navigationType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="targetEntityType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="onDependent">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddTrigger">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger IConventionEntityType.AddTrigger (string name, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddTrigger(string name, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#AddTrigger(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddTrigger (name As String, fromDataAnnotation As Boolean) As IConventionTrigger Implements IConventionEntityType.AddTrigger" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddTrigger : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddTrigger : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddTrigger (name, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.AddTrigger(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.BaseType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.BaseType { get; }" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#BaseType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property BaseType As IConventionEntityType Implements IConventionEntityType.BaseType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.BaseType : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.BaseType" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType? Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.BaseType { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Builder">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionEntityTypeBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Builder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionEntityTypeBuilder Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Builder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#Builder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Builder As IConventionEntityTypeBuilder Implements IConventionEntityType.Builder" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Builder : Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionEntityTypeBuilder" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Builder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Builder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionEntityTypeBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.DefiningEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.DefiningEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.DefiningEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#DefiningEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DefiningEntityType As IConventionEntityType Implements IConventionEntityType.DefiningEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.DefiningEntityType : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.DefiningEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.DefiningEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindDeclaredTrigger">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger IConventionEntityType.FindDeclaredTrigger (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindDeclaredTrigger(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindDeclaredTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredTrigger (name As String) As IConventionTrigger Implements IConventionEntityType.FindDeclaredTrigger" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindDeclaredTrigger name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindDeclaredTrigger(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey IConventionEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function FindForeignKey (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType) As IConventionForeignKey Implements IConventionEntityType.FindForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey? IConventionEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function FindForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As IConventionForeignKey Implements IConventionEntityType.FindForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey IConventionEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex IConventionEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (properties As IReadOnlyList(Of IProperty)) As IConventionIndex Implements IConventionEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex? IConventionEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As IConventionIndex Implements IConventionEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex IConventionEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex IConventionEntityType.FindIndex (string name);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindIndex(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (name As String) As IConventionIndex Implements IConventionEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex? IConventionEntityType.FindIndex (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindIndex(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey IConventionEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindKey (properties As IReadOnlyList(Of IProperty)) As IConventionKey Implements IConventionEntityType.FindKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey? IConventionEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As IConventionKey Implements IConventionEntityType.FindKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey IConventionEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindPrimaryKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey IConventionEntityType.FindPrimaryKey ();" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindPrimaryKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindPrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Function FindPrimaryKey () As IConventionKey Implements IConventionEntityType.FindPrimaryKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindPrimaryKey " />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey? IConventionEntityType.FindPrimaryKey ();" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindPrimaryKey</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionEntityType.FindProperty (string name);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IConventionProperty Implements IConventionEntityType.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty? IConventionEntityType.FindProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty IConventionEntityType.FindServiceProperty (string name);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindServiceProperty (name As String) As IConventionServiceProperty Implements IConventionEntityType.FindServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindServiceProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty? IConventionEntityType.FindServiceProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindServiceProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation IConventionEntityType.FindSkipNavigation (string name);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#FindSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindSkipNavigation (name As String) As IConventionSkipNavigation Implements IConventionEntityType.FindSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindSkipNavigation name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation? IConventionEntityType.FindSkipNavigation (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.FindSkipNavigation(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetDeclaredTriggers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger&gt; IConventionEntityType.GetDeclaredTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetDeclaredTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#GetDeclaredTriggers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredTriggers () As IEnumerable(Of IConventionTrigger) Implements IConventionEntityType.GetDeclaredTriggers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetDeclaredTriggers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetDeclaredTriggers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt; IConventionEntityType.GetForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#GetForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetForeignKeys () As IEnumerable(Of IConventionForeignKey) Implements IConventionEntityType.GetForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt; IConventionEntityType.GetIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#GetIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetIndexes () As IEnumerable(Of IConventionIndex) Implements IConventionEntityType.GetIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetIndexes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt; IConventionEntityType.GetKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#GetKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetKeys () As IEnumerable(Of IConventionKey) Implements IConventionEntityType.GetKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; IConventionEntityType.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IConventionProperty) Implements IConventionEntityType.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetServiceProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&gt; IConventionEntityType.GetServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#GetServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetServiceProperties () As IEnumerable(Of IConventionServiceProperty) Implements IConventionEntityType.GetServiceProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetServiceProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetServiceProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetSkipNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&gt; IConventionEntityType.GetSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#GetSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetSkipNavigations () As IEnumerable(Of IConventionSkipNavigation) Implements IConventionEntityType.GetSkipNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetSkipNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.GetSkipNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasBaseType">
      <MemberSignature Language="C#" Value="void IConventionEntityType.HasBaseType (Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType entityType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasBaseType(class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType entityType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#HasBaseType(Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub HasBaseType (entityType As IConventionEntityType, fromDataAnnotation As Boolean) Implements IConventionEntityType.HasBaseType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasBaseType : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasBaseType : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasBaseType (entityType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasBaseType(Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasNoKey">
      <MemberSignature Language="C#" Value="void IConventionEntityType.HasNoKey (bool? keyless, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasNoKey(valuetype System.Nullable`1&lt;bool&gt; keyless, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#HasNoKey(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub HasNoKey (keyless As Nullable(Of Boolean), fromDataAnnotation As Boolean) Implements IConventionEntityType.HasNoKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasNoKey : Nullable&lt;bool&gt; * bool -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasNoKey : Nullable&lt;bool&gt; * bool -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasNoKey (keyless, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.HasNoKey(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyless" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="keyless">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionModel Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionModel Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IConventionModel Implements IConventionEntityType.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Model : Microsoft.EntityFrameworkCore.Metadata.IConventionModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey">
      <MemberSignature Language="C#" Value="void IConventionEntityType.RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey foreignKey);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey foreignKey) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveForeignKey(Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveForeignKey (foreignKey As IConventionForeignKey) Implements IConventionEntityType.RemoveForeignKey" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey foreignKey" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey IConventionEntityType.RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey foreignKey);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey foreignKey) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Function RemoveForeignKey (foreignKey As IConventionForeignKey) As IConventionForeignKey Implements IConventionEntityType.RemoveForeignKey" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey foreignKey" FrameworkAlternate="efcore-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey(Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey? IConventionEntityType.RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey foreignKey);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveForeignKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveForeignKey (foreignKey As IReadOnlyForeignKey) As IConventionForeignKey Implements IConventionEntityType.RemoveForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey foreignKey" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey IConventionEntityType.RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey foreignKey);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey? IConventionEntityType.RemoveForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IConventionKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType principalEntityType);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IConventionKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IConventionKey,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IConventionKey, principalEntityType As IConventionEntityType) As IConventionForeignKey Implements IConventionEntityType.RemoveForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IConventionKey * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IConventionKey * Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey (properties, principalKey, principalEntityType)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey IConventionEntityType.RemoveForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IConventionKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType principalEntityType);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IConventionKey,Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex">
      <MemberSignature Language="C#" Value="void IConventionEntityType.RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.IConventionIndex index);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex(class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex index) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveIndex(Microsoft.EntityFrameworkCore.Metadata.IConventionIndex)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveIndex (index As IConventionIndex) Implements IConventionEntityType.RemoveIndex" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IConventionIndex -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IConventionIndex -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex index" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex IConventionEntityType.RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.IConventionIndex index);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex(class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex index) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Function RemoveIndex (index As IConventionIndex) As IConventionIndex Implements IConventionEntityType.RemoveIndex" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IConventionIndex -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IConventionIndex -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex index" FrameworkAlternate="efcore-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex(Microsoft.EntityFrameworkCore.Metadata.IConventionIndex)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IConventionIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex? IConventionEntityType.RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex index);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveIndex(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveIndex (index As IReadOnlyIndex) As IConventionIndex Implements IConventionEntityType.RemoveIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex index" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex IConventionEntityType.RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex index);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex? IConventionEntityType.RemoveIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionIndex Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function RemoveIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As IConventionIndex Implements IConventionEntityType.RemoveIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionIndex IConventionEntityType.RemoveIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey">
      <MemberSignature Language="C#" Value="void IConventionEntityType.RemoveKey (Microsoft.EntityFrameworkCore.Metadata.IConventionKey key);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey(class Microsoft.EntityFrameworkCore.Metadata.IConventionKey key) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveKey(Microsoft.EntityFrameworkCore.Metadata.IConventionKey)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveKey (key As IConventionKey) Implements IConventionEntityType.RemoveKey" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IConventionKey -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IConventionKey -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey key" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey IConventionEntityType.RemoveKey (Microsoft.EntityFrameworkCore.Metadata.IConventionKey key);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey(class Microsoft.EntityFrameworkCore.Metadata.IConventionKey key) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Function RemoveKey (key As IConventionKey) As IConventionKey Implements IConventionEntityType.RemoveKey" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IConventionKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IConventionKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey key" FrameworkAlternate="efcore-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey(Microsoft.EntityFrameworkCore.Metadata.IConventionKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IConventionKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey? IConventionEntityType.RemoveKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey key);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveKey (key As IReadOnlyKey) As IConventionKey Implements IConventionEntityType.RemoveKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey key" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey IConventionEntityType.RemoveKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey key);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey? IConventionEntityType.RemoveKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function RemoveKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As IConventionKey Implements IConventionEntityType.RemoveKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey IConventionEntityType.RemoveKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty">
      <MemberSignature Language="C#" Value="void IConventionEntityType.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IConventionProperty property);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty property) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveProperty (property As IConventionProperty) Implements IConventionEntityType.RemoveProperty" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionProperty -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionProperty -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty property" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionEntityType.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IConventionProperty property);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty property) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (property As IConventionProperty) As IConventionProperty Implements IConventionEntityType.RemoveProperty" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty property" FrameworkAlternate="efcore-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty? IConventionEntityType.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (property As IReadOnlyProperty) As IConventionProperty Implements IConventionEntityType.RemoveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty property" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionEntityType.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty? IConventionEntityType.RemoveProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (name As String) As IConventionProperty Implements IConventionEntityType.RemoveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionEntityType.RemoveProperty (string name);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty? IConventionEntityType.RemoveServiceProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty property);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveServiceProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveServiceProperty (property As IReadOnlyServiceProperty) As IConventionServiceProperty Implements IConventionEntityType.RemoveServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty property" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty IConventionEntityType.RemoveServiceProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty property);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty IConventionEntityType.RemoveServiceProperty (string name);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveServiceProperty (name As String) As IConventionServiceProperty Implements IConventionEntityType.RemoveServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty? IConventionEntityType.RemoveServiceProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveServiceProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation IConventionEntityType.RemoveSkipNavigation (Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation navigation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation(class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation navigation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveSkipNavigation(Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveSkipNavigation (navigation As IConventionSkipNavigation) As IConventionSkipNavigation Implements IConventionEntityType.RemoveSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation navigation" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation(Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation" Index="0" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="navigation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation? IConventionEntityType.RemoveSkipNavigation (Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation navigation);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation navigation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveSkipNavigation(Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveSkipNavigation (navigation As IReadOnlySkipNavigation) As IConventionSkipNavigation Implements IConventionEntityType.RemoveSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation navigation" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation IConventionEntityType.RemoveSkipNavigation (Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation navigation);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveSkipNavigation(Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigation" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="navigation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveTrigger">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger IConventionEntityType.RemoveTrigger (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveTrigger(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#RemoveTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveTrigger (name As String) As IConventionTrigger Implements IConventionEntityType.RemoveTrigger" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveTrigger name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.RemoveTrigger(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionTrigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetBaseType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType IConventionEntityType.SetBaseType (Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType entityType, bool fromDataAnnotation);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetBaseType(class Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType entityType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#SetBaseType(Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetBaseType (entityType As IConventionEntityType, fromDataAnnotation As Boolean) As IConventionEntityType Implements IConventionEntityType.SetBaseType" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetBaseType : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetBaseType : Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetBaseType (entityType, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType? IConventionEntityType.SetBaseType (Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType? entityType, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetBaseType(Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? IConventionEntityType.SetChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy), fromDataAnnotation As Boolean) As Nullable(Of ChangeTrackingStrategy) Implements IConventionEntityType.SetChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetChangeTrackingStrategy (changeTrackingStrategy, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetDiscriminatorProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty? IConventionEntityType.SetDiscriminatorProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty? property, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetDiscriminatorProperty(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#SetDiscriminatorProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetDiscriminatorProperty (property As IReadOnlyProperty, fromDataAnnotation As Boolean) As IConventionProperty Implements IConventionEntityType.SetDiscriminatorProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetDiscriminatorProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetDiscriminatorProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetDiscriminatorProperty (property, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty IConventionEntityType.SetDiscriminatorProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property, bool fromDataAnnotation);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetDiscriminatorProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetIsKeyless">
      <MemberSignature Language="C#" Value="bool? IConventionEntityType.SetIsKeyless (bool? keyless, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetIsKeyless(valuetype System.Nullable`1&lt;bool&gt; keyless, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#SetIsKeyless(System.Nullable{System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetIsKeyless (keyless As Nullable(Of Boolean), fromDataAnnotation As Boolean) As Nullable(Of Boolean) Implements IConventionEntityType.SetIsKeyless" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetIsKeyless : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetIsKeyless : Nullable&lt;bool&gt; * bool -&gt; Nullable&lt;bool&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetIsKeyless (keyless, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetIsKeyless(System.Nullable{System.Boolean},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyless" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="keyless">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetPrimaryKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey IConventionEntityType.SetPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, bool fromDataAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionKey Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetPrimaryKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#SetPrimaryKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetPrimaryKey (properties As IReadOnlyList(Of IConventionProperty), fromDataAnnotation As Boolean) As IConventionKey Implements IConventionEntityType.SetPrimaryKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetPrimaryKey (properties, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionKey? IConventionEntityType.SetPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;? properties, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetPrimaryKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetQueryFilter">
      <MemberSignature Language="C#" Value="System.Linq.Expressions.LambdaExpression? IConventionEntityType.SetQueryFilter (System.Linq.Expressions.LambdaExpression? queryFilter, bool fromDataAnnotation);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Linq.Expressions.LambdaExpression Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetQueryFilter(class System.Linq.Expressions.LambdaExpression queryFilter, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IConventionEntityType#SetQueryFilter(System.Linq.Expressions.LambdaExpression,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function SetQueryFilter (queryFilter As LambdaExpression, fromDataAnnotation As Boolean) As LambdaExpression Implements IConventionEntityType.SetQueryFilter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetQueryFilter : System.Linq.Expressions.LambdaExpression * bool -&gt; System.Linq.Expressions.LambdaExpression&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetQueryFilter : System.Linq.Expressions.LambdaExpression * bool -&gt; System.Linq.Expressions.LambdaExpression" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetQueryFilter (queryFilter, fromDataAnnotation)" />
      <MemberSignature Language="C#" Value="System.Linq.Expressions.LambdaExpression IConventionEntityType.SetQueryFilter (System.Linq.Expressions.LambdaExpression queryFilter, bool fromDataAnnotation);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IConventionEntityType.SetQueryFilter(System.Linq.Expressions.LambdaExpression,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queryFilter" Type="System.Linq.Expressions.LambdaExpression" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="queryFilter">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.BaseType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.IEntityType.BaseType { get; }" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.IEntityType.BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#BaseType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property BaseType As IEntityType Implements IEntityType.BaseType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.BaseType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IEntityType.BaseType" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IEntityType? Microsoft.EntityFrameworkCore.Metadata.IEntityType.BaseType { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IEntityType.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.ClrType">
      <MemberSignature Language="C#" Value="Type Microsoft.EntityFrameworkCore.Metadata.IEntityType.ClrType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Microsoft.EntityFrameworkCore.Metadata.IEntityType.ClrType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#ClrType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ClrType As Type Implements IEntityType.ClrType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.ClrType : Type" Usage="Microsoft.EntityFrameworkCore.Metadata.IEntityType.ClrType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IEntityType.ClrType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.DefiningEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.IEntityType.DefiningEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType Microsoft.EntityFrameworkCore.Metadata.IEntityType.DefiningEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#DefiningEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DefiningEntityType As IEntityType Implements IEntityType.DefiningEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.DefiningEntityType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IEntityType.DefiningEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IEntityType.DefiningEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; IEntityType.FindDeclaredForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindDeclaredForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of IForeignKey) Implements IEntityType.FindDeclaredForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredForeignKeys properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.INavigation? IEntityType.FindDeclaredNavigation (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.INavigation Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindDeclaredNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredNavigation (name As String) As INavigation Implements IEntityType.FindDeclaredNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.INavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.INavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredNavigation name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.INavigation IEntityType.FindDeclaredNavigation (string name);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredNavigation(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.INavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IProperty? IEntityType.FindDeclaredProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IProperty Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredProperty (name As String) As IProperty Implements IEntityType.FindDeclaredProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IProperty IEntityType.FindDeclaredProperty (string name);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation IEntityType.FindDeclaredSkipNavigation (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindDeclaredSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredSkipNavigation (name As String) As ISkipNavigation Implements IEntityType.FindDeclaredSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredSkipNavigation name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredSkipNavigation(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredTrigger">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ITrigger IEntityType.FindDeclaredTrigger (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.ITrigger Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredTrigger(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindDeclaredTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredTrigger (name As String) As ITrigger Implements IEntityType.FindDeclaredTrigger" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.ITrigger&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.ITrigger" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredTrigger name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindDeclaredTrigger(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ITrigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IForeignKey IEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IForeignKey Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function FindForeignKey (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType) As IForeignKey Implements IEntityType.FindForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IForeignKey? IEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IForeignKey Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function FindForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As IForeignKey Implements IEntityType.FindForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IForeignKey IEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; IEntityType.FindForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of IForeignKey) Implements IEntityType.FindForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKeys properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IIndex IEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IIndex Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (properties As IReadOnlyList(Of IProperty)) As IIndex Implements IEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IIndex? IEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IIndex Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As IIndex Implements IEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IIndex IEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IIndex IEntityType.FindIndex (string name);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IIndex Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindIndex(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (name As String) As IIndex Implements IEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IIndex? IEntityType.FindIndex (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindIndex(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IKey IEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IKey Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindKey (properties As IReadOnlyList(Of IProperty)) As IKey Implements IEntityType.FindKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IKey? IEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IKey Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As IKey Implements IEntityType.FindKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IKey IEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindPrimaryKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IKey IEntityType.FindPrimaryKey ();" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IKey Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindPrimaryKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindPrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Function FindPrimaryKey () As IKey Implements IEntityType.FindPrimaryKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindPrimaryKey " />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IKey? IEntityType.FindPrimaryKey ();" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindPrimaryKey</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IProperty IEntityType.FindProperty (string name);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IProperty Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IProperty Implements IEntityType.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IProperty? IEntityType.FindProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IServiceProperty IEntityType.FindServiceProperty (string name);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IServiceProperty Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindServiceProperty (name As String) As IServiceProperty Implements IEntityType.FindServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindServiceProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IServiceProperty? IEntityType.FindServiceProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindServiceProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation IEntityType.FindSkipNavigation (System.Reflection.MemberInfo memberInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindSkipNavigation(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Function FindSkipNavigation (memberInfo As MemberInfo) As ISkipNavigation Implements IEntityType.FindSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation memberInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation(System.Reflection.MemberInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation IEntityType.FindSkipNavigation (string name);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#FindSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindSkipNavigation (name As String) As ISkipNavigation Implements IEntityType.FindSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation? IEntityType.FindSkipNavigation (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.FindSkipNavigation(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; IEntityType.GetDeclaredForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDeclaredForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredForeignKeys () As IEnumerable(Of IForeignKey) Implements IEntityType.GetDeclaredForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; IEntityType.GetDeclaredIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDeclaredIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredIndexes () As IEnumerable(Of IIndex) Implements IEntityType.GetDeclaredIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredIndexes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt; IEntityType.GetDeclaredKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IKey&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDeclaredKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredKeys () As IEnumerable(Of IKey) Implements IEntityType.GetDeclaredKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation&gt; IEntityType.GetDeclaredNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.INavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDeclaredNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredNavigations () As IEnumerable(Of INavigation) Implements IEntityType.GetDeclaredNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; IEntityType.GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredProperties () As IEnumerable(Of IProperty) Implements IEntityType.GetDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredReferencingForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; IEntityType.GetDeclaredReferencingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredReferencingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDeclaredReferencingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredReferencingForeignKeys () As IEnumerable(Of IForeignKey) Implements IEntityType.GetDeclaredReferencingForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredReferencingForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredReferencingForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredServiceProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt; IEntityType.GetDeclaredServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDeclaredServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredServiceProperties () As IEnumerable(Of IServiceProperty) Implements IEntityType.GetDeclaredServiceProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredServiceProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredServiceProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredSkipNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt; IEntityType.GetDeclaredSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDeclaredSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredSkipNavigations () As IEnumerable(Of ISkipNavigation) Implements IEntityType.GetDeclaredSkipNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredSkipNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredSkipNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredTriggers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ITrigger&gt; IEntityType.GetDeclaredTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.ITrigger&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDeclaredTriggers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredTriggers () As IEnumerable(Of ITrigger) Implements IEntityType.GetDeclaredTriggers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.ITrigger&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.ITrigger&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredTriggers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDeclaredTriggers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ITrigger&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; IEntityType.GetDerivedForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDerivedForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedForeignKeys () As IEnumerable(Of IForeignKey) Implements IEntityType.GetDerivedForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; IEntityType.GetDerivedIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDerivedIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedIndexes () As IEnumerable(Of IIndex) Implements IEntityType.GetDerivedIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedIndexes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDerivedIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IEntityType&gt; IEntityType.GetDirectlyDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IEntityType&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDirectlyDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Function GetDirectlyDerivedTypes () As IEnumerable(Of IEntityType) Implements IEntityType.GetDirectlyDerivedTypes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IEntityType&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IEntityType&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDirectlyDerivedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetDirectlyDerivedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeyProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; IEntityType.GetForeignKeyProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeyProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetForeignKeyProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetForeignKeyProperties () As IEnumerable(Of IProperty) Implements IEntityType.GetForeignKeyProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeyProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeyProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeyProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeyProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; IEntityType.GetForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetForeignKeys () As IEnumerable(Of IForeignKey) Implements IEntityType.GetForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; IEntityType.GetIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetIndexes () As IEnumerable(Of IIndex) Implements IEntityType.GetIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetIndexes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt; IEntityType.GetKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IKey&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetKeys () As IEnumerable(Of IKey) Implements IEntityType.GetKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation&gt; IEntityType.GetNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.INavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetNavigations () As IEnumerable(Of INavigation) Implements IEntityType.GetNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.INavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; IEntityType.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IProperty) Implements IEntityType.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetReferencingForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; IEntityType.GetReferencingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetReferencingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetReferencingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetReferencingForeignKeys () As IEnumerable(Of IForeignKey) Implements IEntityType.GetReferencingForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetReferencingForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetReferencingForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetServiceProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt; IEntityType.GetServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetServiceProperties () As IEnumerable(Of IServiceProperty) Implements IEntityType.GetServiceProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetServiceProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetServiceProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetSkipNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt; IEntityType.GetSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetSkipNavigations () As IEnumerable(Of ISkipNavigation) Implements IEntityType.GetSkipNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetSkipNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetSkipNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.ISkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetValueGeneratingProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; IEntityType.GetValueGeneratingProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetValueGeneratingProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#GetValueGeneratingProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetValueGeneratingProperties () As IEnumerable(Of IProperty) Implements IEntityType.GetValueGeneratingProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetValueGeneratingProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetValueGeneratingProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetValueGeneratingProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetValueGeneratingProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IEntityType.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.IEntityType.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.IEntityType.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IEntityType#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IModel Implements IEntityType.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IEntityType.Model : Microsoft.EntityFrameworkCore.Metadata.IModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IEntityType.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IEntityType.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey IMutableEntityType.AddForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IMutableKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IMutableKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty},Microsoft.EntityFrameworkCore.Metadata.IMutableKey,Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function AddForeignKey (properties As IReadOnlyList(Of IMutableProperty), principalKey As IMutableKey, principalEntityType As IMutableEntityType) As IMutableForeignKey Implements IMutableEntityType.AddForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IMutableKey * Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IMutableKey * Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty},Microsoft.EntityFrameworkCore.Metadata.IMutableKey,Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableKey" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex IMutableEntityType.AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty})" />
      <MemberSignature Language="VB.NET" Value="Function AddIndex (properties As IReadOnlyList(Of IMutableProperty)) As IMutableIndex Implements IMutableEntityType.AddIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex IMutableEntityType.AddIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties, string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty},System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AddIndex (properties As IReadOnlyList(Of IMutableProperty), name As String) As IMutableIndex Implements IMutableEntityType.AddIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; * string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; * string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex (properties, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey IMutableEntityType.AddKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty})" />
      <MemberSignature Language="VB.NET" Value="Function AddKey (properties As IReadOnlyList(Of IMutableProperty)) As IMutableKey Implements IMutableEntityType.AddKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddKey properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableEntityType.AddProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String) As IMutableProperty Implements IMutableEntityType.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableEntityType.AddProperty (string name, Type propertyType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty(string name, class System.Type propertyType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, propertyType As Type) As IMutableProperty Implements IMutableEntityType.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty : string * Type -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty : string * Type -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty (name, propertyType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-6.0;efcore-7.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-6.0;efcore-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableEntityType.AddProperty (string name, Type propertyType, bool shadow);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty(string name, class System.Type propertyType, bool shadow) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddProperty(System.String,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, propertyType As Type, shadow As Boolean) As IMutableProperty Implements IMutableEntityType.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty : string * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty : string * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty (name, propertyType, shadow)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty(System.String,System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-1.0" />
        <Parameter Name="shadow" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="shadow">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableEntityType.AddProperty (string name, Type propertyType, System.Reflection.MemberInfo memberInfo);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty(string name, class System.Type propertyType, class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddProperty(System.String,System.Type,System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Function AddProperty (name As String, propertyType As Type, memberInfo As MemberInfo) As IMutableProperty Implements IMutableEntityType.AddProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty : string * Type * System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty : string * Type * System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty (name, propertyType, memberInfo)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableEntityType.AddProperty (string name, Type propertyType, System.Reflection.MemberInfo? memberInfo);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddProperty(System.String,System.Type,System.Reflection.MemberInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="propertyType" Type="System.Type" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="efcore-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty IMutableEntityType.AddServiceProperty (System.Reflection.MemberInfo memberInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddServiceProperty(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Function AddServiceProperty (memberInfo As MemberInfo) As IMutableServiceProperty Implements IMutableEntityType.AddServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty memberInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty(System.Reflection.MemberInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty IMutableEntityType.AddServiceProperty (System.Reflection.MemberInfo memberInfo, Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty(class System.Reflection.MemberInfo memberInfo, class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddServiceProperty(System.Reflection.MemberInfo,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function AddServiceProperty (memberInfo As MemberInfo, serviceType As Type) As IMutableServiceProperty Implements IMutableEntityType.AddServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty : System.Reflection.MemberInfo * Type -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty : System.Reflection.MemberInfo * Type -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty (memberInfo, serviceType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddServiceProperty(System.Reflection.MemberInfo,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="serviceType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="serviceType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation IMutableEntityType.AddSkipNavigation (string name, System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType targetEntityType, bool collection, bool onDependent);" FrameworkAlternate="efcore-5.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation(string name, class System.Reflection.MemberInfo memberInfo, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType targetEntityType, bool collection, bool onDependent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddSkipNavigation(System.String,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddSkipNavigation (name As String, memberInfo As MemberInfo, targetEntityType As IMutableEntityType, collection As Boolean, onDependent As Boolean) As IMutableSkipNavigation Implements IMutableEntityType.AddSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation : string * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation : string * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation (name, memberInfo, targetEntityType, collection, onDependent)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation IMutableEntityType.AddSkipNavigation (string name, System.Reflection.MemberInfo? memberInfo, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType targetEntityType, bool collection, bool onDependent);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation(System.String,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="targetEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" Index="2" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="onDependent" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="targetEntityType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="onDependent">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation IMutableEntityType.AddSkipNavigation (string name, Type navigationType, System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType targetEntityType, bool collection, bool onDependent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation(string name, class System.Type navigationType, class System.Reflection.MemberInfo memberInfo, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType targetEntityType, bool collection, bool onDependent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddSkipNavigation(System.String,System.Type,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AddSkipNavigation (name As String, navigationType As Type, memberInfo As MemberInfo, targetEntityType As IMutableEntityType, collection As Boolean, onDependent As Boolean) As IMutableSkipNavigation Implements IMutableEntityType.AddSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation : string * Type * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation : string * Type * System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation (name, navigationType, memberInfo, targetEntityType, collection, onDependent)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddSkipNavigation(System.String,System.Type,System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="navigationType" Type="System.Type" Index="1" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="2" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="targetEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" Index="3" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="collection" Type="System.Boolean" Index="4" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="onDependent" Type="System.Boolean" Index="5" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="navigationType">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="targetEntityType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="onDependent">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddTrigger">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger IMutableEntityType.AddTrigger (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddTrigger(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#AddTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AddTrigger (name As String) As IMutableTrigger Implements IMutableEntityType.AddTrigger" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddTrigger name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.AddTrigger(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.BaseType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.BaseType { get; set; }" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#BaseType" />
      <MemberSignature Language="VB.NET" Value=" Property BaseType As IMutableEntityType Implements IMutableEntityType.BaseType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.BaseType : Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.BaseType" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType? Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.BaseType { get; set; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.DefiningEntityType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.DefiningEntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.DefiningEntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#DefiningEntityType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DefiningEntityType As IMutableEntityType Implements IMutableEntityType.DefiningEntityType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.DefiningEntityType : Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.DefiningEntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.DefiningEntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindDeclaredTrigger">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger IMutableEntityType.FindDeclaredTrigger (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindDeclaredTrigger(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindDeclaredTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredTrigger (name As String) As IMutableTrigger Implements IMutableEntityType.FindDeclaredTrigger" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindDeclaredTrigger name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindDeclaredTrigger(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey IMutableEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function FindForeignKey (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType) As IMutableForeignKey Implements IMutableEntityType.FindForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey? IMutableEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function FindForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As IMutableForeignKey Implements IMutableEntityType.FindForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey IMutableEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex IMutableEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (properties As IReadOnlyList(Of IProperty)) As IMutableIndex Implements IMutableEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex? IMutableEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As IMutableIndex Implements IMutableEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex IMutableEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex IMutableEntityType.FindIndex (string name);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindIndex(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (name As String) As IMutableIndex Implements IMutableEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex? IMutableEntityType.FindIndex (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindIndex(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey IMutableEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindKey (properties As IReadOnlyList(Of IProperty)) As IMutableKey Implements IMutableEntityType.FindKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey? IMutableEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As IMutableKey Implements IMutableEntityType.FindKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey IMutableEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindPrimaryKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey IMutableEntityType.FindPrimaryKey ();" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindPrimaryKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindPrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Function FindPrimaryKey () As IMutableKey Implements IMutableEntityType.FindPrimaryKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindPrimaryKey " />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey? IMutableEntityType.FindPrimaryKey ();" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindPrimaryKey</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableEntityType.FindProperty (string name);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IMutableProperty Implements IMutableEntityType.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty? IMutableEntityType.FindProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty IMutableEntityType.FindServiceProperty (string name);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindServiceProperty (name As String) As IMutableServiceProperty Implements IMutableEntityType.FindServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindServiceProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty? IMutableEntityType.FindServiceProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindServiceProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation IMutableEntityType.FindSkipNavigation (string name);" FrameworkAlternate="efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#FindSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindSkipNavigation (name As String) As IMutableSkipNavigation Implements IMutableEntityType.FindSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindSkipNavigation name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation? IMutableEntityType.FindSkipNavigation (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.FindSkipNavigation(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetDeclaredTriggers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger&gt; IMutableEntityType.GetDeclaredTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetDeclaredTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#GetDeclaredTriggers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredTriggers () As IEnumerable(Of IMutableTrigger) Implements IMutableEntityType.GetDeclaredTriggers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetDeclaredTriggers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetDeclaredTriggers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt; IMutableEntityType.GetForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#GetForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetForeignKeys () As IEnumerable(Of IMutableForeignKey) Implements IMutableEntityType.GetForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt; IMutableEntityType.GetIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#GetIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetIndexes () As IEnumerable(Of IMutableIndex) Implements IMutableEntityType.GetIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetIndexes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt; IMutableEntityType.GetKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#GetKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetKeys () As IEnumerable(Of IMutableKey) Implements IMutableEntityType.GetKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; IMutableEntityType.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IMutableProperty) Implements IMutableEntityType.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetServiceProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&gt; IMutableEntityType.GetServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#GetServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetServiceProperties () As IEnumerable(Of IMutableServiceProperty) Implements IMutableEntityType.GetServiceProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetServiceProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetServiceProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetSkipNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&gt; IMutableEntityType.GetSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#GetSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetSkipNavigations () As IEnumerable(Of IMutableSkipNavigation) Implements IMutableEntityType.GetSkipNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetSkipNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.GetSkipNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IMutableModel Implements IMutableEntityType.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.Model : Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.QueryFilter">
      <MemberSignature Language="C#" Value="System.Linq.Expressions.LambdaExpression Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.QueryFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.Expressions.LambdaExpression Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.QueryFilter" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#QueryFilter" />
      <MemberSignature Language="VB.NET" Value=" Property QueryFilter As LambdaExpression Implements IMutableEntityType.QueryFilter" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.QueryFilter : System.Linq.Expressions.LambdaExpression with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.QueryFilter" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.QueryFilter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey">
      <MemberSignature Language="C#" Value="void IMutableEntityType.RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey foreignKey);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey foreignKey) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveForeignKey(Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveForeignKey (foreignKey As IMutableForeignKey) Implements IMutableEntityType.RemoveForeignKey" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey foreignKey" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey IMutableEntityType.RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey foreignKey);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey foreignKey) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Function RemoveForeignKey (foreignKey As IMutableForeignKey) As IMutableForeignKey Implements IMutableEntityType.RemoveForeignKey" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey foreignKey" FrameworkAlternate="efcore-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey(Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey? IMutableEntityType.RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey foreignKey);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveForeignKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveForeignKey (foreignKey As IReadOnlyForeignKey) As IMutableForeignKey Implements IMutableEntityType.RemoveForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey foreignKey" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey IMutableEntityType.RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey foreignKey);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey IMutableEntityType.RemoveForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveForeignKey (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType) As IMutableForeignKey Implements IMutableEntityType.RemoveForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey? IMutableEntityType.RemoveForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IMutableKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType principalEntityType);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IMutableKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IMutableKey,Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IMutableKey, principalEntityType As IMutableEntityType) As IMutableForeignKey Implements IMutableEntityType.RemoveForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IMutableKey * Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IMutableKey * Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey (properties, principalKey, principalEntityType)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey IMutableEntityType.RemoveForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IMutableKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType principalEntityType);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IMutableKey,Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex">
      <MemberSignature Language="C#" Value="void IMutableEntityType.RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.IMutableIndex index);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex(class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex index) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveIndex(Microsoft.EntityFrameworkCore.Metadata.IMutableIndex)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveIndex (index As IMutableIndex) Implements IMutableEntityType.RemoveIndex" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IMutableIndex -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IMutableIndex -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex index" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex IMutableEntityType.RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.IMutableIndex index);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex(class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex index) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Function RemoveIndex (index As IMutableIndex) As IMutableIndex Implements IMutableEntityType.RemoveIndex" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IMutableIndex -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IMutableIndex -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex index" FrameworkAlternate="efcore-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex(Microsoft.EntityFrameworkCore.Metadata.IMutableIndex)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IMutableIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex? IMutableEntityType.RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex index);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveIndex(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveIndex (index As IReadOnlyIndex) As IMutableIndex Implements IMutableEntityType.RemoveIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex index" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex IMutableEntityType.RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex index);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex IMutableEntityType.RemoveIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Function RemoveIndex (properties As IReadOnlyList(Of IProperty)) As IMutableIndex Implements IMutableEntityType.RemoveIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex? IMutableEntityType.RemoveIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableIndex Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function RemoveIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As IMutableIndex Implements IMutableEntityType.RemoveIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableIndex IMutableEntityType.RemoveIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey">
      <MemberSignature Language="C#" Value="void IMutableEntityType.RemoveKey (Microsoft.EntityFrameworkCore.Metadata.IMutableKey key);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey(class Microsoft.EntityFrameworkCore.Metadata.IMutableKey key) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveKey(Microsoft.EntityFrameworkCore.Metadata.IMutableKey)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveKey (key As IMutableKey) Implements IMutableEntityType.RemoveKey" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IMutableKey -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IMutableKey -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey key" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey IMutableEntityType.RemoveKey (Microsoft.EntityFrameworkCore.Metadata.IMutableKey key);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey(class Microsoft.EntityFrameworkCore.Metadata.IMutableKey key) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Function RemoveKey (key As IMutableKey) As IMutableKey Implements IMutableEntityType.RemoveKey" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IMutableKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IMutableKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey key" FrameworkAlternate="efcore-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey(Microsoft.EntityFrameworkCore.Metadata.IMutableKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IMutableKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey? IMutableEntityType.RemoveKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey key);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveKey (key As IReadOnlyKey) As IMutableKey Implements IMutableEntityType.RemoveKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey key" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey IMutableEntityType.RemoveKey (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey key);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey IMutableEntityType.RemoveKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Function RemoveKey (properties As IReadOnlyList(Of IProperty)) As IMutableKey Implements IMutableEntityType.RemoveKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey? IMutableEntityType.RemoveKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function RemoveKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As IMutableKey Implements IMutableEntityType.RemoveKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey IMutableEntityType.RemoveKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty">
      <MemberSignature Language="C#" Value="void IMutableEntityType.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IMutableProperty property);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty property) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IMutableProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveProperty (property As IMutableProperty) Implements IMutableEntityType.RemoveProperty" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IMutableProperty -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IMutableProperty -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty property" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableEntityType.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IMutableProperty property);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty property) cil managed" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (property As IMutableProperty) As IMutableProperty Implements IMutableEntityType.RemoveProperty" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IMutableProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IMutableProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty property" FrameworkAlternate="efcore-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IMutableProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0">Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty? IMutableEntityType.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (property As IReadOnlyProperty) As IMutableProperty Implements IMutableEntityType.RemoveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty property" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableEntityType.RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty IMutableEntityType.RemoveProperty (string name);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveProperty (name As String) As IMutableProperty Implements IMutableEntityType.RemoveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableProperty? IMutableEntityType.RemoveProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty? IMutableEntityType.RemoveServiceProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty property);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveServiceProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveServiceProperty (property As IReadOnlyServiceProperty) As IMutableServiceProperty Implements IMutableEntityType.RemoveServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty property" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty IMutableEntityType.RemoveServiceProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty property);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty IMutableEntityType.RemoveServiceProperty (string name);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveServiceProperty (name As String) As IMutableServiceProperty Implements IMutableEntityType.RemoveServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty? IMutableEntityType.RemoveServiceProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveServiceProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation IMutableEntityType.RemoveSkipNavigation (Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation navigation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation(class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation navigation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveSkipNavigation(Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveSkipNavigation (navigation As IMutableSkipNavigation) As IMutableSkipNavigation Implements IMutableEntityType.RemoveSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation navigation" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation(Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigation" Type="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation" Index="0" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="navigation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation? IMutableEntityType.RemoveSkipNavigation (Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation navigation);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation navigation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveSkipNavigation(Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveSkipNavigation (navigation As IReadOnlySkipNavigation) As IMutableSkipNavigation Implements IMutableEntityType.RemoveSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation navigation" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation IMutableEntityType.RemoveSkipNavigation (Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation navigation);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveSkipNavigation(Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableSkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigation" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="navigation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveTrigger">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger IMutableEntityType.RemoveTrigger (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveTrigger(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#RemoveTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function RemoveTrigger (name As String) As IMutableTrigger Implements IMutableEntityType.RemoveTrigger" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveTrigger name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.RemoveTrigger(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableTrigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="void IMutableEntityType.SetChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy})" />
      <MemberSignature Language="VB.NET" Value="Sub SetChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy)) Implements IMutableEntityType.SetChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetChangeTrackingStrategy changeTrackingStrategy" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetDiscriminatorProperty">
      <MemberSignature Language="C#" Value="void IMutableEntityType.SetDiscriminatorProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty? property);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetDiscriminatorProperty(class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#SetDiscriminatorProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub SetDiscriminatorProperty (property As IReadOnlyProperty) Implements IMutableEntityType.SetDiscriminatorProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetDiscriminatorProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetDiscriminatorProperty : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetDiscriminatorProperty property" />
      <MemberSignature Language="C#" Value="void IMutableEntityType.SetDiscriminatorProperty (Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty property);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetDiscriminatorProperty(Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetPrimaryKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey IMutableEntityType.SetPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IMutableKey Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetPrimaryKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#SetPrimaryKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty})" />
      <MemberSignature Language="VB.NET" Value="Function SetPrimaryKey (properties As IReadOnlyList(Of IMutableProperty)) As IMutableKey Implements IMutableEntityType.SetPrimaryKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IMutableKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetPrimaryKey properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableKey? IMutableEntityType.SetPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;? properties);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetPrimaryKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IMutableProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IMutableProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetQueryFilter">
      <MemberSignature Language="C#" Value="void IMutableEntityType.SetQueryFilter (System.Linq.Expressions.LambdaExpression? queryFilter);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetQueryFilter(class System.Linq.Expressions.LambdaExpression queryFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableEntityType#SetQueryFilter(System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Sub SetQueryFilter (queryFilter As LambdaExpression) Implements IMutableEntityType.SetQueryFilter" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetQueryFilter : System.Linq.Expressions.LambdaExpression -&gt; unit&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetQueryFilter : System.Linq.Expressions.LambdaExpression -&gt; unit" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetQueryFilter queryFilter" />
      <MemberSignature Language="C#" Value="void IMutableEntityType.SetQueryFilter (System.Linq.Expressions.LambdaExpression queryFilter);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.SetQueryFilter(System.Linq.Expressions.LambdaExpression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queryFilter" Type="System.Linq.Expressions.LambdaExpression" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="queryFilter">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IMutableModel Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IMutableTypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IMutableModel Implements IMutableTypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IMutableModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">P:Microsoft.EntityFrameworkCore.Metadata.IMutableEntityType.Model</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.IMutableTypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IMutableModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.BaseType">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType? Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.BaseType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#BaseType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property BaseType As IReadOnlyEntityType Implements IReadOnlyEntityType.BaseType" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.BaseType : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; IReadOnlyEntityType.FindDeclaredForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindDeclaredForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of IReadOnlyForeignKey) Implements IReadOnlyEntityType.FindDeclaredForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredForeignKeys properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation? IReadOnlyEntityType.FindDeclaredNavigation (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindDeclaredNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredNavigation (name As String) As IReadOnlyNavigation Implements IReadOnlyEntityType.FindDeclaredNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredNavigation name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation IReadOnlyEntityType.FindDeclaredNavigation (string name);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredNavigation(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty? IReadOnlyEntityType.FindDeclaredProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindDeclaredProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredProperty (name As String) As IReadOnlyProperty Implements IReadOnlyEntityType.FindDeclaredProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty IReadOnlyEntityType.FindDeclaredProperty (string name);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation? IReadOnlyEntityType.FindDeclaredSkipNavigation (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindDeclaredSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredSkipNavigation (name As String) As IReadOnlySkipNavigation Implements IReadOnlyEntityType.FindDeclaredSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredSkipNavigation name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation IReadOnlyEntityType.FindDeclaredSkipNavigation (string name);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredSkipNavigation(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredTrigger">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger IReadOnlyEntityType.FindDeclaredTrigger (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredTrigger(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindDeclaredTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindDeclaredTrigger (name As String) As IReadOnlyTrigger Implements IReadOnlyEntityType.FindDeclaredTrigger" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredTrigger name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindDeclaredTrigger(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey? IReadOnlyEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Function FindForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As IReadOnlyForeignKey Implements IReadOnlyEntityType.FindForeignKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKey (properties, principalKey, principalEntityType)" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey IReadOnlyEntityType.FindForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; IReadOnlyEntityType.FindForeignKeys (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKeys(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindForeignKeys (properties As IReadOnlyList(Of IReadOnlyProperty)) As IEnumerable(Of IReadOnlyForeignKey) Implements IReadOnlyEntityType.FindForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKeys : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKeys properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindForeignKeys(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex? IReadOnlyEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As IReadOnlyIndex Implements IReadOnlyEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex IReadOnlyEntityType.FindIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex? IReadOnlyEntityType.FindIndex (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindIndex(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindIndex (name As String) As IReadOnlyIndex Implements IReadOnlyEntityType.FindIndex" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex IReadOnlyEntityType.FindIndex (string name);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindIndex(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey? IReadOnlyEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Function FindKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As IReadOnlyKey Implements IReadOnlyEntityType.FindKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindKey properties" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey IReadOnlyEntityType.FindKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindPrimaryKey">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey? IReadOnlyEntityType.FindPrimaryKey ();" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindPrimaryKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindPrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Function FindPrimaryKey () As IReadOnlyKey Implements IReadOnlyEntityType.FindPrimaryKey" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindPrimaryKey : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindPrimaryKey " />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey IReadOnlyEntityType.FindPrimaryKey ();" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindPrimaryKey</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;? IReadOnlyEntityType.FindProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperties(class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; propertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindProperties(System.Collections.Generic.IReadOnlyList{System.String})" />
      <MemberSignature Language="VB.NET" Value="Function FindProperties (propertyNames As IReadOnlyList(Of String)) As IReadOnlyList(Of IReadOnlyProperty) Implements IReadOnlyEntityType.FindProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperties propertyNames" />
      <MemberSignature Language="C#" Value="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyEntityType.FindProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperties(System.Collections.Generic.IReadOnlyList{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IReadOnlyList&lt;System.String&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="propertyNames">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty? IReadOnlyEntityType.FindProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindProperty (name As String) As IReadOnlyProperty Implements IReadOnlyEntityType.FindProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty IReadOnlyEntityType.FindProperty (string name);" FrameworkAlternate="efcore-7.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindServiceProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty? IReadOnlyEntityType.FindServiceProperty (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindServiceProperty (name As String) As IReadOnlyServiceProperty Implements IReadOnlyEntityType.FindServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindServiceProperty name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty IReadOnlyEntityType.FindServiceProperty (string name);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindServiceProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation? IReadOnlyEntityType.FindSkipNavigation (System.Reflection.MemberInfo memberInfo);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation(class System.Reflection.MemberInfo memberInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindSkipNavigation(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Function FindSkipNavigation (memberInfo As MemberInfo) As IReadOnlySkipNavigation Implements IReadOnlyEntityType.FindSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation : System.Reflection.MemberInfo -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation memberInfo" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation IReadOnlyEntityType.FindSkipNavigation (System.Reflection.MemberInfo memberInfo);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation(System.Reflection.MemberInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation? IReadOnlyEntityType.FindSkipNavigation (string name);" FrameworkAlternate="efcore-6.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#FindSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindSkipNavigation (name As String) As IReadOnlySkipNavigation Implements IReadOnlyEntityType.FindSkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation name" />
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation IReadOnlyEntityType.FindSkipNavigation (string name);" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.FindSkipNavigation(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; IReadOnlyEntityType.GetDeclaredForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDeclaredForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredForeignKeys () As IEnumerable(Of IReadOnlyForeignKey) Implements IReadOnlyEntityType.GetDeclaredForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; IReadOnlyEntityType.GetDeclaredIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDeclaredIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredIndexes () As IEnumerable(Of IReadOnlyIndex) Implements IReadOnlyEntityType.GetDeclaredIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredIndexes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; IReadOnlyEntityType.GetDeclaredKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDeclaredKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredKeys () As IEnumerable(Of IReadOnlyKey) Implements IReadOnlyEntityType.GetDeclaredKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; IReadOnlyEntityType.GetDeclaredNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDeclaredNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredNavigations () As IEnumerable(Of IReadOnlyNavigation) Implements IReadOnlyEntityType.GetDeclaredNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyEntityType.GetDeclaredProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDeclaredProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredProperties () As IEnumerable(Of IReadOnlyProperty) Implements IReadOnlyEntityType.GetDeclaredProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredReferencingForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; IReadOnlyEntityType.GetDeclaredReferencingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredReferencingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDeclaredReferencingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredReferencingForeignKeys () As IEnumerable(Of IReadOnlyForeignKey) Implements IReadOnlyEntityType.GetDeclaredReferencingForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredReferencingForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredReferencingForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredServiceProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; IReadOnlyEntityType.GetDeclaredServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDeclaredServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredServiceProperties () As IEnumerable(Of IReadOnlyServiceProperty) Implements IReadOnlyEntityType.GetDeclaredServiceProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredServiceProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredServiceProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredSkipNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; IReadOnlyEntityType.GetDeclaredSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDeclaredSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredSkipNavigations () As IEnumerable(Of IReadOnlySkipNavigation) Implements IReadOnlyEntityType.GetDeclaredSkipNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredSkipNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredSkipNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredTriggers">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&gt; IReadOnlyEntityType.GetDeclaredTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDeclaredTriggers" />
      <MemberSignature Language="VB.NET" Value="Function GetDeclaredTriggers () As IEnumerable(Of IReadOnlyTrigger) Implements IReadOnlyEntityType.GetDeclaredTriggers" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredTriggers : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredTriggers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDeclaredTriggers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTrigger&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; IReadOnlyEntityType.GetDerivedForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDerivedForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedForeignKeys () As IEnumerable(Of IReadOnlyForeignKey) Implements IReadOnlyEntityType.GetDerivedForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; IReadOnlyEntityType.GetDerivedIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDerivedIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedIndexes () As IEnumerable(Of IReadOnlyIndex) Implements IReadOnlyEntityType.GetDerivedIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedIndexes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; IReadOnlyEntityType.GetDerivedNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDerivedNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedNavigations () As IEnumerable(Of IReadOnlyNavigation) Implements IReadOnlyEntityType.GetDerivedNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyEntityType.GetDerivedProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDerivedProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedProperties () As IEnumerable(Of IReadOnlyProperty) Implements IReadOnlyEntityType.GetDerivedProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedServiceProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; IReadOnlyEntityType.GetDerivedServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDerivedServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedServiceProperties () As IEnumerable(Of IReadOnlyServiceProperty) Implements IReadOnlyEntityType.GetDerivedServiceProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedServiceProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedServiceProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedSkipNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; IReadOnlyEntityType.GetDerivedSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDerivedSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedSkipNavigations () As IEnumerable(Of IReadOnlySkipNavigation) Implements IReadOnlyEntityType.GetDerivedSkipNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedSkipNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedSkipNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedTypes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; IReadOnlyEntityType.GetDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Function GetDerivedTypes () As IEnumerable(Of IReadOnlyEntityType) Implements IReadOnlyEntityType.GetDerivedTypes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDerivedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDirectlyDerivedTypes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; IReadOnlyEntityType.GetDirectlyDerivedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDirectlyDerivedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetDirectlyDerivedTypes" />
      <MemberSignature Language="VB.NET" Value="Function GetDirectlyDerivedTypes () As IEnumerable(Of IReadOnlyEntityType) Implements IReadOnlyEntityType.GetDirectlyDerivedTypes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDirectlyDerivedTypes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDirectlyDerivedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetDirectlyDerivedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; IReadOnlyEntityType.GetForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetForeignKeys () As IEnumerable(Of IReadOnlyForeignKey) Implements IReadOnlyEntityType.GetForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetIndexes">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; IReadOnlyEntityType.GetIndexes ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetIndexes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetIndexes" />
      <MemberSignature Language="VB.NET" Value="Function GetIndexes () As IEnumerable(Of IReadOnlyIndex) Implements IReadOnlyEntityType.GetIndexes" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetIndexes : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetIndexes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetIndexes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyIndex&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; IReadOnlyEntityType.GetKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetKeys () As IEnumerable(Of IReadOnlyKey) Implements IReadOnlyEntityType.GetKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; IReadOnlyEntityType.GetNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetNavigations () As IEnumerable(Of IReadOnlyNavigation) Implements IReadOnlyEntityType.GetNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; IReadOnlyEntityType.GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties () As IEnumerable(Of IReadOnlyProperty) Implements IReadOnlyEntityType.GetProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetReferencingForeignKeys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; IReadOnlyEntityType.GetReferencingForeignKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetReferencingForeignKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetReferencingForeignKeys" />
      <MemberSignature Language="VB.NET" Value="Function GetReferencingForeignKeys () As IEnumerable(Of IReadOnlyForeignKey) Implements IReadOnlyEntityType.GetReferencingForeignKeys" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetReferencingForeignKeys : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetReferencingForeignKeys " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetReferencingForeignKeys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyForeignKey&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetServiceProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; IReadOnlyEntityType.GetServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Function GetServiceProperties () As IEnumerable(Of IReadOnlyServiceProperty) Implements IReadOnlyEntityType.GetServiceProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetServiceProperties : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetServiceProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetServiceProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyServiceProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSkipNavigations">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; IReadOnlyEntityType.GetSkipNavigations ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt; Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSkipNavigations() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#GetSkipNavigations" />
      <MemberSignature Language="VB.NET" Value="Function GetSkipNavigations () As IEnumerable(Of IReadOnlySkipNavigation) Implements IReadOnlyEntityType.GetSkipNavigations" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSkipNavigations : unit -&gt; seq&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSkipNavigations " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.GetSkipNavigations</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlySkipNavigation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.HasServiceProperties">
      <MemberSignature Language="C#" Value="bool IReadOnlyEntityType.HasServiceProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.HasServiceProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyEntityType#HasServiceProperties" />
      <MemberSignature Language="VB.NET" Value="Function HasServiceProperties () As Boolean Implements IReadOnlyEntityType.HasServiceProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.HasServiceProperties : unit -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.HasServiceProperties : unit -&gt; bool" Usage="entityType.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.HasServiceProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType.HasServiceProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-8.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#IReadOnlyTypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IReadOnlyModel Implements IReadOnlyTypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel" Usage="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IReadOnlyTypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IReadOnlyModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IModel Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Microsoft#EntityFrameworkCore#Metadata#ITypeBase#Model" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Model As IModel Implements ITypeBase.Model" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model : Microsoft.EntityFrameworkCore.Metadata.IModel" Usage="Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-1.1">P:Microsoft.EntityFrameworkCore.Metadata.IEntityType.Model</InterfaceMember>
        <InterfaceMember FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.ITypeBase.Model</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Model">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Model Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Model Model" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Model" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Model As Model" />
      <MemberSignature Language="F#" Value="member this.Model : Microsoft.EntityFrameworkCore.Metadata.Internal.Model" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Model" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Model</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.IEntityType.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAnnotationSet">
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Infrastructure.Annotation OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Infrastructure.Annotation annotation, Microsoft.EntityFrameworkCore.Infrastructure.Annotation oldAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.EntityFrameworkCore.Infrastructure.Annotation OnAnnotationSet(string name, class Microsoft.EntityFrameworkCore.Infrastructure.Annotation annotation, class Microsoft.EntityFrameworkCore.Infrastructure.Annotation oldAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.OnAnnotationSet(System.String,Microsoft.EntityFrameworkCore.Infrastructure.Annotation,Microsoft.EntityFrameworkCore.Infrastructure.Annotation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnAnnotationSet (name As String, annotation As Annotation, oldAnnotation As Annotation) As Annotation" />
      <MemberSignature Language="F#" Value="override this.OnAnnotationSet : string * Microsoft.EntityFrameworkCore.Infrastructure.Annotation * Microsoft.EntityFrameworkCore.Infrastructure.Annotation -&gt; Microsoft.EntityFrameworkCore.Infrastructure.Annotation" Usage="entityType.OnAnnotationSet (name, annotation, oldAnnotation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Infrastructure.Annotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="annotation" Type="Microsoft.EntityFrameworkCore.Infrastructure.Annotation" Index="1" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="oldAnnotation" Type="Microsoft.EntityFrameworkCore.Infrastructure.Annotation" Index="2" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name"> The key of the set annotation. </param>
        <param name="annotation"> The annotation set. </param>
        <param name="oldAnnotation"> The old annotation. </param>
        <summary>
                Runs the conventions when an annotation was set or removed.
            </summary>
        <returns> The annotation that was set. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAnnotationSet">
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation annotation, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation oldAnnotation);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation OnAnnotationSet(string name, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation annotation, class Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation oldAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.OnAnnotationSet(System.String,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation,Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnAnnotationSet (name As String, annotation As IConventionAnnotation, oldAnnotation As IConventionAnnotation) As IConventionAnnotation" />
      <MemberSignature Language="F#" Value="override this.OnAnnotationSet : string * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation * Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation -&gt; Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" Usage="entityType.OnAnnotationSet (name, annotation, oldAnnotation)" />
      <MemberSignature Language="C#" Value="protected override Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? OnAnnotationSet (string name, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? annotation, Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation? oldAnnotation);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="annotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="oldAnnotation" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionAnnotation" Index="2" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">The key of the set annotation.</param>
        <param name="annotation">The annotation set.</param>
        <param name="oldAnnotation">The old annotation.</param>
        <summary>
                Runs the conventions when an annotation was set or removed.
            </summary>
        <returns>The annotation that was set.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnForeignKeyUpdated">
      <MemberSignature Language="C#" Value="public virtual void OnForeignKeyUpdated (Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnForeignKeyUpdated(class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.OnForeignKeyUpdated(Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnForeignKeyUpdated (foreignKey As ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member OnForeignKeyUpdated : Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey -&gt; unit&#xA;override this.OnForeignKeyUpdated : Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey -&gt; unit" Usage="entityType.OnForeignKeyUpdated foreignKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnForeignKeyUpdating">
      <MemberSignature Language="C#" Value="public virtual void OnForeignKeyUpdating (Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnForeignKeyUpdating(class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.OnForeignKeyUpdating(Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnForeignKeyUpdating (foreignKey As ForeignKey)" />
      <MemberSignature Language="F#" Value="abstract member OnForeignKeyUpdating : Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey -&gt; unit&#xA;override this.OnForeignKeyUpdating : Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey -&gt; unit" Usage="entityType.OnForeignKeyUpdating foreignKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTypeMemberIgnored">
      <MemberSignature Language="C#" Value="public override void OnTypeMemberIgnored (string name);" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnTypeMemberIgnored(string name) cil managed" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.OnTypeMemberIgnored(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnTypeMemberIgnored (name As String)" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="override this.OnTypeMemberIgnored : string -&gt; unit" Usage="entityType.OnTypeMemberIgnored name" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public override string OnTypeMemberIgnored (string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string OnTypeMemberIgnored(string name) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function OnTypeMemberIgnored (name As String) As String" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="override this.OnTypeMemberIgnored : string -&gt; string" Usage="entityType.OnTypeMemberIgnored name" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public override string? OnTypeMemberIgnored (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTypeRemoved">
      <MemberSignature Language="C#" Value="public virtual void OnTypeRemoved ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnTypeRemoved() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.OnTypeRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnTypeRemoved ()" />
      <MemberSignature Language="F#" Value="abstract member OnTypeRemoved : unit -&gt; unit&#xA;override this.OnTypeRemoved : unit -&gt; unit" Usage="entityType.OnTypeRemoved " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalValuesFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; OriginalValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; OriginalValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.OriginalValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OriginalValuesFactory As Func(Of InternalEntityEntry, ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.OriginalValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.OriginalValuesFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.OriginalValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType? Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType Owner" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Owner As EntityType" />
      <MemberSignature Language="F#" Value="member this.Owner : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyMetadataChanged">
      <MemberSignature Language="C#" Value="public virtual void PropertyMetadataChanged ();" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PropertyMetadataChanged() cil managed" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.PropertyMetadataChanged" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PropertyMetadataChanged ()" FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="F#" Value="abstract member PropertyMetadataChanged : unit -&gt; unit&#xA;override this.PropertyMetadataChanged : unit -&gt; unit" Usage="entityType.PropertyMetadataChanged " FrameworkAlternate="efcore-1.0" />
      <MemberSignature Language="C#" Value="public override void PropertyMetadataChanged ();" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void PropertyMetadataChanged() cil managed" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub PropertyMetadataChanged ()" FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberSignature Language="F#" Value="override this.PropertyMetadataChanged : unit -&gt; unit" Usage="entityType.PropertyMetadataChanged " FrameworkAlternate="efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryFilter">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.LambdaExpression QueryFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.Expressions.LambdaExpression QueryFilter" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.QueryFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property QueryFilter As LambdaExpression" />
      <MemberSignature Language="F#" Value="member this.QueryFilter : System.Linq.Expressions.LambdaExpression with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.QueryFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RelationshipSnapshotFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; RelationshipSnapshotFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; RelationshipSnapshotFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RelationshipSnapshotFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RelationshipSnapshotFactory As Func(Of InternalEntityEntry, ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.RelationshipSnapshotFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RelationshipSnapshotFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.RelationshipSnapshotFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey RemoveForeignKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveForeignKey(Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveForeignKey (foreignKey As ForeignKey) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.RemoveForeignKey : Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.RemoveForeignKey foreignKey" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? RemoveForeignKey (Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey foreignKey);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKey" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="foreignKey">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey RemoveForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey RemoveForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveForeignKey (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.RemoveForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey? RemoveForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey RemoveForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType principalEntityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty},Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey,Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveForeignKey (properties As IReadOnlyList(Of IReadOnlyProperty), principalKey As IReadOnlyKey, principalEntityType As IReadOnlyEntityType) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey * Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.RemoveForeignKey (properties, principalKey, principalEntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyKey" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IReadOnlyEntityType" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey RemoveForeignKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey RemoveForeignKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, class Microsoft.EntityFrameworkCore.Metadata.IKey principalKey, class Microsoft.EntityFrameworkCore.Metadata.IEntityType principalEntityType, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveForeignKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},Microsoft.EntityFrameworkCore.Metadata.IKey,Microsoft.EntityFrameworkCore.Metadata.IEntityType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveForeignKey (properties As IReadOnlyList(Of IProperty), principalKey As IKey, principalEntityType As IEntityType, Optional runConventions As Boolean = true) As ForeignKey" />
      <MemberSignature Language="F#" Value="abstract member RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey&#xA;override this.RemoveForeignKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * Microsoft.EntityFrameworkCore.Metadata.IKey * Microsoft.EntityFrameworkCore.Metadata.IEntityType * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey" Usage="entityType.RemoveForeignKey (properties, principalKey, principalEntityType, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ForeignKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="principalKey" Type="Microsoft.EntityFrameworkCore.Metadata.IKey" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="principalEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="principalKey">To be added.</param>
        <param name="principalEntityType">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.Internal.Index index);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index RemoveIndex(class Microsoft.EntityFrameworkCore.Metadata.Internal.Index index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveIndex(Microsoft.EntityFrameworkCore.Metadata.Internal.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveIndex (index As Index) As Index" />
      <MemberSignature Language="F#" Value="abstract member RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Index -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.RemoveIndex : Microsoft.EntityFrameworkCore.Metadata.Internal.Index -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.RemoveIndex index" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? RemoveIndex (Microsoft.EntityFrameworkCore.Metadata.Internal.Index index);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index RemoveIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index RemoveIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveIndex (properties As IReadOnlyList(Of IProperty)) As Index" />
      <MemberSignature Language="F#" Value="abstract member RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.RemoveIndex properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? RemoveIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index RemoveIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveIndex (properties As IReadOnlyList(Of IReadOnlyProperty)) As Index" />
      <MemberSignature Language="F#" Value="abstract member RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.RemoveIndex properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index RemoveIndex (string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index RemoveIndex(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveIndex(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveIndex (name As String) As Index" />
      <MemberSignature Language="F#" Value="abstract member RemoveIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.RemoveIndex : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.RemoveIndex name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index? RemoveIndex (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Index RemoveIndex (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Index RemoveIndex(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveIndex(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveIndex (properties As IReadOnlyList(Of IProperty), Optional runConventions As Boolean = true) As Index" />
      <MemberSignature Language="F#" Value="abstract member RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index&#xA;override this.RemoveIndex : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Index" Usage="entityType.RemoveIndex (properties, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Index</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.1" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key RemoveKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Key key);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key RemoveKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Key key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Key)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveKey (key As Key) As Key" />
      <MemberSignature Language="F#" Value="abstract member RemoveKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Key -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.RemoveKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Key -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.RemoveKey key" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? RemoveKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Key key);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key RemoveKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key RemoveKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveKey (properties As IReadOnlyList(Of IProperty)) As Key" />
      <MemberSignature Language="F#" Value="abstract member RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.RemoveKey properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? RemoveKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key RemoveKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveKey (properties As IReadOnlyList(Of IReadOnlyProperty)) As Key" />
      <MemberSignature Language="F#" Value="abstract member RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.RemoveKey properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IReadOnlyProperty&gt;" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key RemoveKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key RemoveKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; properties, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IProperty},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveKey (properties As IReadOnlyList(Of IProperty), Optional runConventions As Boolean = true) As Key" />
      <MemberSignature Language="F#" Value="abstract member RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.RemoveKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.RemoveKey (properties, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation RemoveNavigation (string name);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation RemoveNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveNavigation (name As String) As Navigation" />
      <MemberSignature Language="F#" Value="abstract member RemoveNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation&#xA;override this.RemoveNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation" Usage="entityType.RemoveNavigation name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation? RemoveNavigation (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Navigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.Internal.Property)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveProperty (property As Property) As Property" />
      <MemberSignature Language="F#" Value="abstract member RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.RemoveProperty property" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property RemoveProperty (string name);" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property RemoveProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveProperty (name As String) As Property" />
      <MemberSignature Language="F#" Value="abstract member RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.RemoveProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.RemoveProperty name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? RemoveProperty (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveServiceProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty RemoveServiceProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty RemoveServiceProperty(class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveServiceProperty(Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveServiceProperty (property As ServiceProperty) As ServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member RemoveServiceProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&#xA;override this.RemoveServiceProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty" Usage="entityType.RemoveServiceProperty property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveServiceProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty RemoveServiceProperty (string name);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty RemoveServiceProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveServiceProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveServiceProperty (name As String) As ServiceProperty" />
      <MemberSignature Language="F#" Value="abstract member RemoveServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty&#xA;override this.RemoveServiceProperty : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty" Usage="entityType.RemoveServiceProperty name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty? RemoveServiceProperty (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.ServiceProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSkipNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation RemoveSkipNavigation (Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation navigation);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation RemoveSkipNavigation(class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation navigation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveSkipNavigation(Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveSkipNavigation (navigation As SkipNavigation) As SkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&#xA;override this.RemoveSkipNavigation : Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="entityType.RemoveSkipNavigation navigation" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? RemoveSkipNavigation (Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation navigation);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigation" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="navigation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSkipNavigation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation RemoveSkipNavigation (string name);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation RemoveSkipNavigation(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveSkipNavigation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveSkipNavigation (name As String) As SkipNavigation" />
      <MemberSignature Language="F#" Value="abstract member RemoveSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation&#xA;override this.RemoveSkipNavigation : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation" Usage="entityType.RemoveSkipNavigation name" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation? RemoveSkipNavigation (string name);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.SkipNavigation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveTrigger">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger? RemoveTrigger (string modelName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger RemoveTrigger(string modelName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RemoveTrigger(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveTrigger (modelName As String) As Trigger" />
      <MemberSignature Language="F#" Value="abstract member RemoveTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger&#xA;override this.RemoveTrigger : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger" Usage="entityType.RemoveTrigger modelName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Trigger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="modelName" Type="System.String" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="modelName">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RootType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType RootType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType RootType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.RootType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RootType () As EntityType" />
      <MemberSignature Language="F#" Value="abstract member RootType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&#xA;override this.RootType : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="entityType.RootType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceOnlyConstructorBinding">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? ServiceOnlyConstructorBinding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding ServiceOnlyConstructorBinding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ServiceOnlyConstructorBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ServiceOnlyConstructorBinding As InstantiationBinding" />
      <MemberSignature Language="F#" Value="member this.ServiceOnlyConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding with get, set" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ServiceOnlyConstructorBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBaseType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType SetBaseType (Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType newBaseType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType SetBaseType(class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType newBaseType, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetBaseType(Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetBaseType (newBaseType As EntityType, configurationSource As ConfigurationSource) As EntityType" />
      <MemberSignature Language="F#" Value="abstract member SetBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType&#xA;override this.SetBaseType : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Usage="entityType.SetBaseType (newBaseType, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType? SetBaseType (Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType? newBaseType, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="newBaseType">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual void SetChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy), configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="entityType.SetChangeTrackingStrategy (changeTrackingStrategy, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? SetChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; SetChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy), configurationSource As ConfigurationSource) As Nullable(Of ChangeTrackingStrategy)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberSignature Language="F#" Value="abstract member SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;&#xA;override this.SetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Usage="entityType.SetChangeTrackingStrategy (changeTrackingStrategy, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0">System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetConstructorBinding">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? SetConstructorBinding (Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? constructorBinding, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding SetConstructorBinding(class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding constructorBinding, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetConstructorBinding(Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetConstructorBinding (constructorBinding As InstantiationBinding, configurationSource As ConfigurationSource) As InstantiationBinding" />
      <MemberSignature Language="F#" Value="abstract member SetConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding&#xA;override this.SetConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" Usage="entityType.SetConstructorBinding (constructorBinding, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructorBinding" Type="Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="constructorBinding">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDefiningQuery">
      <MemberSignature Language="C#" Value="public virtual void SetDefiningQuery (System.Linq.Expressions.LambdaExpression definingQuery, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetDefiningQuery(class System.Linq.Expressions.LambdaExpression definingQuery, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetDefiningQuery(System.Linq.Expressions.LambdaExpression,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetDefiningQuery (definingQuery As LambdaExpression, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="F#" Value="abstract member SetDefiningQuery : System.Linq.Expressions.LambdaExpression * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetDefiningQuery : System.Linq.Expressions.LambdaExpression * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="entityType.SetDefiningQuery (definingQuery, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.LambdaExpression? SetDefiningQuery (System.Linq.Expressions.LambdaExpression? definingQuery, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.LambdaExpression SetDefiningQuery(class System.Linq.Expressions.LambdaExpression definingQuery, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetDefiningQuery (definingQuery As LambdaExpression, configurationSource As ConfigurationSource) As LambdaExpression" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetDefiningQuery : System.Linq.Expressions.LambdaExpression * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; System.Linq.Expressions.LambdaExpression&#xA;override this.SetDefiningQuery : System.Linq.Expressions.LambdaExpression * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; System.Linq.Expressions.LambdaExpression" Usage="entityType.SetDefiningQuery (definingQuery, configurationSource)" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">
          <AttributeName Language="C#">[System.Obsolete]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="definingQuery" Type="System.Linq.Expressions.LambdaExpression" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="definingQuery">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDiscriminatorProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property SetDiscriminatorProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Property SetDiscriminatorProperty(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetDiscriminatorProperty(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetDiscriminatorProperty (property As Property, configurationSource As ConfigurationSource) As Property" />
      <MemberSignature Language="F#" Value="abstract member SetDiscriminatorProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property&#xA;override this.SetDiscriminatorProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Usage="entityType.SetDiscriminatorProperty (property, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Property? SetDiscriminatorProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.Property? property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Property</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDiscriminatorProperty">
      <MemberSignature Language="C#" Value="public virtual void SetDiscriminatorProperty (Microsoft.EntityFrameworkCore.Metadata.IProperty property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetDiscriminatorProperty(class Microsoft.EntityFrameworkCore.Metadata.IProperty property, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetDiscriminatorProperty(Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetDiscriminatorProperty (property As IProperty, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member SetDiscriminatorProperty : Microsoft.EntityFrameworkCore.Metadata.IProperty * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetDiscriminatorProperty : Microsoft.EntityFrameworkCore.Metadata.IProperty * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="entityType.SetDiscriminatorProperty (property, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsKeyless">
      <MemberSignature Language="C#" Value="public virtual bool? SetIsKeyless (bool? keyless, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;bool&gt; SetIsKeyless(valuetype System.Nullable`1&lt;bool&gt; keyless, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetIsKeyless(System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetIsKeyless (keyless As Nullable(Of Boolean), configurationSource As ConfigurationSource) As Nullable(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetIsKeyless : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;&#xA;override this.SetIsKeyless : Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;bool&gt;" Usage="entityType.SetIsKeyless (keyless, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyless" Type="System.Nullable&lt;System.Boolean&gt;" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="keyless">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsOwned">
      <MemberSignature Language="C#" Value="public virtual void SetIsOwned (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetIsOwned(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetIsOwned(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetIsOwned (value As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetIsOwned : bool -&gt; unit&#xA;override this.SetIsOwned : bool -&gt; unit" Usage="entityType.SetIsOwned value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNavigationAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.PropertyAccessMode? SetNavigationAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; SetNavigationAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetNavigationAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetNavigationAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As ConfigurationSource) As Nullable(Of PropertyAccessMode)" />
      <MemberSignature Language="F#" Value="abstract member SetNavigationAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;&#xA;override this.SetNavigationAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" Usage="entityType.SetNavigationAccessMode (propertyAccessMode, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" Index="0" FrameworkAlternate="efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetPrimaryKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Property)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetPrimaryKey (property As Property) As Key" />
      <MemberSignature Language="F#" Value="abstract member SetPrimaryKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.SetPrimaryKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.SetPrimaryKey property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1;efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetPrimaryKey(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetPrimaryKey (property As Property, configurationSource As ConfigurationSource) As Key" />
      <MemberSignature Language="F#" Value="abstract member SetPrimaryKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.SetPrimaryKey : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.SetPrimaryKey (property, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? SetPrimaryKey (Microsoft.EntityFrameworkCore.Metadata.Internal.Property? property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetPrimaryKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetPrimaryKey (properties As IReadOnlyList(Of Property), configurationSource As ConfigurationSource) As Key" />
      <MemberSignature Language="F#" Value="abstract member SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.SetPrimaryKey (properties, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key? SetPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? properties, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetPrimaryKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetPrimaryKey (properties As IReadOnlyList(Of Property), Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit) As Key" />
      <MemberSignature Language="F#" Value="abstract member SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.SetPrimaryKey (properties, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-2.0;efcore-2.1;efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrimaryKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, bool runConventions = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.Key SetPrimaryKey(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource, bool runConventions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetPrimaryKey(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetPrimaryKey (properties As IReadOnlyList(Of Property), Optional configurationSource As ConfigurationSource = Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource.Explicit, Optional runConventions As Boolean = true) As Key" />
      <MemberSignature Language="F#" Value="abstract member SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key&#xA;override this.SetPrimaryKey : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.Key" Usage="entityType.SetPrimaryKey (properties, configurationSource, runConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.Key</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Index="0" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="1" FrameworkAlternate="efcore-1.0;efcore-1.1" />
        <Parameter Name="runConventions" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-1.0;efcore-1.1" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="runConventions">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetQueryFilter">
      <MemberSignature Language="C#" Value="public virtual void SetQueryFilter (System.Linq.Expressions.LambdaExpression queryFilter, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetQueryFilter(class System.Linq.Expressions.LambdaExpression queryFilter, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetQueryFilter(System.Linq.Expressions.LambdaExpression,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetQueryFilter (queryFilter As LambdaExpression, configurationSource As ConfigurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member SetQueryFilter : System.Linq.Expressions.LambdaExpression * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.SetQueryFilter : System.Linq.Expressions.LambdaExpression * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="entityType.SetQueryFilter (queryFilter, configurationSource)" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.LambdaExpression SetQueryFilter (System.Linq.Expressions.LambdaExpression queryFilter, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.LambdaExpression SetQueryFilter(class System.Linq.Expressions.LambdaExpression queryFilter, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetQueryFilter (queryFilter As LambdaExpression, configurationSource As ConfigurationSource) As LambdaExpression" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="abstract member SetQueryFilter : System.Linq.Expressions.LambdaExpression * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; System.Linq.Expressions.LambdaExpression&#xA;override this.SetQueryFilter : System.Linq.Expressions.LambdaExpression * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; System.Linq.Expressions.LambdaExpression" Usage="entityType.SetQueryFilter (queryFilter, configurationSource)" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.LambdaExpression? SetQueryFilter (System.Linq.Expressions.LambdaExpression? queryFilter, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.0;efcore-3.1">System.Void</ReturnType>
        <ReturnType FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0">System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queryFilter" Type="System.Linq.Expressions.LambdaExpression" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="queryFilter">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRemovedFromModel">
      <MemberSignature Language="C#" Value="public virtual void SetRemovedFromModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRemovedFromModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetRemovedFromModel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRemovedFromModel ()" />
      <MemberSignature Language="F#" Value="abstract member SetRemovedFromModel : unit -&gt; unit&#xA;override this.SetRemovedFromModel : unit -&gt; unit" Usage="entityType.SetRemovedFromModel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetServiceOnlyConstructorBinding">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? SetServiceOnlyConstructorBinding (Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding? constructorBinding, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding SetServiceOnlyConstructorBinding(class Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding constructorBinding, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SetServiceOnlyConstructorBinding(Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetServiceOnlyConstructorBinding (constructorBinding As InstantiationBinding, configurationSource As ConfigurationSource) As InstantiationBinding" />
      <MemberSignature Language="F#" Value="abstract member SetServiceOnlyConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding&#xA;override this.SetServiceOnlyConstructorBinding : Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" Usage="entityType.SetServiceOnlyConstructorBinding (constructorBinding, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructorBinding" Type="Microsoft.EntityFrameworkCore.Metadata.InstantiationBinding" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="constructorBinding">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShadowValuesFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.Storage.ValueBuffer,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; ShadowValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.ValueBuffer, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; ShadowValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ShadowValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ShadowValuesFactory As Func(Of ValueBuffer, ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.ShadowValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.Storage.ValueBuffer, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ShadowValuesFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.ShadowValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.Storage.ValueBuffer,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SidecarValuesFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; SidecarValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; SidecarValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SidecarValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SidecarValuesFactory As Func(Of InternalEntityEntry, ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.SidecarValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.SidecarValuesFactory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StoreGeneratedValuesFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; StoreGeneratedValuesFactory { get; }" FrameworkAlternate="efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; StoreGeneratedValuesFactory" FrameworkAlternate="efcore-3.1;efcore-5.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.StoreGeneratedValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StoreGeneratedValuesFactory As Func(Of InternalEntityEntry, ISnapshot)" FrameworkAlternate="efcore-3.1;efcore-5.0" />
      <MemberSignature Language="F#" Value="member this.StoreGeneratedValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.StoreGeneratedValuesFactory" FrameworkAlternate="efcore-3.1;efcore-5.0" />
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; StoreGeneratedValuesFactory { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; StoreGeneratedValuesFactory" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StoreGeneratedValuesFactory As Func(Of ISnapshot)" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberSignature Language="F#" Value="member this.StoreGeneratedValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.StoreGeneratedValuesFactory" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.StoreGeneratedValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="efcore-3.1;efcore-5.0">System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
        <ReturnType FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TemporaryValuesFactory">
      <MemberSignature Language="C#" Value="public virtual Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; TemporaryValuesFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt; TemporaryValuesFactory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.TemporaryValuesFactory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TemporaryValuesFactory As Func(Of InternalEntityEntry, ISnapshot)" />
      <MemberSignature Language="F#" Value="member this.TemporaryValuesFactory : Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry, Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.TemporaryValuesFactory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0">P:Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeEntityType.TemporaryValuesFactory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry,Microsoft.EntityFrameworkCore.ChangeTracking.Internal.ISnapshot&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="entityType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
        <AssemblyVersion>1.1.6.0</AssemblyVersion>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unignore">
      <MemberSignature Language="C#" Value="public virtual void Unignore (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unignore(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.Unignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unignore (name As String)" />
      <MemberSignature Language="F#" Value="abstract member Unignore : string -&gt; unit&#xA;override this.Unignore : string -&gt; unit" Usage="entityType.Unignore name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.UpdateConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit&#xA;override this.UpdateConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource -&gt; unit" Usage="entityType.UpdateConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ConfigurationSource" Index="0" FrameworkAlternate="efcore-1.0" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used 
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateIsKeylessConfigurationSource">
      <MemberSignature Language="C#" Value="public virtual void UpdateIsKeylessConfigurationSource (Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateIsKeylessConfigurationSource(valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.UpdateIsKeylessConfigurationSource(Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateIsKeylessConfigurationSource (configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member UpdateIsKeylessConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.UpdateIsKeylessConfigurationSource : Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="entityType.UpdateIsKeylessConfigurationSource configurationSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueGeneratingProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ValueGeneratingProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty&gt; ValueGeneratingProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ValueGeneratingProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueGeneratingProperties As IReadOnlyList(Of IProperty)" />
      <MemberSignature Language="F#" Value="member this.ValueGeneratingProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType.ValueGeneratingProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
