<Type Name="InternalTypeBaseBuilder" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder">
  <TypeSignature Language="C#" Value="public abstract class InternalTypeBaseBuilder : Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt;, Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit InternalTypeBaseBuilder extends Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder`2&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt; implements class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder, class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class InternalTypeBaseBuilder&#xA;Inherits AnnotatableBuilder(Of TypeBase, InternalModelBuilder)&#xA;Implements IConventionTypeBaseBuilder" />
  <TypeSignature Language="F#" Value="type InternalTypeBaseBuilder = class&#xA;    inherit AnnotatableBuilder&lt;TypeBase, InternalModelBuilder&gt;&#xA;    interface IConventionTypeBaseBuilder&#xA;    interface IConventionAnnotatableBuilder" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="TMetadata">Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase</BaseTypeArgument>
      <BaseTypeArgument TypeParamName="TModelBuilder">Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionAnnotatableBuilder</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalTypeBaseBuilder (Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase metadata, Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder modelBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase metadata, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder modelBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (metadata As TypeBase, modelBuilder As InternalModelBuilder)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder : Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase * Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder (metadata, modelBuilder)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="metadata" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.TypeBase" />
        <Parameter Name="modelBuilder" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder" />
      </Parameters>
      <Docs>
        <param name="metadata">To be added.</param>
        <param name="modelBuilder">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAddComplexProperty">
      <MemberSignature Language="C#" Value="public abstract bool CanAddComplexProperty (string propertyName, Type? propertyType, Type? targetType, bool? collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool checkClrProperty = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAddComplexProperty(string propertyName, class System.Type propertyType, class System.Type targetType, valuetype System.Nullable`1&lt;bool&gt; collection, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool checkClrProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanAddComplexProperty(System.String,System.Type,System.Type,System.Nullable{System.Boolean},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CanAddComplexProperty (propertyName As String, propertyType As Type, targetType As Type, collection As Nullable(Of Boolean), configurationSource As ConfigurationSource, Optional checkClrProperty As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanAddComplexProperty : string * Type * Type * Nullable&lt;bool&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource * bool -&gt; bool" Usage="internalTypeBaseBuilder.CanAddComplexProperty (propertyName, propertyType, targetType, collection, configurationSource, checkClrProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="targetType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="collection" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
        <Parameter Name="checkClrProperty" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <param name="propertyType">To be added.</param>
        <param name="targetType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="checkClrProperty">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAddProperty">
      <MemberSignature Language="C#" Value="protected abstract bool CanAddProperty (Type? propertyType, string propertyName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool checkClrProperty = false, bool skipTypeCheck = false);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CanAddProperty(class System.Type propertyType, string propertyName, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool checkClrProperty, bool skipTypeCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanAddProperty(System.Type,System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CanAddProperty (propertyType As Type, propertyName As String, configurationSource As ConfigurationSource, Optional checkClrProperty As Boolean = false, Optional skipTypeCheck As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanAddProperty : Type * string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource * bool * bool -&gt; bool" Usage="internalTypeBaseBuilder.CanAddProperty (propertyType, propertyName, configurationSource, checkClrProperty, skipTypeCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
        <Parameter Name="checkClrProperty" Type="System.Boolean" />
        <Parameter Name="skipTypeCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="checkClrProperty">To be added.</param>
        <param name="skipTypeCheck">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanHaveComplexProperty">
      <MemberSignature Language="C#" Value="public virtual bool CanHaveComplexProperty (Type? propertyType, string propertyName, System.Reflection.MemberInfo? memberInfo, Type? complexType, bool? collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanHaveComplexProperty(class System.Type propertyType, string propertyName, class System.Reflection.MemberInfo memberInfo, class System.Type complexType, valuetype System.Nullable`1&lt;bool&gt; collection, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanHaveComplexProperty(System.Type,System.String,System.Reflection.MemberInfo,System.Type,System.Nullable{System.Boolean},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanHaveComplexProperty (propertyType As Type, propertyName As String, memberInfo As MemberInfo, complexType As Type, collection As Nullable(Of Boolean), configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanHaveComplexProperty : Type * string * System.Reflection.MemberInfo * Type * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanHaveComplexProperty : Type * string * System.Reflection.MemberInfo * Type * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalTypeBaseBuilder.CanHaveComplexProperty (propertyType, propertyName, memberInfo, complexType, collection, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="complexType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="collection" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="complexType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanHaveProperty">
      <MemberSignature Language="C#" Value="public virtual bool CanHaveProperty (Type? propertyType, string propertyName, System.Reflection.MemberInfo? memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource, bool checkClrProperty = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanHaveProperty(class System.Type propertyType, string propertyName, class System.Reflection.MemberInfo memberInfo, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource, bool checkClrProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanHaveProperty(System.Type,System.String,System.Reflection.MemberInfo,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanHaveProperty (propertyType As Type, propertyName As String, memberInfo As MemberInfo, typeConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As Nullable(Of ConfigurationSource), Optional checkClrProperty As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanHaveProperty : Type * string * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; bool&#xA;override this.CanHaveProperty : Type * string * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; bool" Usage="internalTypeBaseBuilder.CanHaveProperty (propertyType, propertyName, memberInfo, typeConfigurationSource, configurationSource, checkClrProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="checkClrProperty" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="checkClrProperty">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanIgnore">
      <MemberSignature Language="C#" Value="public virtual bool CanIgnore (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanIgnore(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanIgnore(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanIgnore (name As String, configurationSource As ConfigurationSource) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanIgnore : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool&#xA;override this.CanIgnore : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool" Usage="internalTypeBaseBuilder.CanIgnore (name, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanIgnore">
      <MemberSignature Language="C#" Value="protected abstract bool CanIgnore (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool shouldThrow);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CanIgnore(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool shouldThrow) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanIgnore(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CanIgnore (name As String, configurationSource As ConfigurationSource, shouldThrow As Boolean) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanIgnore : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource * bool -&gt; bool" Usage="internalTypeBaseBuilder.CanIgnore (name, configurationSource, shouldThrow)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
        <Parameter Name="shouldThrow" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="shouldThrow">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRemoveComplexProperty">
      <MemberSignature Language="C#" Value="public virtual bool CanRemoveComplexProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty complexProperty, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRemoveComplexProperty(class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty complexProperty, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanRemoveComplexProperty(Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanRemoveComplexProperty (complexProperty As ComplexProperty, configurationSource As ConfigurationSource) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanRemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool&#xA;override this.CanRemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool" Usage="internalTypeBaseBuilder.CanRemoveComplexProperty (complexProperty, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="complexProperty" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="complexProperty">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRemoveProperty">
      <MemberSignature Language="C#" Value="public virtual bool CanRemoveProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool canOverrideSameSource = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool canOverrideSameSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanRemoveProperty(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanRemoveProperty (property As Property, configurationSource As ConfigurationSource, Optional canOverrideSameSource As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanRemoveProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource * bool -&gt; bool&#xA;override this.CanRemoveProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource * bool -&gt; bool" Usage="internalTypeBaseBuilder.CanRemoveProperty (property, configurationSource, canOverrideSameSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
        <Parameter Name="canOverrideSameSource" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="canOverrideSameSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual bool CanSetChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanSetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy), configurationSource As ConfigurationSource) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool&#xA;override this.CanSetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool" Usage="internalTypeBaseBuilder.CanSetChangeTrackingStrategy (changeTrackingStrategy, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetPropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual bool CanSetPropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetPropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CanSetPropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetPropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As ConfigurationSource) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool&#xA;override this.CanSetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; bool" Usage="internalTypeBaseBuilder.CanSetPropertyAccessMode (propertyAccessMode, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ComplexIndexerProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder? ComplexIndexerProperty (Type? propertyType, string propertyName, Type? complexType, bool? collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder ComplexIndexerProperty(class System.Type propertyType, string propertyName, class System.Type complexType, valuetype System.Nullable`1&lt;bool&gt; collection, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.ComplexIndexerProperty(System.Type,System.String,System.Type,System.Nullable{System.Boolean},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ComplexIndexerProperty (propertyType As Type, propertyName As String, complexType As Type, collection As Nullable(Of Boolean), configurationSource As Nullable(Of ConfigurationSource)) As InternalComplexPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member ComplexIndexerProperty : Type * string * Type * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder&#xA;override this.ComplexIndexerProperty : Type * string * Type * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder" Usage="internalTypeBaseBuilder.ComplexIndexerProperty (propertyType, propertyName, complexType, collection, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="complexType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="collection" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="complexType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder? ComplexProperty (System.Reflection.MemberInfo memberInfo, string? complexTypeName, bool? collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder ComplexProperty(class System.Reflection.MemberInfo memberInfo, string complexTypeName, valuetype System.Nullable`1&lt;bool&gt; collection, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.ComplexProperty(System.Reflection.MemberInfo,System.String,System.Nullable{System.Boolean},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ComplexProperty (memberInfo As MemberInfo, complexTypeName As String, collection As Nullable(Of Boolean), configurationSource As Nullable(Of ConfigurationSource)) As InternalComplexPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member ComplexProperty : System.Reflection.MemberInfo * string * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder&#xA;override this.ComplexProperty : System.Reflection.MemberInfo * string * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder" Usage="internalTypeBaseBuilder.ComplexProperty (memberInfo, complexTypeName, collection, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="complexTypeName" Type="System.String" />
        <Parameter Name="collection" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="complexTypeName">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder? ComplexProperty (Type? propertyType, string propertyName, string? complexTypeName, bool? collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder ComplexProperty(class System.Type propertyType, string propertyName, string complexTypeName, valuetype System.Nullable`1&lt;bool&gt; collection, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.ComplexProperty(System.Type,System.String,System.String,System.Nullable{System.Boolean},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ComplexProperty (propertyType As Type, propertyName As String, complexTypeName As String, collection As Nullable(Of Boolean), configurationSource As Nullable(Of ConfigurationSource)) As InternalComplexPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member ComplexProperty : Type * string * string * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder&#xA;override this.ComplexProperty : Type * string * string * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder" Usage="internalTypeBaseBuilder.ComplexProperty (propertyType, propertyName, complexTypeName, collection, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="complexTypeName" Type="System.String" />
        <Parameter Name="collection" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="complexTypeName">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder? ComplexProperty (Type? propertyType, string propertyName, System.Reflection.MemberInfo? memberInfo, string? complexTypeName, Type? complexType, bool? collection, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder ComplexProperty(class System.Type propertyType, string propertyName, class System.Reflection.MemberInfo memberInfo, string complexTypeName, class System.Type complexType, valuetype System.Nullable`1&lt;bool&gt; collection, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.ComplexProperty(System.Type,System.String,System.Reflection.MemberInfo,System.String,System.Type,System.Nullable{System.Boolean},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ComplexProperty (propertyType As Type, propertyName As String, memberInfo As MemberInfo, complexTypeName As String, complexType As Type, collection As Nullable(Of Boolean), configurationSource As Nullable(Of ConfigurationSource)) As InternalComplexPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member ComplexProperty : Type * string * System.Reflection.MemberInfo * string * Type * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder&#xA;override this.ComplexProperty : Type * string * System.Reflection.MemberInfo * string * Type * Nullable&lt;bool&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder" Usage="internalTypeBaseBuilder.ComplexProperty (propertyType, propertyName, memberInfo, complexTypeName, complexType, collection, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalComplexPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="complexTypeName" Type="System.String" />
        <Parameter Name="complexType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="collection" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="complexTypeName">To be added.</param>
        <param name="complexType">To be added.</param>
        <param name="collection">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUniqueProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? CreateUniqueProperties (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; principalProperties, bool isRequired, string baseName, bool checkTypes = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; CreateUniqueProperties(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; principalProperties, bool isRequired, string baseName, bool checkTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CreateUniqueProperties(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},System.Boolean,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateUniqueProperties (principalProperties As IReadOnlyList(Of Property), isRequired As Boolean, baseName As String, Optional checkTypes As Boolean = false) As IReadOnlyList(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member CreateUniqueProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * bool * string * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.CreateUniqueProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * bool * string * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="internalTypeBaseBuilder.CreateUniqueProperties (principalProperties, isRequired, baseName, checkTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principalProperties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" />
        <Parameter Name="isRequired" Type="System.Boolean" />
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="checkTypes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="principalProperties">To be added.</param>
        <param name="isRequired">To be added.</param>
        <param name="baseName">To be added.</param>
        <param name="checkTypes">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUniqueProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? CreateUniqueProperties (System.Collections.Generic.IReadOnlyList&lt;Type&gt; propertyTypes, System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames, bool isRequired, bool checkTypes = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; CreateUniqueProperties(class System.Collections.Generic.IReadOnlyList`1&lt;class System.Type&gt; propertyTypes, class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; propertyNames, bool isRequired, bool checkTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CreateUniqueProperties(System.Collections.Generic.IReadOnlyList{System.Type},System.Collections.Generic.IReadOnlyList{System.String},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateUniqueProperties (propertyTypes As IReadOnlyList(Of Type), propertyNames As IReadOnlyList(Of String), isRequired As Boolean, Optional checkTypes As Boolean = false) As IReadOnlyList(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member CreateUniqueProperties : System.Collections.Generic.IReadOnlyList&lt;Type&gt; * System.Collections.Generic.IReadOnlyList&lt;string&gt; * bool * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.CreateUniqueProperties : System.Collections.Generic.IReadOnlyList&lt;Type&gt; * System.Collections.Generic.IReadOnlyList&lt;string&gt; * bool * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="internalTypeBaseBuilder.CreateUniqueProperties (propertyTypes, propertyNames, isRequired, checkTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyTypes" Type="System.Collections.Generic.IReadOnlyList&lt;System.Type&gt;" />
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IReadOnlyList&lt;System.String&gt;" />
        <Parameter Name="isRequired" Type="System.Boolean" />
        <Parameter Name="checkTypes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyTypes">To be added.</param>
        <param name="propertyNames">To be added.</param>
        <param name="isRequired">To be added.</param>
        <param name="checkTypes">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUniqueProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? CreateUniqueProperty (Type propertyType, string propertyName, bool required, bool checkType = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder CreateUniqueProperty(class System.Type propertyType, string propertyName, bool required, bool checkType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.CreateUniqueProperty(System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateUniqueProperty (propertyType As Type, propertyName As String, required As Boolean, Optional checkType As Boolean = false) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member CreateUniqueProperty : Type * string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.CreateUniqueProperty : Type * string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.CreateUniqueProperty (propertyType, propertyName, required, checkType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="required" Type="System.Boolean" />
        <Parameter Name="checkType" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="required">To be added.</param>
        <param name="checkType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachProperties">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexPropertySnapshot&gt;? DetachProperties (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; propertiesToDetach);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexPropertySnapshot&gt; DetachProperties(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; propertiesToDetach) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.DetachProperties(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DetachProperties (propertiesToDetach As IReadOnlyList(Of ComplexProperty)) As List(Of ComplexPropertySnapshot)" />
      <MemberSignature Language="F#" Value="static member DetachProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt; -&gt; System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexPropertySnapshot&gt;" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.DetachProperties propertiesToDetach" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexPropertySnapshot&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertiesToDetach" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="propertiesToDetach">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachProperties">
      <MemberSignature Language="C#" Value="public static Microsoft.EntityFrameworkCore.Metadata.Internal.PropertiesSnapshot? DetachProperties (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; propertiesToDetach);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertiesSnapshot DetachProperties(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; propertiesToDetach) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.DetachProperties(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DetachProperties (propertiesToDetach As IReadOnlyList(Of Property)) As PropertiesSnapshot" />
      <MemberSignature Language="F#" Value="static member DetachProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertiesSnapshot" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.DetachProperties propertiesToDetach" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertiesSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertiesToDetach" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" />
      </Parameters>
      <Docs>
        <param name="propertiesToDetach">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActualProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? GetActualProperties (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? properties, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetActualProperties(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; properties, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.GetActualProperties(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetActualProperties (properties As IReadOnlyList(Of Property), configurationSource As Nullable(Of ConfigurationSource)) As IReadOnlyList(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetActualProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetActualProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="internalTypeBaseBuilder.GetActualProperties (properties, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? GetOrCreateProperties (System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;? clrMembers, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetOrCreateProperties(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; clrMembers, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.GetOrCreateProperties(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrCreateProperties (clrMembers As IEnumerable(Of MemberInfo), configurationSource As Nullable(Of ConfigurationSource)) As IReadOnlyList(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateProperties : seq&lt;System.Reflection.MemberInfo&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetOrCreateProperties : seq&lt;System.Reflection.MemberInfo&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="internalTypeBaseBuilder.GetOrCreateProperties (clrMembers, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clrMembers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="clrMembers">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateProperties">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? GetOrCreateProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt;? propertyNames, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource, System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? referencedProperties = default, bool required = false, bool useDefaultType = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; GetOrCreateProperties(class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; propertyNames, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource, class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; referencedProperties, bool required, bool useDefaultType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.GetOrCreateProperties(System.Collections.Generic.IReadOnlyList{System.String},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrCreateProperties (propertyNames As IReadOnlyList(Of String), configurationSource As Nullable(Of ConfigurationSource), Optional referencedProperties As IReadOnlyList(Of Property) = Nothing, Optional required As Boolean = false, Optional useDefaultType As Boolean = false) As IReadOnlyList(Of Property)" />
      <MemberSignature Language="F#" Value="abstract member GetOrCreateProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * bool * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&#xA;override this.GetOrCreateProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * bool * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" Usage="internalTypeBaseBuilder.GetOrCreateProperties (propertyNames, configurationSource, referencedProperties, required, useDefaultType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IReadOnlyList&lt;System.String&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="referencedProperties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" />
        <Parameter Name="required" Type="System.Boolean" />
        <Parameter Name="useDefaultType" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyNames">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="referencedProperties">To be added.</param>
        <param name="required">To be added.</param>
        <param name="useDefaultType">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder? HasChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder HasChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.HasChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy), configurationSource As ConfigurationSource) As InternalTypeBaseBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder&#xA;override this.HasChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="internalTypeBaseBuilder.HasChangeTrackingStrategy (changeTrackingStrategy, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasNoComplexProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder? HasNoComplexProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty complexProperty, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder HasNoComplexProperty(class Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty complexProperty, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.HasNoComplexProperty(Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasNoComplexProperty (complexProperty As ComplexProperty, configurationSource As ConfigurationSource) As InternalTypeBaseBuilder" />
      <MemberSignature Language="F#" Value="abstract member HasNoComplexProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder&#xA;override this.HasNoComplexProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="internalTypeBaseBuilder.HasNoComplexProperty (complexProperty, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="complexProperty" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.ComplexProperty" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="complexProperty">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public abstract Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder? Ignore (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder Ignore(string name, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Ignore(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Ignore (name As String, configurationSource As ConfigurationSource) As InternalTypeBaseBuilder" />
      <MemberSignature Language="F#" Value="abstract member Ignore : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="internalTypeBaseBuilder.Ignore (name, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexerProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? IndexerProperty (Type? propertyType, string propertyName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource, bool skipTypeCheck = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder IndexerProperty(class System.Type propertyType, string propertyName, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource, bool skipTypeCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.IndexerProperty(System.Type,System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexerProperty (propertyType As Type, propertyName As String, configurationSource As Nullable(Of ConfigurationSource), Optional skipTypeCheck As Boolean = false) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member IndexerProperty : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.IndexerProperty : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.IndexerProperty (propertyType, propertyName, configurationSource, skipTypeCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="skipTypeCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="skipTypeCheck">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompatible">
      <MemberSignature Language="C#" Value="public static bool IsCompatible (System.Reflection.MemberInfo? newMemberInfo, Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase existingProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsCompatible(class System.Reflection.MemberInfo newMemberInfo, class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase existingProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.IsCompatible(System.Reflection.MemberInfo,Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsCompatible (newMemberInfo As MemberInfo, existingProperty As PropertyBase) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsCompatible : System.Reflection.MemberInfo * Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase -&gt; bool" Usage="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.IsCompatible (newMemberInfo, existingProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newMemberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="existingProperty" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase" />
      </Parameters>
      <Docs>
        <param name="newMemberInfo">To be added.</param>
        <param name="existingProperty">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIgnored">
      <MemberSignature Language="C#" Value="public virtual bool IsIgnored (string name, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsIgnored(string name, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.IsIgnored(System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsIgnored (name As String, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsIgnored : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.IsIgnored : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalTypeBaseBuilder.IsIgnored (name, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexIndexerProperty">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanHaveComplexIndexerProperty (Type propertyType, string propertyName, Type complexType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexIndexerProperty(class System.Type propertyType, string propertyName, class System.Type complexType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanHaveComplexIndexerProperty(System.Type,System.String,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanHaveComplexIndexerProperty (propertyType As Type, propertyName As String, complexType As Type, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanHaveComplexIndexerProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexIndexerProperty : Type * string * Type * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexIndexerProperty : Type * string * Type * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexIndexerProperty (propertyType, propertyName, complexType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexIndexerProperty(System.Type,System.String,System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="complexType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="complexType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanHaveComplexProperty (System.Reflection.MemberInfo memberInfo, Type complexType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty(class System.Reflection.MemberInfo memberInfo, class System.Type complexType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanHaveComplexProperty(System.Reflection.MemberInfo,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanHaveComplexProperty (memberInfo As MemberInfo, complexType As Type, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanHaveComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty : System.Reflection.MemberInfo * Type * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty : System.Reflection.MemberInfo * Type * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty (memberInfo, complexType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty(System.Reflection.MemberInfo,System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="complexType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="complexType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanHaveComplexProperty (Type propertyType, string propertyName, Type complexType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty(class System.Type propertyType, string propertyName, class System.Type complexType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanHaveComplexProperty(System.Type,System.String,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanHaveComplexProperty (propertyType As Type, propertyName As String, complexType As Type, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanHaveComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty : Type * string * Type * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty : Type * string * Type * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty (propertyType, propertyName, complexType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveComplexProperty(System.Type,System.String,System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="complexType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="complexType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveIndexerProperty">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanHaveIndexerProperty (Type propertyType, string propertyName, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveIndexerProperty(class System.Type propertyType, string propertyName, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanHaveIndexerProperty(System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanHaveIndexerProperty (propertyType As Type, propertyName As String, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanHaveIndexerProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveIndexerProperty : Type * string * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveIndexerProperty : Type * string * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveIndexerProperty (propertyType, propertyName, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveIndexerProperty(System.Type,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanHaveProperty (System.Reflection.MemberInfo memberInfo, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty(class System.Reflection.MemberInfo memberInfo, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanHaveProperty(System.Reflection.MemberInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanHaveProperty (memberInfo As MemberInfo, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanHaveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty : System.Reflection.MemberInfo * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty : System.Reflection.MemberInfo * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty (memberInfo, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty(System.Reflection.MemberInfo,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanHaveProperty (Type propertyType, string propertyName, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty(class System.Type propertyType, string propertyName, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanHaveProperty(System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanHaveProperty (propertyType As Type, propertyName As String, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanHaveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty : Type * string * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty : Type * string * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty (propertyType, propertyName, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanHaveProperty(System.Type,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanIgnore">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanIgnore (string name, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanIgnore(string name, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanIgnore(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanIgnore (name As String, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanIgnore" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanIgnore : string * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanIgnore : string * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanIgnore (name, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanIgnore(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveComplexProperty">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanRemoveComplexProperty (Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty complexProperty, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveComplexProperty(class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty complexProperty, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanRemoveComplexProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanRemoveComplexProperty (complexProperty As IConventionComplexProperty, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanRemoveComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveComplexProperty (complexProperty, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveComplexProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="complexProperty" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="complexProperty">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveProperty">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanRemoveProperty (Microsoft.EntityFrameworkCore.Metadata.IConventionProperty property, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty property, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanRemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionProperty,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanRemoveProperty (property As IConventionProperty, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanRemoveProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionProperty * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionProperty * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveProperty (property, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanRemoveProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionProperty,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanSetChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanSetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy), fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanSetChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetChangeTrackingStrategy (changeTrackingStrategy, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetPropertyAccessMode">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.CanSetPropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetPropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CanSetPropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CanSetPropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.CanSetPropertyAccessMode" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetPropertyAccessMode (propertyAccessMode, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CanSetPropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexIndexerProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder IConventionTypeBaseBuilder.ComplexIndexerProperty (Type propertyType, string propertyName, Type complexType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexIndexerProperty(class System.Type propertyType, string propertyName, class System.Type complexType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#ComplexIndexerProperty(System.Type,System.String,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function ComplexIndexerProperty (propertyType As Type, propertyName As String, complexType As Type, fromDataAnnotation As Boolean) As IConventionComplexPropertyBuilder Implements IConventionTypeBaseBuilder.ComplexIndexerProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexIndexerProperty : Type * string * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexIndexerProperty : Type * string * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexIndexerProperty (propertyType, propertyName, complexType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexIndexerProperty(System.Type,System.String,System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="complexType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="complexType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder IConventionTypeBaseBuilder.ComplexProperty (System.Reflection.MemberInfo memberInfo, Type complexType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty(class System.Reflection.MemberInfo memberInfo, class System.Type complexType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#ComplexProperty(System.Reflection.MemberInfo,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function ComplexProperty (memberInfo As MemberInfo, complexType As Type, fromDataAnnotation As Boolean) As IConventionComplexPropertyBuilder Implements IConventionTypeBaseBuilder.ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty : System.Reflection.MemberInfo * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty : System.Reflection.MemberInfo * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty (memberInfo, complexType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty(System.Reflection.MemberInfo,System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="complexType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="complexType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder IConventionTypeBaseBuilder.ComplexProperty (Type propertyType, string propertyName, Type complexType, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty(class System.Type propertyType, string propertyName, class System.Type complexType, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#ComplexProperty(System.Type,System.String,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function ComplexProperty (propertyType As Type, propertyName As String, complexType As Type, fromDataAnnotation As Boolean) As IConventionComplexPropertyBuilder Implements IConventionTypeBaseBuilder.ComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty : Type * string * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty : Type * string * Type * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty (propertyType, propertyName, complexType, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.ComplexProperty(System.Type,System.String,System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionComplexPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="complexType" Type="System.Type" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="complexType">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CreateUniqueProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder IConventionTypeBaseBuilder.CreateUniqueProperty (Type propertyType, string basePropertyName, bool required);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CreateUniqueProperty(class System.Type propertyType, string basePropertyName, bool required) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#CreateUniqueProperty(System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function CreateUniqueProperty (propertyType As Type, basePropertyName As String, required As Boolean) As IConventionPropertyBuilder Implements IConventionTypeBaseBuilder.CreateUniqueProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CreateUniqueProperty : Type * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CreateUniqueProperty : Type * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CreateUniqueProperty (propertyType, basePropertyName, required)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.CreateUniqueProperty(System.Type,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="basePropertyName" Type="System.String" />
        <Parameter Name="required" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="basePropertyName">To be added.</param>
        <param name="required">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; IConventionTypeBaseBuilder.GetOrCreateProperties (System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; memberInfos, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; memberInfos, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#GetOrCreateProperties(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetOrCreateProperties (memberInfos As IEnumerable(Of MemberInfo), fromDataAnnotation As Boolean) As IReadOnlyList(Of IConventionProperty) Implements IConventionTypeBaseBuilder.GetOrCreateProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties : seq&lt;System.Reflection.MemberInfo&gt; * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties : seq&lt;System.Reflection.MemberInfo&gt; * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties (memberInfos, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfos" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="memberInfos">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; IConventionTypeBaseBuilder.GetOrCreateProperties (System.Collections.Generic.IReadOnlyList&lt;string&gt; propertyNames, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties(class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; propertyNames, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#GetOrCreateProperties(System.Collections.Generic.IReadOnlyList{System.String},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetOrCreateProperties (propertyNames As IReadOnlyList(Of String), fromDataAnnotation As Boolean) As IReadOnlyList(Of IConventionProperty) Implements IConventionTypeBaseBuilder.GetOrCreateProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties : System.Collections.Generic.IReadOnlyList&lt;string&gt; * bool -&gt; System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties (propertyNames, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.GetOrCreateProperties(System.Collections.Generic.IReadOnlyList{System.String},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyNames" Type="System.Collections.Generic.IReadOnlyList&lt;System.String&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyNames">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasAnnotation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder IConventionTypeBaseBuilder.HasAnnotation (string name, object value, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasAnnotation(string name, object value, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#HasAnnotation(System.String,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasAnnotation (name As String, value As Object, fromDataAnnotation As Boolean) As IConventionTypeBaseBuilder Implements IConventionTypeBaseBuilder.HasAnnotation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasAnnotation : string * obj * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasAnnotation : string * obj * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasAnnotation (name, value, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasAnnotation(System.String,System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="value">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder IConventionTypeBaseBuilder.HasChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy? changeTrackingStrategy, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasChangeTrackingStrategy(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; changeTrackingStrategy, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#HasChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasChangeTrackingStrategy (changeTrackingStrategy As Nullable(Of ChangeTrackingStrategy), fromDataAnnotation As Boolean) As IConventionTypeBaseBuilder Implements IConventionTypeBaseBuilder.HasChangeTrackingStrategy" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasChangeTrackingStrategy : Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasChangeTrackingStrategy (changeTrackingStrategy, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasChangeTrackingStrategy(System.Nullable{Microsoft.EntityFrameworkCore.ChangeTrackingStrategy},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.ChangeTrackingStrategy&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoAnnotation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder IConventionTypeBaseBuilder.HasNoAnnotation (string name, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoAnnotation(string name, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#HasNoAnnotation(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasNoAnnotation (name As String, fromDataAnnotation As Boolean) As IConventionTypeBaseBuilder Implements IConventionTypeBaseBuilder.HasNoAnnotation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoAnnotation : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoAnnotation : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoAnnotation (name, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoAnnotation(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoComplexProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder IConventionTypeBaseBuilder.HasNoComplexProperty (Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty complexProperty, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoComplexProperty(class Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty complexProperty, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#HasNoComplexProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasNoComplexProperty (complexProperty As IConventionComplexProperty, fromDataAnnotation As Boolean) As IConventionTypeBaseBuilder Implements IConventionTypeBaseBuilder.HasNoComplexProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoComplexProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoComplexProperty (complexProperty, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoComplexProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="complexProperty" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionComplexProperty" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="complexProperty">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNonNullAnnotation">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder IConventionTypeBaseBuilder.HasNonNullAnnotation (string name, object value, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNonNullAnnotation(string name, object value, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#HasNonNullAnnotation(System.String,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasNonNullAnnotation (name As String, value As Object, fromDataAnnotation As Boolean) As IConventionTypeBaseBuilder Implements IConventionTypeBaseBuilder.HasNonNullAnnotation" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNonNullAnnotation : string * obj * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNonNullAnnotation : string * obj * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNonNullAnnotation (name, value, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNonNullAnnotation(System.String,System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="value">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder IConventionTypeBaseBuilder.HasNoProperty (Microsoft.EntityFrameworkCore.Metadata.IConventionProperty property, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoProperty(class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty property, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#HasNoProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionProperty,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function HasNoProperty (property As IConventionProperty, fromDataAnnotation As Boolean) As IConventionTypeBaseBuilder Implements IConventionTypeBaseBuilder.HasNoProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionProperty * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoProperty : Microsoft.EntityFrameworkCore.Metadata.IConventionProperty * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoProperty (property, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.HasNoProperty(Microsoft.EntityFrameworkCore.Metadata.IConventionProperty,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IConventionProperty" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Ignore">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder IConventionTypeBaseBuilder.Ignore (string memberName, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Ignore(string memberName, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#Ignore(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function Ignore (memberName As String, fromDataAnnotation As Boolean) As IConventionTypeBaseBuilder Implements IConventionTypeBaseBuilder.Ignore" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Ignore : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Ignore : string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Ignore (memberName, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Ignore(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberName" Type="System.String" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="memberName">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IndexerProperty">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder IConventionTypeBaseBuilder.IndexerProperty (Type propertyType, string propertyName, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IndexerProperty(class System.Type propertyType, string propertyName, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#IndexerProperty(System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IndexerProperty (propertyType As Type, propertyName As String, fromDataAnnotation As Boolean) As IConventionPropertyBuilder Implements IConventionTypeBaseBuilder.IndexerProperty" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IndexerProperty : Type * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IndexerProperty : Type * string * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IndexerProperty (propertyType, propertyName, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IndexerProperty(System.Type,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IsIgnored">
      <MemberSignature Language="C#" Value="bool IConventionTypeBaseBuilder.IsIgnored (string name, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IsIgnored(string name, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#IsIgnored(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsIgnored (name As String, fromDataAnnotation As Boolean) As Boolean Implements IConventionTypeBaseBuilder.IsIgnored" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IsIgnored : string * bool -&gt; bool&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IsIgnored : string * bool -&gt; bool" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IsIgnored (name, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.IsIgnored(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Metadata">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Metadata" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#Metadata" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Metadata As IConventionTypeBase Implements IConventionTypeBaseBuilder.Metadata" />
      <MemberSignature Language="F#" Value="member this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Metadata : Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase" Usage="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Metadata" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Metadata</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IConventionTypeBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder IConventionTypeBaseBuilder.Property (System.Reflection.MemberInfo memberInfo, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property(class System.Reflection.MemberInfo memberInfo, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#Property(System.Reflection.MemberInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function Property (memberInfo As MemberInfo, fromDataAnnotation As Boolean) As IConventionPropertyBuilder Implements IConventionTypeBaseBuilder.Property" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property : System.Reflection.MemberInfo * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property : System.Reflection.MemberInfo * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property (memberInfo, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property(System.Reflection.MemberInfo,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder IConventionTypeBaseBuilder.Property (Type propertyType, string propertyName, bool setTypeConfigurationSource, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property(class System.Type propertyType, string propertyName, bool setTypeConfigurationSource, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#Property(System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function Property (propertyType As Type, propertyName As String, setTypeConfigurationSource As Boolean, fromDataAnnotation As Boolean) As IConventionPropertyBuilder Implements IConventionTypeBaseBuilder.Property" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property : Type * string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property : Type * string * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property (propertyType, propertyName, setTypeConfigurationSource, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.Property(System.Type,System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="setTypeConfigurationSource" Type="System.Boolean" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="setTypeConfigurationSource">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.RemoveUnusedImplicitProperties">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder IConventionTypeBaseBuilder.RemoveUnusedImplicitProperties (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.RemoveUnusedImplicitProperties(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#RemoveUnusedImplicitProperties(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty})" />
      <MemberSignature Language="VB.NET" Value="Function RemoveUnusedImplicitProperties (properties As IReadOnlyList(Of IConventionProperty)) As IConventionTypeBaseBuilder Implements IConventionTypeBaseBuilder.RemoveUnusedImplicitProperties" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.RemoveUnusedImplicitProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.RemoveUnusedImplicitProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.RemoveUnusedImplicitProperties properties" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.RemoveUnusedImplicitProperties(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.UsePropertyAccessMode">
      <MemberSignature Language="C#" Value="Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder IConventionTypeBaseBuilder.UsePropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, bool fromDataAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.UsePropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, bool fromDataAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Microsoft#EntityFrameworkCore#Metadata#Builders#IConventionTypeBaseBuilder#UsePropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function UsePropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), fromDataAnnotation As Boolean) As IConventionTypeBaseBuilder Implements IConventionTypeBaseBuilder.UsePropertyAccessMode" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.UsePropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder&#xA;override this.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.UsePropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder" Usage="internalTypeBaseBuilder.Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.UsePropertyAccessMode (propertyAccessMode, fromDataAnnotation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder.UsePropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IConventionTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" />
        <Parameter Name="fromDataAnnotation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="fromDataAnnotation">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimitiveCollection">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? PrimitiveCollection (System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder PrimitiveCollection(class System.Reflection.MemberInfo memberInfo, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.PrimitiveCollection(System.Reflection.MemberInfo,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PrimitiveCollection (memberInfo As MemberInfo, configurationSource As Nullable(Of ConfigurationSource)) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member PrimitiveCollection : System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.PrimitiveCollection : System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.PrimitiveCollection (memberInfo, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimitiveCollection">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? PrimitiveCollection (string propertyName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder PrimitiveCollection(string propertyName, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.PrimitiveCollection(System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PrimitiveCollection (propertyName As String, configurationSource As Nullable(Of ConfigurationSource)) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member PrimitiveCollection : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.PrimitiveCollection : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.PrimitiveCollection (propertyName, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimitiveCollection">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? PrimitiveCollection (Type? propertyType, string propertyName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder PrimitiveCollection(class System.Type propertyType, string propertyName, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.PrimitiveCollection(System.Type,System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PrimitiveCollection (propertyType As Type, propertyName As String, configurationSource As Nullable(Of ConfigurationSource)) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member PrimitiveCollection : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.PrimitiveCollection : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.PrimitiveCollection (propertyType, propertyName, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimitiveCollection">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? PrimitiveCollection (Type? propertyType, string propertyName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder PrimitiveCollection(class System.Type propertyType, string propertyName, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.PrimitiveCollection(System.Type,System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PrimitiveCollection (propertyType As Type, propertyName As String, typeConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As Nullable(Of ConfigurationSource)) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member PrimitiveCollection : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.PrimitiveCollection : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.PrimitiveCollection (propertyType, propertyName, typeConfigurationSource, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimitiveCollection">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? PrimitiveCollection (Type? propertyType, string propertyName, System.Reflection.MemberInfo? memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder PrimitiveCollection(class System.Type propertyType, string propertyName, class System.Reflection.MemberInfo memberInfo, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.PrimitiveCollection(System.Type,System.String,System.Reflection.MemberInfo,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function PrimitiveCollection (propertyType As Type, propertyName As String, memberInfo As MemberInfo, typeConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As Nullable(Of ConfigurationSource)) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member PrimitiveCollection : Type * string * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.PrimitiveCollection : Type * string * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.PrimitiveCollection (propertyType, propertyName, memberInfo, typeConfigurationSource, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? Property (System.Reflection.MemberInfo memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder Property(class System.Reflection.MemberInfo memberInfo, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Property(System.Reflection.MemberInfo,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Property (memberInfo As MemberInfo, configurationSource As Nullable(Of ConfigurationSource)) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member Property : System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.Property : System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.Property (memberInfo, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="memberInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? Property (string propertyName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder Property(string propertyName, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Property(System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Property (propertyName As String, configurationSource As Nullable(Of ConfigurationSource)) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member Property : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.Property : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.Property (propertyName, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? Property (Type? propertyType, string propertyName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource, bool skipTypeCheck = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder Property(class System.Type propertyType, string propertyName, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource, bool skipTypeCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Property(System.Type,System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Property (propertyType As Type, propertyName As String, configurationSource As Nullable(Of ConfigurationSource), Optional skipTypeCheck As Boolean = false) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member Property : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.Property : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.Property (propertyType, propertyName, configurationSource, skipTypeCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="skipTypeCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="skipTypeCheck">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? Property (Type? propertyType, string propertyName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource, bool skipTypeCheck = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder Property(class System.Type propertyType, string propertyName, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource, bool skipTypeCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Property(System.Type,System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Property (propertyType As Type, propertyName As String, typeConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As Nullable(Of ConfigurationSource), Optional skipTypeCheck As Boolean = false) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member Property : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.Property : Type * string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.Property (propertyType, propertyName, typeConfigurationSource, configurationSource, skipTypeCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="skipTypeCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="skipTypeCheck">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder? Property (Type? propertyType, string propertyName, System.Reflection.MemberInfo? memberInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? typeConfigurationSource, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource, bool skipTypeCheck = false);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder Property(class System.Type propertyType, string propertyName, class System.Reflection.MemberInfo memberInfo, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; typeConfigurationSource, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource, bool skipTypeCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.Property(System.Type,System.String,System.Reflection.MemberInfo,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Property (propertyType As Type, propertyName As String, memberInfo As MemberInfo, typeConfigurationSource As Nullable(Of ConfigurationSource), configurationSource As Nullable(Of ConfigurationSource), Optional skipTypeCheck As Boolean = false) As InternalPropertyBuilder" />
      <MemberSignature Language="F#" Value="abstract member Property : Type * string * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder&#xA;override this.Property : Type * string * System.Reflection.MemberInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" Usage="internalTypeBaseBuilder.Property (propertyType, propertyName, memberInfo, typeConfigurationSource, configurationSource, skipTypeCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="memberInfo" Type="System.Reflection.MemberInfo" />
        <Parameter Name="typeConfigurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
        <Parameter Name="skipTypeCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyType">To be added.</param>
        <param name="propertyName">To be added.</param>
        <param name="memberInfo">To be added.</param>
        <param name="typeConfigurationSource">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="skipTypeCheck">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMembersInHierarchy">
      <MemberSignature Language="C#" Value="public virtual void RemoveMembersInHierarchy (string propertyName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveMembersInHierarchy(string propertyName, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.RemoveMembersInHierarchy(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveMembersInHierarchy (propertyName As String, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member RemoveMembersInHierarchy : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.RemoveMembersInHierarchy : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="internalTypeBaseBuilder.RemoveMembersInHierarchy (propertyName, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="propertyName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveProperty">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? RemoveProperty (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool canOverrideSameSource = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; RemoveProperty(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource, bool canOverrideSameSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.RemoveProperty(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveProperty (property As Property, configurationSource As ConfigurationSource, Optional canOverrideSameSource As Boolean = true) As Nullable(Of ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;&#xA;override this.RemoveProperty : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource * bool -&gt; Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" Usage="internalTypeBaseBuilder.RemoveProperty (property, configurationSource, canOverrideSameSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
        <Parameter Name="canOverrideSameSource" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <param name="canOverrideSameSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePropertyIfUnused">
      <MemberSignature Language="C#" Value="protected virtual void RemovePropertyIfUnused (Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RemovePropertyIfUnused(class Microsoft.EntityFrameworkCore.Metadata.Internal.Property property, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.RemovePropertyIfUnused(Microsoft.EntityFrameworkCore.Metadata.Internal.Property,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RemovePropertyIfUnused (property As Property, configurationSource As ConfigurationSource)" />
      <MemberSignature Language="F#" Value="abstract member RemovePropertyIfUnused : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit&#xA;override this.RemovePropertyIfUnused : Microsoft.EntityFrameworkCore.Metadata.Internal.Property * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; unit" Usage="internalTypeBaseBuilder.RemovePropertyIfUnused (property, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.Property" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="property">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveUnusedImplicitProperties">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder RemoveUnusedImplicitProperties (System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder RemoveUnusedImplicitProperties(class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.RemoveUnusedImplicitProperties(System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.IConventionProperty})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveUnusedImplicitProperties (properties As IReadOnlyList(Of IConventionProperty)) As InternalTypeBaseBuilder" />
      <MemberSignature Language="F#" Value="abstract member RemoveUnusedImplicitProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder&#xA;override this.RemoveUnusedImplicitProperties : System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="internalTypeBaseBuilder.RemoveUnusedImplicitProperties properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.IConventionProperty&gt;" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateUniqueProperties">
      <MemberSignature Language="C#" Value="public virtual (bool, System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;?) TryCreateUniqueProperties (int propertyCount, System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;? currentProperties, System.Collections.Generic.IEnumerable&lt;Type&gt; principalPropertyTypes, System.Collections.Generic.IEnumerable&lt;string&gt; principalPropertyNames, bool isRequired, string baseName, bool checkTypes = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.ValueTuple`2&lt;bool, class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&gt; TryCreateUniqueProperties(int32 propertyCount, class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; currentProperties, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; principalPropertyTypes, class System.Collections.Generic.IEnumerable`1&lt;string&gt; principalPropertyNames, bool isRequired, string baseName, bool checkTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.TryCreateUniqueProperties(System.Int32,System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.Metadata.Internal.Property},System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateUniqueProperties (propertyCount As Integer, currentProperties As IReadOnlyList(Of Property), principalPropertyTypes As IEnumerable(Of Type), principalPropertyNames As IEnumerable(Of String), isRequired As Boolean, baseName As String, Optional checkTypes As Boolean = false) As ValueTuple(Of Boolean, IReadOnlyList(Of Property))" />
      <MemberSignature Language="F#" Value="abstract member TryCreateUniqueProperties : int * System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * seq&lt;Type&gt; * seq&lt;string&gt; * bool * string * bool -&gt; ValueTuple&lt;bool, System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&gt;&#xA;override this.TryCreateUniqueProperties : int * System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt; * seq&lt;Type&gt; * seq&lt;string&gt; * bool * string * bool -&gt; ValueTuple&lt;bool, System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&gt;" Usage="internalTypeBaseBuilder.TryCreateUniqueProperties (propertyCount, currentProperties, principalPropertyTypes, principalPropertyNames, isRequired, baseName, checkTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Boolean,System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyCount" Type="System.Int32" />
        <Parameter Name="currentProperties" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.Metadata.Internal.Property&gt;" />
        <Parameter Name="principalPropertyTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
        <Parameter Name="principalPropertyNames" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="isRequired" Type="System.Boolean" />
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="checkTypes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyCount">To be added.</param>
        <param name="currentProperties">To be added.</param>
        <param name="principalPropertyTypes">To be added.</param>
        <param name="principalPropertyNames">To be added.</param>
        <param name="isRequired">To be added.</param>
        <param name="baseName">To be added.</param>
        <param name="checkTypes">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UsePropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder? UsePropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder UsePropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder.UsePropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UsePropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As ConfigurationSource) As InternalTypeBaseBuilder" />
      <MemberSignature Language="F#" Value="abstract member UsePropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder&#xA;override this.UsePropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder" Usage="internalTypeBaseBuilder.UsePropertyAccessMode (propertyAccessMode, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalTypeBaseBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
