<Type Name="InternalPropertyBaseBuilder&lt;TPropertyBase&gt;" FullName="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt;">
  <TypeSignature Language="C#" Value="public class InternalPropertyBaseBuilder&lt;TPropertyBase&gt; : Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder&lt;TPropertyBase,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt; where TPropertyBase : PropertyBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InternalPropertyBaseBuilder`1&lt;(class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase) TPropertyBase&gt; extends Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder`2&lt;!TPropertyBase, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1" />
  <TypeSignature Language="VB.NET" Value="Public Class InternalPropertyBaseBuilder(Of TPropertyBase)&#xA;Inherits AnnotatableBuilder(Of TPropertyBase, InternalModelBuilder)" />
  <TypeSignature Language="F#" Value="type InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; PropertyBase)&gt; = class&#xA;    inherit AnnotatableBuilder&lt;'PropertyBase, InternalModelBuilder (requires 'PropertyBase :&gt; PropertyBase)&gt;" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TPropertyBase">
      <Constraints>
        <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase</BaseTypeName>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Infrastructure.AnnotatableBuilder&lt;TPropertyBase,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="TMetadata">TPropertyBase</BaseTypeArgument>
      <BaseTypeArgument TypeParamName="TModelBuilder">Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TPropertyBase">To be added.</typeparam>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalPropertyBaseBuilder (TPropertyBase metadata, Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder modelBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!TPropertyBase metadata, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder modelBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1.#ctor(`0,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (metadata As TPropertyBase, modelBuilder As InternalModelBuilder)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt; : 'PropertyBase * Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt;" Usage="new Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt; (metadata, modelBuilder)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="metadata" Type="TPropertyBase" />
        <Parameter Name="modelBuilder" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalModelBuilder" />
      </Parameters>
      <Docs>
        <param name="metadata">To be added.</param>
        <param name="modelBuilder">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetField">
      <MemberSignature Language="C#" Value="public virtual bool CanSetField (System.Reflection.FieldInfo fieldInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetField(class System.Reflection.FieldInfo fieldInfo, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1.CanSetField(System.Reflection.FieldInfo,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetField (fieldInfo As FieldInfo, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetField : System.Reflection.FieldInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetField : System.Reflection.FieldInfo * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalPropertyBaseBuilder.CanSetField (fieldInfo, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual bool CanSetField (System.Reflection.FieldInfo? fieldInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="fieldInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetField">
      <MemberSignature Language="C#" Value="public virtual bool CanSetField (string fieldName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetField(string fieldName, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1.CanSetField(System.String,System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetField (fieldName As String, configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetField : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetField : string * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalPropertyBaseBuilder.CanSetField (fieldName, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual bool CanSetField (string? fieldName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="fieldName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSetPropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual bool CanSetPropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource? configurationSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanSetPropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1.CanSetPropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},System.Nullable{Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanSetPropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As Nullable(Of ConfigurationSource)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member CanSetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool&#xA;override this.CanSetPropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt; -&gt; bool" Usage="internalPropertyBaseBuilder.CanSetPropertyAccessMode (propertyAccessMode, configurationSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" />
        <Parameter Name="configurationSource" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasField">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt; HasField (System.Reflection.FieldInfo fieldInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1&lt;!TPropertyBase&gt; HasField(class System.Reflection.FieldInfo fieldInfo, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1.HasField(System.Reflection.FieldInfo,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasField (fieldInfo As FieldInfo, configurationSource As ConfigurationSource) As InternalPropertyBaseBuilder(Of TPropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member HasField : System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt;&#xA;override this.HasField : System.Reflection.FieldInfo * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt;" Usage="internalPropertyBaseBuilder.HasField (fieldInfo, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt;? HasField (System.Reflection.FieldInfo? fieldInfo, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="fieldInfo">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasField">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt; HasField (string fieldName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1&lt;!TPropertyBase&gt; HasField(string fieldName, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1.HasField(System.String,Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasField (fieldName As String, configurationSource As ConfigurationSource) As InternalPropertyBaseBuilder(Of TPropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member HasField : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt;&#xA;override this.HasField : string * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt;" Usage="internalPropertyBaseBuilder.HasField (fieldName, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt;? HasField (string? fieldName, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="fieldName">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UsePropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt; UsePropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1&lt;!TPropertyBase&gt; UsePropertyAccessMode(valuetype System.Nullable`1&lt;valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; propertyAccessMode, valuetype Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder`1.UsePropertyAccessMode(System.Nullable{Microsoft.EntityFrameworkCore.PropertyAccessMode},Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UsePropertyAccessMode (propertyAccessMode As Nullable(Of PropertyAccessMode), configurationSource As ConfigurationSource) As InternalPropertyBaseBuilder(Of TPropertyBase)" />
      <MemberSignature Language="F#" Value="abstract member UsePropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt;&#xA;override this.UsePropertyAccessMode : Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt; * Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource -&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;'PropertyBase (requires 'PropertyBase :&gt; Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBase)&gt;" Usage="internalPropertyBaseBuilder.UsePropertyAccessMode (propertyAccessMode, configurationSource)" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt;? UsePropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode? propertyAccessMode, Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource configurationSource);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBaseBuilder&lt;TPropertyBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="System.Nullable&lt;Microsoft.EntityFrameworkCore.PropertyAccessMode&gt;" />
        <Parameter Name="configurationSource" Type="Microsoft.EntityFrameworkCore.Metadata.ConfigurationSource" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode">To be added.</param>
        <param name="configurationSource">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
