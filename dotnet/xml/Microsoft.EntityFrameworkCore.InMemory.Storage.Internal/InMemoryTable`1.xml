<Type Name="InMemoryTable&lt;TKey&gt;" FullName="Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;TKey&gt;">
  <TypeSignature Language="C#" Value="public class InMemoryTable&lt;TKey&gt; : Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InMemoryTable`1&lt;TKey&gt; extends System.Object implements class Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1" />
  <TypeSignature Language="VB.NET" Value="Public Class InMemoryTable(Of TKey)&#xA;Implements IInMemoryTable" />
  <TypeSignature Language="F#" Value="type InMemoryTable&lt;'Key&gt; = class&#xA;    interface IInMemoryTable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.11.0</AssemblyVersion>
    <AssemblyVersion>2.2.6.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TKey">To be added.</typeparam>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InMemoryTable (Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IPrincipalKeyValueFactory&lt;TKey&gt; keyValueFactory, bool sensitiveLoggingEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IPrincipalKeyValueFactory`1&lt;!TKey&gt; keyValueFactory, bool sensitiveLoggingEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.#ctor(Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IPrincipalKeyValueFactory{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keyValueFactory As IPrincipalKeyValueFactory(Of TKey), sensitiveLoggingEnabled As Boolean)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt; : Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IPrincipalKeyValueFactory&lt;'Key&gt; * bool -&gt; Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt;" Usage="new Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt; (keyValueFactory, sensitiveLoggingEnabled)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keyValueFactory" Type="Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IPrincipalKeyValueFactory&lt;TKey&gt;" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
        <Parameter Name="sensitiveLoggingEnabled" Type="System.Boolean" Index="1" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <param name="keyValueFactory">To be added.</param>
        <param name="sensitiveLoggingEnabled">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InMemoryTable (Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable baseTable, bool sensitiveLoggingEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, class Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable baseTable, bool sensitiveLoggingEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.#ctor(Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (entityType As IEntityType, baseTable As IInMemoryTable, sensitiveLoggingEnabled As Boolean)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt; : Microsoft.EntityFrameworkCore.Metadata.IEntityType * Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable * bool -&gt; Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt;" Usage="new Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt; (entityType, baseTable, sensitiveLoggingEnabled)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="0" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="baseTable" Type="Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable" Index="1" FrameworkAlternate="efcore-5.0" />
        <Parameter Name="sensitiveLoggingEnabled" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-5.0" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="baseTable">To be added.</param>
        <param name="sensitiveLoggingEnabled">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InMemoryTable (Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable? baseTable, bool sensitiveLoggingEnabled, bool nullabilityCheckEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, class Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable baseTable, bool sensitiveLoggingEnabled, bool nullabilityCheckEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.#ctor(Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (entityType As IEntityType, baseTable As IInMemoryTable, sensitiveLoggingEnabled As Boolean, nullabilityCheckEnabled As Boolean)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt; : Microsoft.EntityFrameworkCore.Metadata.IEntityType * Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable * bool * bool -&gt; Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt;" Usage="new Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt; (entityType, baseTable, sensitiveLoggingEnabled, nullabilityCheckEnabled)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" Index="0" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="baseTable" Type="Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable" Index="1" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="sensitiveLoggingEnabled" Type="System.Boolean" Index="2" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="nullabilityCheckEnabled" Type="System.Boolean" Index="3" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="entityType">To be added.</param>
        <param name="baseTable">To be added.</param>
        <param name="sensitiveLoggingEnabled">To be added.</param>
        <param name="nullabilityCheckEnabled">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseTable">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable BaseTable { get; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable BaseTable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.BaseTable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseTable As IInMemoryTable" />
      <MemberSignature Language="F#" Value="member this.BaseTable : Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable" Usage="Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt;.BaseTable" />
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable? BaseTable { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.BaseTable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BumpValueGenerators">
      <MemberSignature Language="C#" Value="public virtual void BumpValueGenerators (object[] row);" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BumpValueGenerators(object[] row) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.BumpValueGenerators(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BumpValueGenerators (row As Object())" />
      <MemberSignature Language="F#" Value="abstract member BumpValueGenerators : obj[] -&gt; unit&#xA;override this.BumpValueGenerators : obj[] -&gt; unit" Usage="inMemoryTable.BumpValueGenerators row" />
      <MemberSignature Language="C#" Value="public virtual void BumpValueGenerators (object?[] row);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.BumpValueGenerators(System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Object[]" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="row">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public virtual void Create (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Create(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.Create(Microsoft.EntityFrameworkCore.Update.IUpdateEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Create (entry As IUpdateEntry)" />
      <MemberSignature Language="F#" Value="abstract member Create : Microsoft.EntityFrameworkCore.Update.IUpdateEntry -&gt; unit&#xA;override this.Create : Microsoft.EntityFrameworkCore.Update.IUpdateEntry -&gt; unit" Usage="inMemoryTable.Create entry" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.Create(Microsoft.EntityFrameworkCore.Update.IUpdateEntry)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public virtual void Create (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; updateLogger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Create(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, class Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger`1&lt;class Microsoft.EntityFrameworkCore.DbLoggerCategory/Update&gt; updateLogger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.Create(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger{Microsoft.EntityFrameworkCore.DbLoggerCategory.Update})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Create (entry As IUpdateEntry, updateLogger As IDiagnosticsLogger(Of DbLoggerCategory.Update))" />
      <MemberSignature Language="F#" Value="abstract member Create : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; -&gt; unit&#xA;override this.Create : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; -&gt; unit" Usage="inMemoryTable.Create (entry, updateLogger)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.Create(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger{Microsoft.EntityFrameworkCore.DbLoggerCategory.Update})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
        <Parameter Name="updateLogger" Type="Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory+Update&gt;" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="updateLogger">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public virtual void Delete (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Delete(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.Delete(Microsoft.EntityFrameworkCore.Update.IUpdateEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Delete (entry As IUpdateEntry)" />
      <MemberSignature Language="F#" Value="abstract member Delete : Microsoft.EntityFrameworkCore.Update.IUpdateEntry -&gt; unit&#xA;override this.Delete : Microsoft.EntityFrameworkCore.Update.IUpdateEntry -&gt; unit" Usage="inMemoryTable.Delete entry" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.Delete(Microsoft.EntityFrameworkCore.Update.IUpdateEntry)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public virtual void Delete (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; updateLogger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Delete(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, class Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger`1&lt;class Microsoft.EntityFrameworkCore.DbLoggerCategory/Update&gt; updateLogger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.Delete(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger{Microsoft.EntityFrameworkCore.DbLoggerCategory.Update})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Delete (entry As IUpdateEntry, updateLogger As IDiagnosticsLogger(Of DbLoggerCategory.Update))" />
      <MemberSignature Language="F#" Value="abstract member Delete : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; -&gt; unit&#xA;override this.Delete : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; -&gt; unit" Usage="inMemoryTable.Delete (entry, updateLogger)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.Delete(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger{Microsoft.EntityFrameworkCore.DbLoggerCategory.Update})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
        <Parameter Name="updateLogger" Type="Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory+Update&gt;" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="updateLogger">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityType">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.IEntityType EntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType EntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.EntityType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntityType As IEntityType" />
      <MemberSignature Language="F#" Value="member this.EntityType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt;.EntityType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.EntityType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIntegerValueGenerator&lt;TProperty&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator&lt;TProperty&gt; GetIntegerValueGenerator&lt;TProperty&gt; (Microsoft.EntityFrameworkCore.Metadata.IProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator`1&lt;!!TProperty&gt; GetIntegerValueGenerator&lt;TProperty&gt;(class Microsoft.EntityFrameworkCore.Metadata.IProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.GetIntegerValueGenerator``1(Microsoft.EntityFrameworkCore.Metadata.IProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIntegerValueGenerator(Of TProperty) (property As IProperty) As InMemoryIntegerValueGenerator(Of TProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetIntegerValueGenerator : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator&lt;'Property&gt;&#xA;override this.GetIntegerValueGenerator : Microsoft.EntityFrameworkCore.Metadata.IProperty -&gt; Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator&lt;'Property&gt;" Usage="inMemoryTable.GetIntegerValueGenerator property" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.GetIntegerValueGenerator``1(Microsoft.EntityFrameworkCore.Metadata.IProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProperty" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" Index="0" FrameworkAlternate="efcore-3.0;efcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TProperty">To be added.</typeparam>
        <param name="property">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIntegerValueGenerator&lt;TProperty&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator&lt;TProperty&gt; GetIntegerValueGenerator&lt;TProperty&gt; (Microsoft.EntityFrameworkCore.Metadata.IProperty property, System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable&gt; tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator`1&lt;!!TProperty&gt; GetIntegerValueGenerator&lt;TProperty&gt;(class Microsoft.EntityFrameworkCore.Metadata.IProperty property, class System.Collections.Generic.IReadOnlyList`1&lt;class Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable&gt; tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.GetIntegerValueGenerator``1(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetIntegerValueGenerator(Of TProperty) (property As IProperty, tables As IReadOnlyList(Of IInMemoryTable)) As InMemoryIntegerValueGenerator(Of TProperty)" />
      <MemberSignature Language="F#" Value="abstract member GetIntegerValueGenerator : Microsoft.EntityFrameworkCore.Metadata.IProperty * System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable&gt; -&gt; Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator&lt;'Property&gt;&#xA;override this.GetIntegerValueGenerator : Microsoft.EntityFrameworkCore.Metadata.IProperty * System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable&gt; -&gt; Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator&lt;'Property&gt;" Usage="inMemoryTable.GetIntegerValueGenerator (property, tables)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.GetIntegerValueGenerator``1(Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Collections.Generic.IReadOnlyList{Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.InMemory.ValueGeneration.Internal.InMemoryIntegerValueGenerator&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProperty" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IProperty" Index="0" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
        <Parameter Name="tables" Type="System.Collections.Generic.IReadOnlyList&lt;Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable&gt;" Index="1" FrameworkAlternate="efcore-5.0;efcore-6.0;efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <typeparam name="TProperty">To be added.</typeparam>
        <param name="property">To be added.</param>
        <param name="tables">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;object[]&gt; Rows { get; }" FrameworkAlternate="efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;object[]&gt; Rows" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.Rows" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Rows As IEnumerable(Of Object())" />
      <MemberSignature Language="F#" Value="member this.Rows : seq&lt;obj[]&gt;" Usage="Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable&lt;'Key&gt;.Rows" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;object?[]&gt; Rows { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.Rows</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Object[]&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapshotRows">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;object[]&gt; SnapshotRows ();" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyList`1&lt;object[]&gt; SnapshotRows() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.SnapshotRows" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SnapshotRows () As IReadOnlyList(Of Object())" />
      <MemberSignature Language="F#" Value="abstract member SnapshotRows : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;obj[]&gt;&#xA;override this.SnapshotRows : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;obj[]&gt;" Usage="inMemoryTable.SnapshotRows " />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IReadOnlyList&lt;object?[]&gt; SnapshotRows ();" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.SnapshotRows</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;System.Object[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowUpdateConcurrencyException">
      <MemberSignature Language="C#" Value="protected virtual void ThrowUpdateConcurrencyException (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,object&gt; concurrencyConflicts);" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ThrowUpdateConcurrencyException(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, class System.Collections.Generic.Dictionary`2&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, object&gt; concurrencyConflicts) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.ThrowUpdateConcurrencyException(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,System.Collections.Generic.Dictionary{Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ThrowUpdateConcurrencyException (entry As IUpdateEntry, concurrencyConflicts As Dictionary(Of IProperty, Object))" />
      <MemberSignature Language="F#" Value="abstract member ThrowUpdateConcurrencyException : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, obj&gt; -&gt; unit&#xA;override this.ThrowUpdateConcurrencyException : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, obj&gt; -&gt; unit" Usage="inMemoryTable.ThrowUpdateConcurrencyException (entry, concurrencyConflicts)" />
      <MemberSignature Language="C#" Value="protected virtual void ThrowUpdateConcurrencyException (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,object?&gt; concurrencyConflicts);" FrameworkAlternate="efcore-6.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
        <Parameter Name="concurrencyConflicts" Type="System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Object&gt;" Index="1" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      </Parameters>
      <Docs>
        <param name="entry">The update entry which resulted in the conflict(s).</param>
        <param name="concurrencyConflicts">The conflicting properties with their associated database values.</param>
        <summary>
                Throws an exception indicating that concurrency conflicts were detected.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowUpdateConcurrencyException">
      <MemberSignature Language="C#" Value="protected virtual void ThrowUpdateConcurrencyException (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,object?&gt; concurrencyConflicts, Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; updateLogger);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ThrowUpdateConcurrencyException(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, class System.Collections.Generic.Dictionary`2&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, object&gt; concurrencyConflicts, class Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger`1&lt;class Microsoft.EntityFrameworkCore.DbLoggerCategory/Update&gt; updateLogger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.ThrowUpdateConcurrencyException(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,System.Collections.Generic.Dictionary{Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Object},Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger{Microsoft.EntityFrameworkCore.DbLoggerCategory.Update})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ThrowUpdateConcurrencyException (entry As IUpdateEntry, concurrencyConflicts As Dictionary(Of IProperty, Object), updateLogger As IDiagnosticsLogger(Of DbLoggerCategory.Update))" />
      <MemberSignature Language="F#" Value="abstract member ThrowUpdateConcurrencyException : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, obj&gt; * Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; -&gt; unit&#xA;override this.ThrowUpdateConcurrencyException : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, obj&gt; * Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; -&gt; unit" Usage="inMemoryTable.ThrowUpdateConcurrencyException (entry, concurrencyConflicts, updateLogger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
        <Parameter Name="concurrencyConflicts" Type="System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,System.Object&gt;" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
        <Parameter Name="updateLogger" Type="Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory+Update&gt;" Index="2" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="concurrencyConflicts">To be added.</param>
        <param name="updateLogger">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public virtual void Update (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Update(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.Update(Microsoft.EntityFrameworkCore.Update.IUpdateEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Update (entry As IUpdateEntry)" />
      <MemberSignature Language="F#" Value="abstract member Update : Microsoft.EntityFrameworkCore.Update.IUpdateEntry -&gt; unit&#xA;override this.Update : Microsoft.EntityFrameworkCore.Update.IUpdateEntry -&gt; unit" Usage="inMemoryTable.Update entry" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.Update(Microsoft.EntityFrameworkCore.Update.IUpdateEntry)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2;efcore-3.0;efcore-3.1;efcore-5.0;efcore-6.0" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public virtual void Update (Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; updateLogger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Update(class Microsoft.EntityFrameworkCore.Update.IUpdateEntry entry, class Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger`1&lt;class Microsoft.EntityFrameworkCore.DbLoggerCategory/Update&gt; updateLogger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.InMemoryTable`1.Update(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger{Microsoft.EntityFrameworkCore.DbLoggerCategory.Update})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Update (entry As IUpdateEntry, updateLogger As IDiagnosticsLogger(Of DbLoggerCategory.Update))" />
      <MemberSignature Language="F#" Value="abstract member Update : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; -&gt; unit&#xA;override this.Update : Microsoft.EntityFrameworkCore.Update.IUpdateEntry * Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory.Update&gt; -&gt; unit" Usage="inMemoryTable.Update (entry, updateLogger)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.InMemory.Storage.Internal.IInMemoryTable.Update(Microsoft.EntityFrameworkCore.Update.IUpdateEntry,Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger{Microsoft.EntityFrameworkCore.DbLoggerCategory.Update})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore.InMemory</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="Microsoft.EntityFrameworkCore.Update.IUpdateEntry" Index="0" FrameworkAlternate="efcore-7.0;efcore-8.0" />
        <Parameter Name="updateLogger" Type="Microsoft.EntityFrameworkCore.Diagnostics.IDiagnosticsLogger&lt;Microsoft.EntityFrameworkCore.DbLoggerCategory+Update&gt;" Index="1" FrameworkAlternate="efcore-7.0;efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="entry">To be added.</param>
        <param name="updateLogger">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
