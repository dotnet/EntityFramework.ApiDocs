<Type Name="MaterializationInterceptionData" FullName="Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData">
  <TypeSignature Language="C#" Value="public readonly struct MaterializationInterceptionData" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MaterializationInterceptionData extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData" />
  <TypeSignature Language="VB.NET" Value="Public Structure MaterializationInterceptionData" />
  <TypeSignature Language="F#" Value="type MaterializationInterceptionData = struct" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
                A parameter object passed to <see cref="T:Microsoft.EntityFrameworkCore.Diagnostics.IMaterializationInterceptor" /> methods containing data about the instance
                being materialized.
            </summary>
    <remarks>
                See <see href="https://aka.ms/efcore-docs-diagnostics">Logging, events, and diagnostics</see> for more information and examples.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaterializationInterceptionData (Microsoft.EntityFrameworkCore.Storage.MaterializationContext materializationContext, Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,(object TypedAccessor, Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,object?&gt; Accessor)&gt; valueAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext materializationContext, class Microsoft.EntityFrameworkCore.Metadata.IEntityType entityType, class System.Collections.Generic.Dictionary`2&lt;class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase, valuetype System.ValueTuple`2&lt;object, class System.Func`2&lt;valuetype Microsoft.EntityFrameworkCore.Storage.MaterializationContext, object&gt;&gt;&gt; valueAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData.#ctor(Microsoft.EntityFrameworkCore.Storage.MaterializationContext,Microsoft.EntityFrameworkCore.Metadata.IEntityType,System.Collections.Generic.Dictionary{Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,System.ValueTuple{System.Object,System.Func{Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object}}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (materializationContext As MaterializationContext, entityType As IEntityType, valueAccessor As Dictionary(Of IPropertyBase, ValueTuple(Of Object, Func(Of MaterializationContext, Object))))" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData : Microsoft.EntityFrameworkCore.Storage.MaterializationContext * Microsoft.EntityFrameworkCore.Metadata.IEntityType * System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase, ValueTuple&lt;obj, Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext, obj&gt;&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData" Usage="new Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData (materializationContext, entityType, valueAccessor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="materializationContext" Type="Microsoft.EntityFrameworkCore.Storage.MaterializationContext" />
        <Parameter Name="entityType" Type="Microsoft.EntityFrameworkCore.Metadata.IEntityType" />
        <Parameter Name="valueAccessor" Type="System.Collections.Generic.Dictionary&lt;Microsoft.EntityFrameworkCore.Metadata.IPropertyBase,System.ValueTuple&lt;System.Object,System.Func&lt;Microsoft.EntityFrameworkCore.Storage.MaterializationContext,System.Object&gt;&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "TypedAccessor", "Accessor" })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "TypedAccessor", "Accessor" })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="materializationContext">To be added.</param>
        <param name="entityType">To be added.</param>
        <param name="valueAccessor">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.DbContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.DbContext Context" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData.Context" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Context As DbContext" />
      <MemberSignature Language="F#" Value="member this.Context : Microsoft.EntityFrameworkCore.DbContext" Usage="Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.DbContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                The current <see cref="T:Microsoft.EntityFrameworkCore.DbContext" /> instance being used.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityType">
      <MemberSignature Language="C#" Value="public Microsoft.EntityFrameworkCore.Metadata.IEntityType EntityType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.Metadata.IEntityType EntityType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData.EntityType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EntityType As IEntityType" />
      <MemberSignature Language="F#" Value="member this.EntityType : Microsoft.EntityFrameworkCore.Metadata.IEntityType" Usage="Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData.EntityType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.IEntityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                The type of the entity being materialized.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public object? GetPropertyValue (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPropertyValue(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData.GetPropertyValue(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (property As IPropertyBase) As Object" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; obj" Usage="materializationInterceptionData.GetPropertyValue property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <param name="property">The property.</param>
        <summary>
                Gets the property value for the given property.
            </summary>
        <returns>The property value.</returns>
        <remarks>
                This non-generic overload of this method will always cause a primitive or value-type property value to be boxed into
                a heap-allocated object.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public object? GetPropertyValue (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPropertyValue(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData.GetPropertyValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (propertyName As String) As Object" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : string -&gt; obj" Usage="materializationInterceptionData.GetPropertyValue propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">The property name.</param>
        <summary>
                Gets the property value for the property with the given name.
            </summary>
        <returns>The property value.</returns>
        <remarks>
                This non-generic overload of this method will always cause a primitive or value-type property value to be boxed into
                a heap-allocated object.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetPropertyValue&lt;T&gt; (Microsoft.EntityFrameworkCore.Metadata.IPropertyBase property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetPropertyValue&lt;T&gt;(class Microsoft.EntityFrameworkCore.Metadata.IPropertyBase property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData.GetPropertyValue``1(Microsoft.EntityFrameworkCore.Metadata.IPropertyBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue(Of T) (property As IPropertyBase) As T" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : Microsoft.EntityFrameworkCore.Metadata.IPropertyBase -&gt; 'T" Usage="materializationInterceptionData.GetPropertyValue property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.EntityFrameworkCore.Metadata.IPropertyBase" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="property">The property.</param>
        <summary>
                Gets the property value for the given property.
            </summary>
        <returns>The property value.</returns>
        <remarks>
                This generic overload of this method will not cause a primitive or value-type property value to be boxed into
                a heap-allocated object.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetPropertyValue&lt;T&gt; (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetPropertyValue&lt;T&gt;(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Diagnostics.MaterializationInterceptionData.GetPropertyValue``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue(Of T) (propertyName As String) As T" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : string -&gt; 'T" Usage="materializationInterceptionData.GetPropertyValue propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="propertyName">The property name.</param>
        <summary>
                Gets the property value for the property with the given name.
            </summary>
        <returns>The property value.</returns>
        <remarks>
                This generic overload of this method will not cause a primitive or value-type property value to be boxed into
                a heap-allocated object.
            </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
