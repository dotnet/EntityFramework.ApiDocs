<Type Name="ConventionContext&lt;TMetadata&gt;" FullName="Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext&lt;TMetadata&gt;">
  <TypeSignature Language="C#" Value="public class ConventionContext&lt;TMetadata&gt; : Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionContext&lt;TMetadata&gt;, Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.IReadableConventionContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ConventionContext`1&lt;TMetadata&gt; extends System.Object implements class Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionContext, class Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionContext`1&lt;!TMetadata&gt;, class Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.IReadableConventionContext" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext`1" />
  <TypeSignature Language="VB.NET" Value="Public Class ConventionContext(Of TMetadata)&#xA;Implements IConventionContext(Of TMetadata), IReadableConventionContext" />
  <TypeSignature Language="F#" Value="type ConventionContext&lt;'Metadata&gt; = class&#xA;    interface IConventionContext&lt;'Metadata&gt;&#xA;    interface IConventionContext&#xA;    interface IReadableConventionContext" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TMetadata" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionContext</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionContext&lt;TMetadata&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.IReadableConventionContext</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TMetadata">To be added.</typeparam>
    <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConventionContext (Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionDispatcher dispatcher);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionDispatcher dispatcher) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext`1.#ctor(Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionDispatcher)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dispatcher As ConventionDispatcher)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext&lt;'Metadata&gt; : Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionDispatcher -&gt; Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext&lt;'Metadata&gt;" Usage="new Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext&lt;'Metadata&gt; dispatcher" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dispatcher" Type="Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionDispatcher" />
      </Parameters>
      <Docs>
        <param name="dispatcher">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DelayConventions">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionBatch DelayConventions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionBatch DelayConventions() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext`1.DelayConventions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DelayConventions () As IConventionBatch" />
      <MemberSignature Language="F#" Value="abstract member DelayConventions : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionBatch&#xA;override this.DelayConventions : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionBatch" Usage="conventionContext.DelayConventions " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionContext.DelayConventions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionBatch</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Prevents conventions from being executed immediately when a metadata aspect is modified. All the delayed conventions
                will be executed after the returned object is disposed.
            </summary>
        <returns>An object that should be disposed to execute the delayed conventions.</returns>
        <remarks>
                This is useful when performing multiple operations that depend on each other.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public virtual void ResetState (TMetadata input);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetState(!TMetadata input) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext`1.ResetState(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetState (input As TMetadata)" />
      <MemberSignature Language="F#" Value="abstract member ResetState : 'Metadata -&gt; unit&#xA;override this.ResetState : 'Metadata -&gt; unit" Usage="conventionContext.ResetState input" />
      <MemberSignature Language="C#" Value="public virtual void ResetState (TMetadata? input);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="TMetadata" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public virtual TMetadata Result { get; }" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance !TMetadata Result" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext`1.Result" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Result As TMetadata" />
      <MemberSignature Language="F#" Value="member this.Result : 'Metadata" Usage="Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext&lt;'Metadata&gt;.Result" />
      <MemberSignature Language="C#" Value="public virtual TMetadata? Result { get; }" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldStopProcessing">
      <MemberSignature Language="C#" Value="public virtual bool ShouldStopProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldStopProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext`1.ShouldStopProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ShouldStopProcessing () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member ShouldStopProcessing : unit -&gt; bool&#xA;override this.ShouldStopProcessing : unit -&gt; bool" Usage="conventionContext.ShouldStopProcessing " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.IReadableConventionContext.ShouldStopProcessing</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopProcessing">
      <MemberSignature Language="C#" Value="public virtual void StopProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext`1.StopProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub StopProcessing ()" />
      <MemberSignature Language="F#" Value="abstract member StopProcessing : unit -&gt; unit&#xA;override this.StopProcessing : unit -&gt; unit" Usage="conventionContext.StopProcessing " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionContext.StopProcessing</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Calling this will prevent further processing of the associated event by other conventions.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopProcessing">
      <MemberSignature Language="C#" Value="public virtual void StopProcessing (TMetadata result);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopProcessing(!TMetadata result) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext`1.StopProcessing(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub StopProcessing (result As TMetadata)" />
      <MemberSignature Language="F#" Value="abstract member StopProcessing : 'Metadata -&gt; unit&#xA;override this.StopProcessing : 'Metadata -&gt; unit" Usage="conventionContext.StopProcessing result" />
      <MemberSignature Language="C#" Value="public virtual void StopProcessing (TMetadata? result);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionContext`1.StopProcessing(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="TMetadata" />
      </Parameters>
      <Docs>
        <param name="result">The new metadata object or <see langword="null" />.</param>
        <summary>
                Calling this will prevent further processing of the associated event by other conventions.
            </summary>
        <remarks>
                The common use case is when the metadata object was removed or replaced by the convention.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopProcessingIfChanged">
      <MemberSignature Language="C#" Value="public virtual void StopProcessingIfChanged (TMetadata result);" FrameworkAlternate="efcore-3.0;efcore-3.1;efcore-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopProcessingIfChanged(!TMetadata result) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal.ConventionContext`1.StopProcessingIfChanged(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub StopProcessingIfChanged (result As TMetadata)" />
      <MemberSignature Language="F#" Value="abstract member StopProcessingIfChanged : 'Metadata -&gt; unit&#xA;override this.StopProcessingIfChanged : 'Metadata -&gt; unit" Usage="conventionContext.StopProcessingIfChanged result" />
      <MemberSignature Language="C#" Value="public virtual void StopProcessingIfChanged (TMetadata? result);" FrameworkAlternate="efcore-6.0;efcore-7.0;efcore-8.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.EntityFrameworkCore.Metadata.Conventions.IConventionContext`1.StopProcessingIfChanged(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="TMetadata" />
      </Parameters>
      <Docs>
        <param name="result">The new metadata object or <see langword="null" />.</param>
        <summary>
                Calling this will prevent further processing of the associated event by other conventions
                if the given objects are different.
            </summary>
        <remarks>
                The common use case is when the metadata object was replaced by the convention.
            </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
