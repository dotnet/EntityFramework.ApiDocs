<Type Name="TypeMappingConfigurationBuilder&lt;TProperty&gt;" FullName="Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt;">
  <TypeSignature Language="C#" Value="public class TypeMappingConfigurationBuilder&lt;TProperty&gt; : Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TypeMappingConfigurationBuilder`1&lt;TProperty&gt; extends Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeMappingConfigurationBuilder(Of TProperty)&#xA;Inherits TypeMappingConfigurationBuilder" />
  <TypeSignature Language="F#" Value="type TypeMappingConfigurationBuilder&lt;'Property&gt; = class&#xA;    inherit TypeMappingConfigurationBuilder" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TProperty" />
  </TypeParameters>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TProperty">To be added.</typeparam>
    <summary>
                Provides a simple API surface for setting property defaults before conventions run.
            </summary>
    <remarks>
      <para>
                    Instances of this class are returned from methods when using the <see cref="T:Microsoft.EntityFrameworkCore.ModelConfigurationBuilder" /> API
                    and it is not designed to be directly constructed in your application code.
                </para>
      <para>
                    See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see> for more information and
                    examples.
                </para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeMappingConfigurationBuilder (Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyConfiguration scalar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyConfiguration scalar) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyConfiguration)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (scalar As PropertyConfiguration)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt; : Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyConfiguration -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt;" Usage="new Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt; scalar" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal]</AttributeName>
          <AttributeName Language="F#">[&lt;Microsoft.EntityFrameworkCore.Infrastructure.EntityFrameworkInternal&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="scalar" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyConfiguration" />
      </Parameters>
      <Docs>
        <param name="scalar">To be added.</param>
        <summary>
                This is an internal API that supports the Entity Framework Core infrastructure and not subject to
                the same compatibility standards as public APIs. It may be changed or removed without notice in
                any release. You should only use it directly in your code with extreme caution and knowing that
                doing so can result in application failures when updating to a new Entity Framework Core release.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnnotation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt; HasAnnotation (string annotation, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1&lt;!TProperty&gt; HasAnnotation(string annotation, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1.HasAnnotation(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasAnnotation (annotation As String, value As Object) As TypeMappingConfigurationBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasAnnotation : string * obj -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt;" Usage="typeMappingConfigurationBuilder.HasAnnotation (annotation, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="annotation">The key of the annotation to be added or updated.</param>
        <param name="value">The value to be stored in the annotation.</param>
        <summary>
                Adds or updates an annotation on the property. If an annotation with the key specified in
                <paramref name="annotation" /> already exists its value will be updated.
            </summary>
        <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConversion">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt; HasConversion (Type conversionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1&lt;!TProperty&gt; HasConversion(class System.Type conversionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1.HasConversion(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConversion (conversionType As Type) As TypeMappingConfigurationBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasConversion : Type -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt;" Usage="typeMappingConfigurationBuilder.HasConversion conversionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="conversionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="conversionType">The type to convert to and from or a type that derives from <see cref="T:Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />.</param>
        <summary>
                Configures the property so that the property value is converted before
                writing to the database and converted back when reading from the database.
            </summary>
        <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConversion&lt;TConversion&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt; HasConversion&lt;TConversion&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1&lt;!TProperty&gt; HasConversion&lt;TConversion&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1.HasConversion``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConversion(Of TConversion) () As TypeMappingConfigurationBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasConversion : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt;" Usage="typeMappingConfigurationBuilder.HasConversion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TConversion" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="T:Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />.</typeparam>
        <summary>
                Configures the property so that the property value is converted before
                writing to the database and converted back when reading from the database.
            </summary>
        <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasMaxLength">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt; HasMaxLength (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1&lt;!TProperty&gt; HasMaxLength(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1.HasMaxLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasMaxLength (maxLength As Integer) As TypeMappingConfigurationBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasMaxLength : int -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt;" Usage="typeMappingConfigurationBuilder.HasMaxLength maxLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">
                The maximum length of data allowed in the property. A value of <c>-1</c> indicates that the property has no maximum length.
            </param>
        <summary>
                Configures the maximum length of data that can be stored in this property.
                Maximum length can only be set on array properties (including <see cref="T:System.String" /> properties).
            </summary>
        <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrecision">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt; HasPrecision (int precision);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1&lt;!TProperty&gt; HasPrecision(int32 precision) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1.HasPrecision(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasPrecision (precision As Integer) As TypeMappingConfigurationBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasPrecision : int -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt;" Usage="typeMappingConfigurationBuilder.HasPrecision precision" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="precision">The precision of the property.</param>
        <summary>
                Configures the precision of the property.
            </summary>
        <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrecision">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt; HasPrecision (int precision, int scale);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1&lt;!TProperty&gt; HasPrecision(int32 precision, int32 scale) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1.HasPrecision(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasPrecision (precision As Integer, scale As Integer) As TypeMappingConfigurationBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasPrecision : int * int -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt;" Usage="typeMappingConfigurationBuilder.HasPrecision (precision, scale)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precision" Type="System.Int32" />
        <Parameter Name="scale" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="precision">The precision of the property.</param>
        <param name="scale">The scale of the property.</param>
        <summary>
                Configures the precision and scale of the property.
            </summary>
        <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasSentinel">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt; HasSentinel (object? sentinel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1&lt;!TProperty&gt; HasSentinel(object sentinel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1.HasSentinel(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasSentinel (sentinel As Object) As TypeMappingConfigurationBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasSentinel : obj -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt;" Usage="typeMappingConfigurationBuilder.HasSentinel sentinel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sentinel" Type="System.Object" Index="0" FrameworkAlternate="efcore-8.0" />
      </Parameters>
      <Docs>
        <param name="sentinel">The sentinel value.</param>
        <summary>
                Configures the value that will be used to determine if the property has been set or not. If the property is set to the
                sentinel value, then it is considered not set. By default, the sentinel value is the CLR default value for the type of
                the property.
            </summary>
        <returns>The same builder instance if the configuration was applied, <see langword="null" /> otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt; IsUnicode (bool unicode = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1&lt;!TProperty&gt; IsUnicode(bool unicode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder`1.IsUnicode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsUnicode (Optional unicode As Boolean = true) As TypeMappingConfigurationBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.IsUnicode : bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;'Property&gt;" Usage="typeMappingConfigurationBuilder.IsUnicode unicode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.TypeMappingConfigurationBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="unicode">A value indicating whether the property can contain unicode characters.</param>
        <summary>
                Configures the property as capable of persisting unicode characters.
                Can only be set on <see cref="T:System.String" /> properties.
            </summary>
        <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
