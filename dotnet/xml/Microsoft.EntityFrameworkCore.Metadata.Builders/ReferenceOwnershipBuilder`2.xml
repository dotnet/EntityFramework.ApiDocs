<Type Name="ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;" FullName="Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;">
  <TypeSignature Language="C#" Value="public class ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; : Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder where TEntity : class where TRelatedEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReferenceOwnershipBuilder`2&lt;class TEntity, class TRelatedEntity&gt; extends Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2" />
  <TypeSignature Language="VB.NET" Value="Public Class ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)&#xA;Inherits ReferenceOwnershipBuilder" />
  <TypeSignature Language="F#" Value="type ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt; = class&#xA;    inherit ReferenceOwnershipBuilder" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.3.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.11.0</AssemblyVersion>
    <AssemblyVersion>2.2.6.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TRelatedEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TEntity">To be added.</typeparam>
    <typeparam name="TRelatedEntity">To be added.</typeparam>
    <summary>
      <para>
                    Provides a simple API for configuring a one-to-one ownership.
                </para>
    </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReferenceOwnershipBuilder (Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType relatedEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType relatedEntityType, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (declaringEntityType As EntityType, relatedEntityType As EntityType, builder As InternalRelationshipBuilder)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt; : Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType * Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="new Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt; (declaringEntityType, relatedEntityType, builder)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="declaringEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" />
        <Parameter Name="relatedEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" />
        <Parameter Name="builder" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder" />
      </Parameters>
      <Docs>
        <param name="declaringEntityType">To be added.</param>
        <param name="relatedEntityType">To be added.</param>
        <param name="builder">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReferenceOwnershipBuilder (Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder builder, Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder oldBuilder, bool inverted = false, bool foreignKeySet = false, bool principalKeySet = false, bool requiredSet = false);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder builder, class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder oldBuilder, bool inverted, bool foreignKeySet, bool principalKeySet, bool requiredSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder,Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (builder As InternalRelationshipBuilder, oldBuilder As ReferenceOwnershipBuilder, Optional inverted As Boolean = false, Optional foreignKeySet As Boolean = false, Optional principalKeySet As Boolean = false, Optional requiredSet As Boolean = false)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt; : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder * Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder * bool * bool * bool * bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="new Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt; (builder, oldBuilder, inverted, foreignKeySet, principalKeySet, requiredSet)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder" />
        <Parameter Name="oldBuilder" Type="Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder" />
        <Parameter Name="inverted" Type="System.Boolean" />
        <Parameter Name="foreignKeySet" Type="System.Boolean" />
        <Parameter Name="principalKeySet" Type="System.Boolean" />
        <Parameter Name="requiredSet" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="builder">To be added.</param>
        <param name="oldBuilder">To be added.</param>
        <param name="inverted">To be added.</param>
        <param name="foreignKeySet">To be added.</param>
        <param name="principalKeySet">To be added.</param>
        <param name="requiredSet">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasChangeTrackingStrategy(valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasChangeTrackingStrategy(Microsoft.EntityFrameworkCore.ChangeTrackingStrategy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasChangeTrackingStrategy (changeTrackingStrategy As ChangeTrackingStrategy) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasChangeTrackingStrategy : Microsoft.EntityFrameworkCore.ChangeTrackingStrategy -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.HasChangeTrackingStrategy changeTrackingStrategy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy"> The change tracking strategy to be used. </param>
        <summary>
                Configures the <see cref="T:Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" /> to be used for this entity type.
                This strategy indicates how the context detects changes to properties for an instance of the entity type.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasData">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.DataBuilder&lt;TRelatedEntity&gt; HasData (params object[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.DataBuilder`1&lt;!TRelatedEntity&gt; HasData(object[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasData(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasData (ParamArray data As Object()) As DataBuilder(Of TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasData : obj[] -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.DataBuilder&lt;'RelatedEntity (requires 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.HasData data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.DataBuilder&lt;TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object[]" Index="0" FrameworkAlternate="efcore-2.2">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
                An array of seed data represented by anonymous types.
            </param>
        <summary>
                Configures this entity to have seed data. It is used to generate data motion migrations.
            </summary>
        <returns> An object that can be used to configure the model data. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasData">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.DataBuilder&lt;TRelatedEntity&gt; HasData (params TRelatedEntity[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.DataBuilder`1&lt;!TRelatedEntity&gt; HasData(!TRelatedEntity[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasData(`1[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasData (ParamArray data As TRelatedEntity()) As DataBuilder(Of TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasData : 'RelatedEntity[] -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.DataBuilder&lt;'RelatedEntity (requires 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.HasData data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.DataBuilder&lt;TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="TRelatedEntity[]" Index="0" FrameworkAlternate="efcore-2.1;efcore-2.2">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
                An array of seed data.
            </param>
        <summary>
                Configures this entity to have seed data. It is used to generate data motion migrations.
            </summary>
        <returns> An object that can be used to configure the model data. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasEntityTypeAnnotation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasEntityTypeAnnotation (string annotation, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasEntityTypeAnnotation(string annotation, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasEntityTypeAnnotation(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasEntityTypeAnnotation (annotation As String, value As Object) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasEntityTypeAnnotation : string * obj -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.HasEntityTypeAnnotation (annotation, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="annotation"> The key of the annotation to be added or updated. </param>
        <param name="value"> The value to be stored in the annotation. </param>
        <summary>
                Adds or updates an annotation on the owned entity type. If an annotation with the key specified in
                <paramref name="annotation" /> already exists its value will be updated.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasForeignKey (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,object&gt;&gt; foreignKeyExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasForeignKey(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, object&gt;&gt; foreignKeyExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasForeignKey(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasForeignKey (foreignKeyExpression As Expression(Of Func(Of TRelatedEntity, Object))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasForeignKey : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, obj&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.HasForeignKey foreignKeyExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKeyExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="foreignKeyExpression">
          <para>
                    A lambda expression representing the foreign key property(s) (<c>t =&gt; t.Id1</c>).
                </para>
          <para>
                    If the foreign key is made up of multiple properties then specify an anonymous type including the
                    properties (<c>t =&gt; new { t.Id1, t.Id2 }</c>). The order specified should match the order of
                    corresponding properties in <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})" />.
                </para>
        </param>
        <summary>
          <para>
                    Configures the property(s) to use as the foreign key for this relationship.
                </para>
          <para>
                    If the specified property name(s) do not exist on the entity type then a new shadow state
                    property(s) will be added to serve as the foreign key. A shadow state property is one
                    that does not have a corresponding property in the entity class. The current value for the
                    property is stored in the <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker" /> rather than being stored in instances
                    of the entity class.
                </para>
          <para>
                    If <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})" /> is not specified, then an
                    attempt will be made to match the data type and order of foreign key properties against the primary
                    key of the principal entity type. If they do not match, new shadow state properties that form a
                    unique index will be added to the principal entity type to serve as the reference key.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasForeignKey (params string[] foreignKeyPropertyNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasForeignKey(string[] foreignKeyPropertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasForeignKey(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasForeignKey (ParamArray foreignKeyPropertyNames As String()) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasForeignKey : string[] -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.HasForeignKey foreignKeyPropertyNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKeyPropertyNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="foreignKeyPropertyNames">
                The name(s) of the foreign key property(s).
            </param>
        <summary>
          <para>
                    Configures the property(s) to use as the foreign key for this relationship.
                </para>
          <para>
                    If the specified property name(s) do not exist on the entity type then a new shadow state
                    property(s) will be added to serve as the foreign key. A shadow state property is one
                    that does not have a corresponding property in the entity class. The current value for the
                    property is stored in the <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker" /> rather than being stored in instances
                    of the entity class.
                </para>
          <para>
                    If <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.String[])" /> is not specified, then an attempt will be made to
                    match the data type and order of foreign key properties against the primary key of the principal
                    entity type. If they do not match, new shadow state properties that form a unique index will be
                    added to the principal entity type to serve as the reference key.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasForeignKeyAnnotation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasForeignKeyAnnotation (string annotation, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasForeignKeyAnnotation(string annotation, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasForeignKeyAnnotation(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasForeignKeyAnnotation (annotation As String, value As Object) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasForeignKeyAnnotation : string * obj -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.HasForeignKeyAnnotation (annotation, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="annotation"> The key of the annotation to be added or updated. </param>
        <param name="value"> The value to be stored in the annotation. </param>
        <summary>
                Adds or updates an annotation on the foreign key. If an annotation with the key specified in
                <paramref name="annotation" /> already exists its value will be updated.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.IndexBuilder HasIndex (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,object&gt;&gt; indexExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IndexBuilder HasIndex(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, object&gt;&gt; indexExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasIndex(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasIndex (indexExpression As Expression(Of Func(Of TRelatedEntity, Object))) As IndexBuilder" />
      <MemberSignature Language="F#" Value="override this.HasIndex : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, obj&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.IndexBuilder" Usage="referenceOwnershipBuilder.HasIndex indexExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IndexBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="indexExpression">
          <para>
                    A lambda expression representing the property(s) to be included in the index
                    (<c>blog =&gt; blog.Url</c>).
                </para>
          <para>
                    If the index is made up of multiple properties then specify an anonymous type including the
                    properties (<c>post =&gt; new { post.Title, post.BlogId }</c>).
                </para>
        </param>
        <summary>
                Configures an index on the specified properties. If there is an existing index on the given
                set of properties, then the existing index will be returned for configuration.
            </summary>
        <returns> An object that can be used to configure the index. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.KeyBuilder HasKey (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,object&gt;&gt; keyExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.KeyBuilder HasKey(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, object&gt;&gt; keyExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasKey(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasKey (keyExpression As Expression(Of Func(Of TRelatedEntity, Object))) As KeyBuilder" />
      <MemberSignature Language="F#" Value="override this.HasKey : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, obj&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.KeyBuilder" Usage="referenceOwnershipBuilder.HasKey keyExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.KeyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Object&gt;&gt;" Index="0" FrameworkAlternate="efcore-2.2" />
      </Parameters>
      <Docs>
        <param name="keyExpression">
          <para>
                    A lambda expression representing the primary key property(s) (<c>blog =&gt; blog.Url</c>).
                </para>
          <para>
                    If the primary key is made up of multiple properties then specify an anonymous type including the
                    properties (<c>post =&gt; new { post.Title, post.BlogId }</c>).
                </para>
        </param>
        <summary>
                Sets the properties that make up the primary key for this owned entity type.
            </summary>
        <returns> An object that can be used to configure the primary key. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasMany&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt; HasMany&lt;TNewRelatedEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,System.Collections.Generic.IEnumerable&lt;TNewRelatedEntity&gt;&gt;&gt; navigationExpression = default) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionNavigationBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt; HasMany&lt;class TNewRelatedEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, class System.Collections.Generic.IEnumerable`1&lt;!!TNewRelatedEntity&gt;&gt;&gt; navigationExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasMany``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasMany(Of TNewRelatedEntity As Class) (Optional navigationExpression As Expression(Of Func(Of TRelatedEntity, IEnumerable(Of TNewRelatedEntity))) = Nothing) As CollectionNavigationBuilder(Of TRelatedEntity, TNewRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasMany : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, seq&lt;'NewRelatedEntity&gt;&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionNavigationBuilder&lt;'RelatedEntity, 'NewRelatedEntity (requires 'RelatedEntity : null and 'NewRelatedEntity : null)&gt; (requires 'NewRelatedEntity : null)" Usage="referenceOwnershipBuilder.HasMany navigationExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Collections.Generic.IEnumerable&lt;TNewRelatedEntity&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the collection navigation property on this entity type that represents
                the relationship (<c>blog =&gt; blog.Posts</c>). If no property is specified, the relationship will be
                configured without a navigation property on this end.
            </param>
        <summary>
          <para>
                    Configures a relationship where this entity type has a collection that contains
                    instances of the other type in the relationship.
                </para>
          <para>
                    Note that calling this method with no parameters will explicitly configure this side
                    of the relationship to use no navigation property, even if such a property exists on the
                    entity type. If the navigation property is to be used, then it must be specified.
                </para>
          <para>
                    After calling this method, you should chain a call to
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionNavigationBuilder`2.WithOne(System.Linq.Expressions.Expression{System.Func{`1,`0}})" />
                    to fully configure the relationship. Calling just this method without the chained call will not
                    produce a valid relationship.
                </para>
        </summary>
        <returns> An object that can be used to configure the relationship. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasOne&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt; HasOne&lt;TNewRelatedEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt; navigationExpression = default) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt; HasOne&lt;class TNewRelatedEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt;&gt; navigationExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasOne``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasOne(Of TNewRelatedEntity As Class) (Optional navigationExpression As Expression(Of Func(Of TRelatedEntity, TNewRelatedEntity)) = Nothing) As ReferenceNavigationBuilder(Of TRelatedEntity, TNewRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasOne : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, 'NewRelatedEntity&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder&lt;'RelatedEntity, 'NewRelatedEntity (requires 'RelatedEntity : null and 'NewRelatedEntity : null)&gt; (requires 'NewRelatedEntity : null)" Usage="referenceOwnershipBuilder.HasOne navigationExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the reference navigation property on this entity type that represents
                the relationship (<c>post =&gt; post.Blog</c>). If no property is specified, the relationship will be
                configured without a navigation property on this end.
            </param>
        <summary>
          <para>
                    Configures a relationship where this entity type has a reference that points
                    to a single instance of the other type in the relationship.
                </para>
          <para>
                    Note that calling this method with no parameters will explicitly configure this side
                    of the relationship to use no navigation property, even if such a property exists on the
                    entity type. If the navigation property is to be used, then it must be specified.
                </para>
          <para>
                    After calling this method, you should chain a call to
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder`2.WithMany(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{`0}}})" />
                    or
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder`2.WithOne(System.Linq.Expressions.Expression{System.Func{`1,`0}})" />
                    to fully configure the relationship. Calling just this method without the chained call will not
                    produce a valid relationship.
                </para>
        </summary>
        <returns> An object that can be used to configure the relationship. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasOne&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt; HasOne&lt;TNewRelatedEntity&gt; (string navigationName) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt; HasOne&lt;class TNewRelatedEntity&gt;(string navigationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasOne``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasOne(Of TNewRelatedEntity As Class) (navigationName As String) As ReferenceNavigationBuilder(Of TRelatedEntity, TNewRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasOne : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder&lt;'RelatedEntity, 'NewRelatedEntity (requires 'RelatedEntity : null and 'NewRelatedEntity : null)&gt; (requires 'NewRelatedEntity : null)" Usage="referenceOwnershipBuilder.HasOne navigationName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.2" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationName">
                The name of the reference navigation property on this entity type that represents the relationship. If
                no property is specified, the relationship will be configured without a navigation property on this
                end.
            </param>
        <summary>
          <para>
                    Configures a relationship where this entity type has a reference that points
                    to a single instance of the other type in the relationship.
                </para>
          <para>
                    Note that calling this method with no parameters will explicitly configure this side
                    of the relationship to use no navigation property, even if such a property exists on the
                    entity type. If the navigation property is to be used, then it must be specified.
                </para>
          <para>
                    After calling this method, you should chain a call to
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder`2.WithMany(System.String)" />
                    or
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder`2.WithOne(System.String)" />
                    to fully configure the relationship. Calling just this method without the chained call will not
                    produce a valid relationship.
                </para>
        </summary>
        <returns> An object that can be used to configure the relationship. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrincipalKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasPrincipalKey (System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; keyExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasPrincipalKey(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TEntity, object&gt;&gt; keyExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasPrincipalKey (keyExpression As Expression(Of Func(Of TEntity, Object))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasPrincipalKey : System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.HasPrincipalKey keyExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="keyExpression">
          <para>
                    A lambda expression representing the reference key property(s) (<c>t =&gt; t.Id</c>).
                </para>
          <para>
                    If the principal key is made up of multiple properties then specify an anonymous type including the
                    properties (<c>t =&gt; new { t.Id1, t.Id2 }</c>). The order specified should match the order of
                    corresponding properties in <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasForeignKey(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})" />.
                </para>
        </param>
        <summary>
                Configures the unique property(s) that this relationship targets. Typically you would only call this
                method if you want to use a property(s) other than the primary key as the principal property(s). If
                the specified property(s) is not already a unique constraint (or the primary key) then a new unique
                constraint will be introduced.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>
          <para>
                    If multiple principal key properties are specified, the order of principal key properties should
                    match the order that the primary key or unique constraint properties were configured on the principal
                    entity type.
                </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrincipalKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasPrincipalKey (params string[] keyPropertyNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasPrincipalKey(string[] keyPropertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasPrincipalKey (ParamArray keyPropertyNames As String()) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.HasPrincipalKey : string[] -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.HasPrincipalKey keyPropertyNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyPropertyNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="keyPropertyNames"> The name(s) of the reference key property(s). </param>
        <summary>
                Configures the unique property(s) that this relationship targets. Typically you would only call this
                method if you want to use a property(s) other than the primary key as the principal property(s). If
                the specified property(s) is not already a unique constraint (or the primary key) then a new unique
                constraint will be introduced.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>
          <para>
                    If multiple principal key properties are specified, the order of principal key properties should
                    match the order that the primary key or unique constraint properties were configured on the principal
                    entity type.
                </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; Ignore (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,object&gt;&gt; propertyExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; Ignore(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, object&gt;&gt; propertyExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.Ignore(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Ignore (propertyExpression As Expression(Of Func(Of TRelatedEntity, Object))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.Ignore : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, obj&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.Ignore propertyExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyExpression">
                A lambda expression representing the property to be ignored
                (<c>blog =&gt; blog.Url</c>).
            </param>
        <summary>
                Excludes the given property from the entity type. This method is typically used to remove properties
                from the owned entity type that were added by convention.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; Ignore (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; Ignore(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.Ignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Ignore (propertyName As String) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.Ignore : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.Ignore propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName"> The name of then property to be removed from the entity type. </param>
        <summary>
                Excludes the given property from the entity type. This method is typically used to remove properties
                from the owned entity type that were added by convention.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDelete">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; OnDelete (Microsoft.EntityFrameworkCore.DeleteBehavior deleteBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; OnDelete(valuetype Microsoft.EntityFrameworkCore.DeleteBehavior deleteBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OnDelete(Microsoft.EntityFrameworkCore.DeleteBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OnDelete (deleteBehavior As DeleteBehavior) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.OnDelete : Microsoft.EntityFrameworkCore.DeleteBehavior -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.OnDelete deleteBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deleteBehavior" Type="Microsoft.EntityFrameworkCore.DeleteBehavior" />
      </Parameters>
      <Docs>
        <param name="deleteBehavior"> The action to perform. </param>
        <summary>
                Configures how a delete operation is applied to dependent entities in the relationship when the
                principal is deleted or the relationship is severed.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsMany&lt;TDependentEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;TRelatedEntity,TDependentEntity&gt; OwnsMany&lt;TDependentEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,System.Collections.Generic.IEnumerable&lt;TDependentEntity&gt;&gt;&gt; navigationExpression) where TDependentEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder`2&lt;!TRelatedEntity, !!TDependentEntity&gt; OwnsMany&lt;class TDependentEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, class System.Collections.Generic.IEnumerable`1&lt;!!TDependentEntity&gt;&gt;&gt; navigationExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsMany``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsMany(Of TDependentEntity As Class) (navigationExpression As Expression(Of Func(Of TRelatedEntity, IEnumerable(Of TDependentEntity)))) As CollectionOwnershipBuilder(Of TRelatedEntity, TDependentEntity)" />
      <MemberSignature Language="F#" Value="override this.OwnsMany : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, seq&lt;'DependentEntity&gt;&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;'RelatedEntity, 'DependentEntity (requires 'RelatedEntity : null and 'DependentEntity : null)&gt; (requires 'DependentEntity : null)" Usage="referenceOwnershipBuilder.OwnsMany navigationExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;TRelatedEntity,TDependentEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDependentEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Collections.Generic.IEnumerable&lt;TDependentEntity&gt;&gt;&gt;" Index="0" FrameworkAlternate="efcore-2.2" />
      </Parameters>
      <Docs>
        <typeparam name="TDependentEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the reference navigation property on this entity type that represents
                the relationship (<c>customer =&gt; customer.Address</c>).
            </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the owned type and the relationship. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsMany&lt;TDependentEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;TRelatedEntity,TDependentEntity&gt; OwnsMany&lt;TDependentEntity&gt; (string navigationName) where TDependentEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder`2&lt;!TRelatedEntity, !!TDependentEntity&gt; OwnsMany&lt;class TDependentEntity&gt;(string navigationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsMany``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsMany(Of TDependentEntity As Class) (navigationName As String) As CollectionOwnershipBuilder(Of TRelatedEntity, TDependentEntity)" />
      <MemberSignature Language="F#" Value="override this.OwnsMany : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;'RelatedEntity, 'DependentEntity (requires 'RelatedEntity : null and 'DependentEntity : null)&gt; (requires 'DependentEntity : null)" Usage="referenceOwnershipBuilder.OwnsMany navigationName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;TRelatedEntity,TDependentEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDependentEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.2" />
      </Parameters>
      <Docs>
        <typeparam name="TDependentEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationName">
                The name of the reference navigation property on this entity type that represents the relationship.
            </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the owned type and the relationship. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsMany&lt;TDependentEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; OwnsMany&lt;TDependentEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,System.Collections.Generic.IEnumerable&lt;TDependentEntity&gt;&gt;&gt; navigationExpression, Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;TRelatedEntity,TDependentEntity&gt;&gt; buildAction) where TDependentEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; OwnsMany&lt;class TDependentEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, class System.Collections.Generic.IEnumerable`1&lt;!!TDependentEntity&gt;&gt;&gt; navigationExpression, class System.Action`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder`2&lt;!TRelatedEntity, !!TDependentEntity&gt;&gt; buildAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsMany``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}},System.Action{Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsMany(Of TDependentEntity As Class) (navigationExpression As Expression(Of Func(Of TRelatedEntity, IEnumerable(Of TDependentEntity))), buildAction As Action(Of CollectionOwnershipBuilder(Of TRelatedEntity, TDependentEntity))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.OwnsMany : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, seq&lt;'DependentEntity&gt;&gt;&gt; * Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;'RelatedEntity, 'DependentEntity&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt; (requires 'DependentEntity : null)" Usage="referenceOwnershipBuilder.OwnsMany (navigationExpression, buildAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDependentEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Collections.Generic.IEnumerable&lt;TDependentEntity&gt;&gt;&gt;" Index="0" FrameworkAlternate="efcore-2.2" />
        <Parameter Name="buildAction" Type="System.Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;TRelatedEntity,TDependentEntity&gt;&gt;" Index="1" FrameworkAlternate="efcore-2.2" />
      </Parameters>
      <Docs>
        <typeparam name="TDependentEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the reference navigation property on this entity type that represents
                the relationship (<c>customer =&gt; customer.Address</c>).
            </param>
        <param name="buildAction"> An action that performs configuration of the owned type and the relationship. </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the entity type. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsMany&lt;TDependentEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; OwnsMany&lt;TDependentEntity&gt; (string navigationName, Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;TRelatedEntity,TDependentEntity&gt;&gt; buildAction) where TDependentEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; OwnsMany&lt;class TDependentEntity&gt;(string navigationName, class System.Action`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder`2&lt;!TRelatedEntity, !!TDependentEntity&gt;&gt; buildAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsMany``1(System.String,System.Action{Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsMany(Of TDependentEntity As Class) (navigationName As String, buildAction As Action(Of CollectionOwnershipBuilder(Of TRelatedEntity, TDependentEntity))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.OwnsMany : string * Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;'RelatedEntity, 'DependentEntity&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt; (requires 'DependentEntity : null)" Usage="referenceOwnershipBuilder.OwnsMany (navigationName, buildAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDependentEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.2" />
        <Parameter Name="buildAction" Type="System.Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionOwnershipBuilder&lt;TRelatedEntity,TDependentEntity&gt;&gt;" Index="1" FrameworkAlternate="efcore-2.2" />
      </Parameters>
      <Docs>
        <typeparam name="TDependentEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationName">
                The name of the reference navigation property on this entity type that represents the relationship.
            </param>
        <param name="buildAction"> An action that performs configuration of the owned type and the relationship. </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the entity type. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsOne&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt; OwnsOne&lt;TNewRelatedEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt; navigationExpression) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt; OwnsOne&lt;class TNewRelatedEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt;&gt; navigationExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsOne``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsOne(Of TNewRelatedEntity As Class) (navigationExpression As Expression(Of Func(Of TRelatedEntity, TNewRelatedEntity))) As ReferenceOwnershipBuilder(Of TRelatedEntity, TNewRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.OwnsOne : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, 'NewRelatedEntity&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'RelatedEntity, 'NewRelatedEntity (requires 'RelatedEntity : null and 'NewRelatedEntity : null)&gt; (requires 'NewRelatedEntity : null)" Usage="referenceOwnershipBuilder.OwnsOne navigationExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the reference navigation property on this entity type that represents
                the relationship (<c>customer =&gt; customer.Address</c>).
            </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                    The target entity key value is always propagated from the entity it belongs to.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the entity type. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsOne&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt; OwnsOne&lt;TNewRelatedEntity&gt; (string navigationName) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt; OwnsOne&lt;class TNewRelatedEntity&gt;(string navigationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsOne``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsOne(Of TNewRelatedEntity As Class) (navigationName As String) As ReferenceOwnershipBuilder(Of TRelatedEntity, TNewRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.OwnsOne : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'RelatedEntity, 'NewRelatedEntity (requires 'RelatedEntity : null and 'NewRelatedEntity : null)&gt; (requires 'NewRelatedEntity : null)" Usage="referenceOwnershipBuilder.OwnsOne navigationName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.2" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationName">
                The name of the reference navigation property on this entity type that represents the relationship.
            </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                    The target entity key value is always propagated from the entity it belongs to.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the entity type. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsOne&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; OwnsOne&lt;TNewRelatedEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt; navigationExpression, Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt; buildAction) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; OwnsOne&lt;class TNewRelatedEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt;&gt; navigationExpression, class System.Action`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt;&gt; buildAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsOne``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Action{Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsOne(Of TNewRelatedEntity As Class) (navigationExpression As Expression(Of Func(Of TRelatedEntity, TNewRelatedEntity)), buildAction As Action(Of ReferenceOwnershipBuilder(Of TRelatedEntity, TNewRelatedEntity))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.OwnsOne : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, 'NewRelatedEntity&gt;&gt; * Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'RelatedEntity, 'NewRelatedEntity&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt; (requires 'NewRelatedEntity : null)" Usage="referenceOwnershipBuilder.OwnsOne (navigationExpression, buildAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt;" />
        <Parameter Name="buildAction" Type="System.Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the reference navigation property on this entity type that represents
                the relationship (<c>customer =&gt; customer.Address</c>).
            </param>
        <param name="buildAction"> An action that performs configuration of the relationship. </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                    The target entity key value is always propagated from the entity it belongs to.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the entity type. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsOne&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; OwnsOne&lt;TNewRelatedEntity&gt; (string navigationName, Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt; buildAction) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; OwnsOne&lt;class TNewRelatedEntity&gt;(string navigationName, class System.Action`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt;&gt; buildAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsOne``1(System.String,System.Action{Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsOne(Of TNewRelatedEntity As Class) (navigationName As String, buildAction As Action(Of ReferenceOwnershipBuilder(Of TRelatedEntity, TNewRelatedEntity))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.OwnsOne : string * Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'RelatedEntity, 'NewRelatedEntity&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt; (requires 'NewRelatedEntity : null)" Usage="referenceOwnershipBuilder.OwnsOne (navigationName, buildAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationName" Type="System.String" Index="0" FrameworkAlternate="efcore-2.2" />
        <Parameter Name="buildAction" Type="System.Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt;" Index="1" FrameworkAlternate="efcore-2.2" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationName">
                The name of the reference navigation property on this entity type that represents the relationship.
            </param>
        <param name="buildAction"> An action that performs configuration of the relationship. </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                    The target entity key value is always propagated from the entity it belongs to.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the entity type. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property&lt;TProperty&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; Property&lt;TProperty&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,TProperty&gt;&gt; propertyExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!!TProperty&gt; Property&lt;TProperty&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, !!TProperty&gt;&gt; propertyExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.Property``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Property(Of TProperty) (propertyExpression As Expression(Of Func(Of TRelatedEntity, TProperty))) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.Property : System.Linq.Expressions.Expression&lt;Func&lt;'RelatedEntity, 'Property&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="referenceOwnershipBuilder.Property propertyExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProperty" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="propertyExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,TProperty&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TProperty"> The type of the property to be configured. </typeparam>
        <param name="propertyExpression">
                A lambda expression representing the property to be configured (
                <c>blog =&gt; blog.Url</c>).
            </param>
        <summary>
          <para>
                    Returns an object that can be used to configure a property of the owned entity type.
                    If no property with the given name exists, then a new property will be added.
                </para>
          <para>
                    When adding a new property, if a property with the same name exists in the entity class
                    then it will be added to the model. If no property exists in the entity class, then
                    a new shadow state property will be added. A shadow state property is one that does not have a
                    corresponding property in the entity class. The current value for the property is stored in
                    the <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker" /> rather than being stored in instances of the entity class.
                </para>
        </summary>
        <returns> An object that can be used to configure the property. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UsePropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; UsePropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; UsePropertyAccessMode(valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.UsePropertyAccessMode(Microsoft.EntityFrameworkCore.PropertyAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UsePropertyAccessMode (propertyAccessMode As PropertyAccessMode) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberSignature Language="F#" Value="override this.UsePropertyAccessMode : Microsoft.EntityFrameworkCore.PropertyAccessMode -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;'Entity, 'RelatedEntity (requires 'Entity : null and 'RelatedEntity : null)&gt;" Usage="referenceOwnershipBuilder.UsePropertyAccessMode propertyAccessMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.3.0</AssemblyVersion>
        <AssemblyVersion>2.1.11.0</AssemblyVersion>
        <AssemblyVersion>2.2.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="Microsoft.EntityFrameworkCore.PropertyAccessMode" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode"> The <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> to use for properties of this entity type. </param>
        <summary>
          <para>
                    Sets the <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> to use for all properties of this entity type.
                </para>
          <para>
                    By default, the backing field, if one is found by convention or has been specified, is used when
                    new objects are constructed, typically when entities are queried from the database.
                    Properties are used for all other accesses.  Calling this method will change that behavior
                    for all properties of this entity type as described in the <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> enum.
                </para>
          <para>
                    Calling this method overrides for all properties of this entity type any access mode that was
                    set on the model.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
